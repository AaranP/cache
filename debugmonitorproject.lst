680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 29 Feb 2024      Time: 21:49:39          Source: C:\M68KV6.0 - 800BY480\DEBUGMONITORPROJECT.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ;StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0B00 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0B00 
00000486  00C4      
00000488  23FC 0B00  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  05AA 0B00 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  2D7C      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0B00  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0B00  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0B00  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0B00  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0B00 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0B00  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0B00  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0B00  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0B00  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0B00  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0B00  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0B00  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0B00  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0B00  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0B00  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0B00  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0B00  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0B00  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0B00  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0B00  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0B00  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0B00  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0B00  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0B00  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0B00  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0B00  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0B00  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0B00  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0B00  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0B00  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0B00  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0B00  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0B00  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0B00  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0B00  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0B00  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0B00  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0B00  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0B00  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0B00  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0B00  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0B00  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0B00  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0B00  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0B00  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0B00  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0B00  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0B00  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0B00  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0B00  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0B00  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0B00  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0B00  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0B00  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0B00  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0B00  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0B00  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0B00  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0B00  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0B00  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0B00 
00000714  00D8      
00000716  33DF 0B00  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0B00  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0B00  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0B00  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0B00  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0B00  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0B00  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0B00  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0B00  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0B00  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0B00  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0B00  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0B00  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0B00  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0B00  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0B00  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0B00  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0B00  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0B00  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0B00  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0B00  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0B00  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0B00  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0B00  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0B00  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0B00  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0B00  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0B00  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0B00  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0B00  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0B00  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0B00  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0B00  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0B00  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0B00  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0B00  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0B00  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  251E      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0B00  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0B00  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0B00  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0B00  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0B00  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0B00  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0B00  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0B00  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0B00  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0B00  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0B00  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0B00  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0B00  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0B00  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0B00  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0B00  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0B00  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0B00  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0B00  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0B00  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0B00  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0B00  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0B00  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0B00  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0B00  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0B00  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0B00  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0B00  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0B00  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; #include "DebugMonitor.h"
                     471   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     472   ; //#define StartOfExceptionVectorTable 0x08030000
                     473   ; #define StartOfExceptionVectorTable 0x0B000000
                     474   ; // use 0C000000 for dram or hex 08040000 for sram
                     475   ; //#define TopOfStack 0x08040000
                     476   ; #define TopOfStack 0x0C000000
                     477   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     478   ; unsigned int i, x, y, z, PortA_Count;
                     479   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     480   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     481   ; unsigned int d0,d1,d2,d3,d4,d5,d6,d7 ;
                     482   ; unsigned int a0,a1,a2,a3,a4,a5,a6 ;
                     483   ; unsigned int PC, SSP, USP ;
                     484   ; unsigned short int SR;
                     485   ; // Breakpoint variables
                     486   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     487   ; unsigned short int BreakPointInstruction[8] ;           // to hold the instruction opcode at the breakpoint
                     488   ; unsigned int BreakPointSetOrCleared[8] ;
                     489   ; unsigned int InstructionSize ;
                     490   ; // watchpoint variables
                     491   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     492   ; unsigned int WatchPointSetOrCleared[8] ;
                     493   ; char WatchPointString[8][100] ;
                     494   ; // for disassembly of program
                     495   ; char    Instruction[100] ;
                     496   ; char    TempString[100] ;
                     497   ; /************************************************************************************
                     498   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     499   ; ************************************************************************************/
                     500   ; void Wait1ms(void)
                     501   ; {
                     502   _Wait1ms:
00000932  2F02       503          move.l    D2,-(A7)
                     504   ; long int  i ;
                     505   ; for(i = 0; i < 1000; i ++)
00000934  4282       506          clr.l     D2
                     507   Wait1ms_1:
00000936  0C82 0000  508          cmp.l     #1000,D2
0000093A  03E8      
0000093C  6C04       509          bge.s     Wait1ms_3
0000093E  5282       510          addq.l    #1,D2
00000940  60F4       511          bra       Wait1ms_1
                     512   Wait1ms_3:
00000942  241F       513          move.l    (A7)+,D2
00000944  4E75       514          rts
                     515   ; ;
                     516   ; }
                     517   ; /************************************************************************************
                     518   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     519   ; **************************************************************************************/
                     520   ; void Wait3ms(void)
                     521   ; {
                     522   _Wait3ms:
00000946  2F02       523          move.l    D2,-(A7)
                     524   ; int i ;
                     525   ; for(i = 0; i < 3; i++)
00000948  4282       526          clr.l     D2
                     527   Wait3ms_1:
0000094A  0C82 0000  528          cmp.l     #3,D2
0000094E  0003      
00000950  6C08       529          bge.s     Wait3ms_3
                     530   ; Wait1ms() ;
00000952  4EB8 0932  531          jsr       _Wait1ms
00000956  5282       532          addq.l    #1,D2
00000958  60F0       533          bra       Wait3ms_1
                     534   Wait3ms_3:
0000095A  241F       535          move.l    (A7)+,D2
0000095C  4E75       536          rts
                     537   ; }
                     538   ; /*********************************************************************************************
                     539   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     540   ; *********************************************************************************************/
                     541   ; void Init_LCD(void)
                     542   ; {
                     543   _Init_LCD:
                     544   ; LCDcommand = (char)(0x0c) ;
0000095E  13FC 000C  545          move.b    #12,4194336
00000962  0040 0020 
                     546   ; Wait3ms() ;
00000966  4EB8 0946  547          jsr       _Wait3ms
                     548   ; LCDcommand = (char)(0x38) ;
0000096A  13FC 0038  549          move.b    #56,4194336
0000096E  0040 0020 
                     550   ; Wait3ms() ;
00000972  4EB8 0946  551          jsr       _Wait3ms
00000976  4E75       552          rts
                     553   ; }
                     554   ; /******************************************************************************
                     555   ; *subroutine to output a single character held in d1 to the LCD display
                     556   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     557   ; *current cursor position
                     558   ; *******************************************************************************/
                     559   ; void Outchar(int c)
                     560   ; {
                     561   _Outchar:
00000978  4E56 0000  562          link      A6,#0
                     563   ; LCDdata = (char)(c);
0000097C  202E 0008  564          move.l    8(A6),D0
00000980  13C0 0040  565          move.b    D0,4194338
00000984  0022      
                     566   ; Wait1ms() ;
00000986  4EB8 0932  567          jsr       _Wait1ms
0000098A  4E5E       568          unlk      A6
0000098C  4E75       569          rts
                     570   ; }
                     571   ; /**********************************************************************************
                     572   ; *subroutine to output a message at the current cursor position of the LCD display
                     573   ; ************************************************************************************/
                     574   ; void OutMess(char *theMessage)
                     575   ; {
                     576   _OutMess:
0000098E  4E56 FFFC  577          link      A6,#-4
                     578   ; char c ;
                     579   ; while((c = *theMessage++) != (char)(0))
                     580   OutMess_1:
00000992  206E 0008  581          move.l    8(A6),A0
00000996  52AE 0008  582          addq.l    #1,8(A6)
0000099A  1D50 FFFF  583          move.b    (A0),-1(A6)
0000099E  1010       584          move.b    (A0),D0
000009A0  6712       585          beq.s     OutMess_3
                     586   ; Outchar(c) ;
000009A2  122E FFFF  587          move.b    -1(A6),D1
000009A6  4881       588          ext.w     D1
000009A8  48C1       589          ext.l     D1
000009AA  2F01       590          move.l    D1,-(A7)
000009AC  4EB8 0978  591          jsr       _Outchar
000009B0  584F       592          addq.w    #4,A7
000009B2  60DE       593          bra       OutMess_1
                     594   OutMess_3:
000009B4  4E5E       595          unlk      A6
000009B6  4E75       596          rts
                     597   ; }
                     598   ; /******************************************************************************
                     599   ; *subroutine to clear the line by issuing 24 space characters
                     600   ; *******************************************************************************/
                     601   ; void Clearln(void)
                     602   ; {
                     603   _Clearln:
000009B8  2F02       604          move.l    D2,-(A7)
                     605   ; unsigned char i ;
                     606   ; for(i = 0; i < 24; i ++)
000009BA  4202       607          clr.b     D2
                     608   Clearln_1:
000009BC  0C02 0018  609          cmp.b     #24,D2
000009C0  640E       610          bhs.s     Clearln_3
                     611   ; Outchar(' ') ;  /* write a space char to the LCD display */
000009C2  4878 0020  612          pea       32
000009C6  4EB8 0978  613          jsr       _Outchar
000009CA  584F       614          addq.w    #4,A7
000009CC  5202       615          addq.b    #1,D2
000009CE  60EC       616          bra       Clearln_1
                     617   Clearln_3:
000009D0  241F       618          move.l    (A7)+,D2
000009D2  4E75       619          rts
                     620   ; }
                     621   ; /******************************************************************************
                     622   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     623   ; *******************************************************************************/
                     624   ; void Oline0(char *theMessage)
                     625   ; {
                     626   _Oline0:
000009D4  4E56 0000  627          link      A6,#0
                     628   ; LCDcommand = (char)(0x80) ;
000009D8  13FC 0080  629          move.b    #128,4194336
000009DC  0040 0020 
                     630   ; Wait3ms();
000009E0  4EB8 0946  631          jsr       _Wait3ms
                     632   ; Clearln() ;
000009E4  4EB8 09B8  633          jsr       _Clearln
                     634   ; LCDcommand = (char)(0x80) ;
000009E8  13FC 0080  635          move.b    #128,4194336
000009EC  0040 0020 
                     636   ; Wait3ms() ;
000009F0  4EB8 0946  637          jsr       _Wait3ms
                     638   ; OutMess(theMessage) ;
000009F4  2F2E 0008  639          move.l    8(A6),-(A7)
000009F8  4EB8 098E  640          jsr       _OutMess
000009FC  584F       641          addq.w    #4,A7
000009FE  4E5E       642          unlk      A6
00000A00  4E75       643          rts
                     644   ; }
                     645   ; /******************************************************************************
                     646   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     647   ; *******************************************************************************/
                     648   ; void Oline1(char *theMessage)
                     649   ; {
                     650   _Oline1:
00000A02  4E56 0000  651          link      A6,#0
                     652   ; LCDcommand = (char)(0xC0) ;
00000A06  13FC 00C0  653          move.b    #192,4194336
00000A0A  0040 0020 
                     654   ; Wait3ms();
00000A0E  4EB8 0946  655          jsr       _Wait3ms
                     656   ; Clearln() ;
00000A12  4EB8 09B8  657          jsr       _Clearln
                     658   ; LCDcommand = (char)(0xC0) ;
00000A16  13FC 00C0  659          move.b    #192,4194336
00000A1A  0040 0020 
                     660   ; Wait3ms() ;
00000A1E  4EB8 0946  661          jsr       _Wait3ms
                     662   ; OutMess(theMessage) ;
00000A22  2F2E 0008  663          move.l    8(A6),-(A7)
00000A26  4EB8 098E  664          jsr       _OutMess
00000A2A  584F       665          addq.w    #4,A7
00000A2C  4E5E       666          unlk      A6
00000A2E  4E75       667          rts
                     668   ; }
                     669   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                     670   ; {
                     671   _InstallExceptionHandler:
00000A30  4E56 FFFC  672          link      A6,#-4
                     673   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A34  2D7C 0B00  674          move.l    #184549376,-4(A6)
00000A38  0000 FFFC 
                     675   ; RamVectorAddress[level] = (long int *)(function_ptr);
00000A3C  206E FFFC  676          move.l    -4(A6),A0
00000A40  202E 000C  677          move.l    12(A6),D0
00000A44  E588       678          lsl.l     #2,D0
00000A46  21AE 0008  679          move.l    8(A6),0(A0,D0.L)
00000A4A  0800      
00000A4C  4E5E       680          unlk      A6
00000A4E  4E75       681          rts
                     682   ; }
                     683   ; void TestLEDS(void)
                     684   ; {
                     685   _TestLEDS:
00000A50  48E7 3000  686          movem.l   D2/D3,-(A7)
                     687   ; int delay ;
                     688   ; unsigned char count = 0 ;
00000A54  4202       689          clr.b     D2
                     690   ; while(1)    {
                     691   TestLEDS_1:
                     692   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f)) ;
00000A56  1002       693          move.b    D2,D0
00000A58  E908       694          lsl.b     #4,D0
00000A5A  1202       695          move.b    D2,D1
00000A5C  C23C 000F  696          and.b     #15,D1
00000A60  D001       697          add.b     D1,D0
00000A62  13C0 0040  698          move.b    D0,4194326
00000A66  0016      
00000A68  13C0 0040  699          move.b    D0,4194324
00000A6C  0014      
00000A6E  13C0 0040  700          move.b    D0,4194322
00000A72  0012      
00000A74  13C0 0040  701          move.b    D0,4194320
00000A78  0010      
00000A7A  13C0 0040  702          move.b    D0,4194310
00000A7E  0006      
00000A80  13C0 0040  703          move.b    D0,4194308
00000A84  0004      
00000A86  13C0 0040  704          move.b    D0,4194306
00000A8A  0002      
00000A8C  13C0 0040  705          move.b    D0,4194304
00000A90  0000      
                     706   ; for(delay = 0; delay < 200000; delay ++)
00000A92  4283       707          clr.l     D3
                     708   TestLEDS_4:
00000A94  0C83 0003  709          cmp.l     #200000,D3
00000A98  0D40      
00000A9A  6C04       710          bge.s     TestLEDS_6
00000A9C  5283       711          addq.l    #1,D3
00000A9E  60F4       712          bra       TestLEDS_4
                     713   TestLEDS_6:
                     714   ; ;
                     715   ; count ++;
00000AA0  5202       716          addq.b    #1,D2
00000AA2  60B2       717          bra       TestLEDS_1
                     718   ; }
                     719   ; }
                     720   ; void SwitchTest(void)
                     721   ; {
                     722   _SwitchTest:
00000AA4  48E7 3020  723          movem.l   D2/D3/A2,-(A7)
00000AA8  45F9 0000  724          lea       _printf.L,A2
00000AAC  5AA4      
                     725   ; int i, switches = 0 ;
00000AAE  4283       726          clr.l     D3
                     727   ; printf("\r\n") ;
00000AB0  4879 0000  728          pea       @m68kde~2_1.L
00000AB4  6354      
00000AB6  4E92       729          jsr       (A2)
00000AB8  584F       730          addq.w    #4,A7
                     731   ; while(1)    {
                     732   SwitchTest_1:
                     733   ; switches = (PortB << 8) | (PortA) ;
00000ABA  1039 0040  734          move.b    4194306,D0
00000ABE  0002      
00000AC0  C0BC 0000  735          and.l     #255,D0
00000AC4  00FF      
00000AC6  E188       736          lsl.l     #8,D0
00000AC8  1239 0040  737          move.b    4194304,D1
00000ACC  0000      
00000ACE  C2BC 0000  738          and.l     #255,D1
00000AD2  00FF      
00000AD4  8081       739          or.l      D1,D0
00000AD6  2600       740          move.l    D0,D3
                     741   ; printf("\rSwitches SW[7-0] = ") ;
00000AD8  4879 0000  742          pea       @m68kde~2_2.L
00000ADC  6358      
00000ADE  4E92       743          jsr       (A2)
00000AE0  584F       744          addq.w    #4,A7
                     745   ; for( i = (int)(0x00000080); i > 0; i = i >> 1)  {
00000AE2  243C 0000  746          move.l    #128,D2
00000AE6  0080      
                     747   SwitchTest_4:
00000AE8  0C82 0000  748          cmp.l     #0,D2
00000AEC  0000      
00000AEE  6F20       749          ble.s     SwitchTest_6
                     750   ; if((switches & i) == 0)
00000AF0  2003       751          move.l    D3,D0
00000AF2  C082       752          and.l     D2,D0
00000AF4  660C       753          bne.s     SwitchTest_7
                     754   ; printf("0") ;
00000AF6  4879 0000  755          pea       @m68kde~2_3.L
00000AFA  636E      
00000AFC  4E92       756          jsr       (A2)
00000AFE  584F       757          addq.w    #4,A7
00000B00  600A       758          bra.s     SwitchTest_8
                     759   SwitchTest_7:
                     760   ; else
                     761   ; printf("1") ;
00000B02  4879 0000  762          pea       @m68kde~2_4.L
00000B06  6370      
00000B08  4E92       763          jsr       (A2)
00000B0A  584F       764          addq.w    #4,A7
                     765   SwitchTest_8:
00000B0C  E282       766          asr.l     #1,D2
00000B0E  60D8       767          bra       SwitchTest_4
                     768   SwitchTest_6:
00000B10  60A8       769          bra       SwitchTest_1
                     770   ; }
                     771   ; }
                     772   ; }
                     773   ; /*********************************************************************************************
                     774   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                     775   ; *********************************************************************************************/
                     776   ; void Init_RS232(void)
                     777   ; {
                     778   _Init_RS232:
                     779   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B12  13FC 0015  780          move.b    #21,4194368
00000B16  0040 0040 
                     781   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B1A  13FC 0001  782          move.b    #1,4194372
00000B1E  0040 0044 
00000B22  4E75       783          rts
                     784   ; }
                     785   ; int kbhit(void)
                     786   ; {
                     787   _kbhit:
                     788   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B24  1039 0040  789          move.b    4194368,D0
00000B28  0040      
00000B2A  C03C 0001  790          and.b     #1,D0
00000B2E  0C00 0001  791          cmp.b     #1,D0
00000B32  6604       792          bne.s     kbhit_1
                     793   ; return 1 ;
00000B34  7001       794          moveq     #1,D0
00000B36  6002       795          bra.s     kbhit_3
                     796   kbhit_1:
                     797   ; else
                     798   ; return 0 ;
00000B38  4280       799          clr.l     D0
                     800   kbhit_3:
00000B3A  4E75       801          rts
                     802   ; }
                     803   ; /*********************************************************************************************************
                     804   ; **  Subroutine to provide a low level output function to 6850 ACIA
                     805   ; **  This routine provides the basic functionality to output a single character to the serial Port
                     806   ; **  to allow the board to communicate with HyperTerminal Program
                     807   ; **
                     808   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                     809   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                     810   ; **  call _putch() also
                     811   ; *********************************************************************************************************/
                     812   ; int _putch( int c)
                     813   ; {
                     814   __putch:
00000B3C  4E56 0000  815          link      A6,#0
                     816   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                     817   _putch_1:
00000B40  1039 0040  818          move.b    4194368,D0
00000B44  0040      
00000B46  C03C 0002  819          and.b     #2,D0
00000B4A  0C00 0002  820          cmp.b     #2,D0
00000B4E  6702       821          beq.s     _putch_3
00000B50  60EE       822          bra       _putch_1
                     823   _putch_3:
                     824   ; ;
                     825   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000B52  202E 0008  826          move.l    8(A6),D0
00000B56  C03C 007F  827          and.b     #127,D0
00000B5A  13C0 0040  828          move.b    D0,4194370
00000B5E  0042      
                     829   ; return c ;                                              // putchar() expects the character to be returned
00000B60  202E 0008  830          move.l    8(A6),D0
00000B64  4E5E       831          unlk      A6
00000B66  4E75       832          rts
                     833   ; }
                     834   ; /*********************************************************************************************************
                     835   ; **  Subroutine to provide a low level input function to 6850 ACIA
                     836   ; **  This routine provides the basic functionality to input a single character from the serial Port
                     837   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                     838   ; **
                     839   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                     840   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                     841   ; **  call _getch() also
                     842   ; *********************************************************************************************************/
                     843   ; int _getch( void )
                     844   ; {
                     845   __getch:
00000B68  2F02       846          move.l    D2,-(A7)
                     847   ; int c ;
                     848   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                     849   _getch_1:
00000B6A  1039 0040  850          move.b    4194368,D0
00000B6E  0040      
00000B70  C03C 0001  851          and.b     #1,D0
00000B74  0C00 0001  852          cmp.b     #1,D0
00000B78  6702       853          beq.s     _getch_3
00000B7A  60EE       854          bra       _getch_1
                     855   _getch_3:
                     856   ; ;
                     857   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000B7C  1039 0040  858          move.b    4194370,D0
00000B80  0042      
00000B82  C0BC 0000  859          and.l     #255,D0
00000B86  00FF      
00000B88  C0BC 0000  860          and.l     #127,D0
00000B8C  007F      
00000B8E  2400       861          move.l    D0,D2
                     862   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                     863   ; if(Echo)
00000B90  4AB9 0B00  864          tst.l     _Echo.L
00000B94  00E0      
00000B96  6708       865          beq.s     _getch_4
                     866   ; _putch(c);
00000B98  2F02       867          move.l    D2,-(A7)
00000B9A  4EB8 0B3C  868          jsr       __putch
00000B9E  584F       869          addq.w    #4,A7
                     870   _getch_4:
                     871   ; return c ;
00000BA0  2002       872          move.l    D2,D0
00000BA2  241F       873          move.l    (A7)+,D2
00000BA4  4E75       874          rts
                     875   ; }
                     876   ; // flush the input stream for any unread characters
                     877   ; void FlushKeyboard(void)
                     878   ; {
                     879   _FlushKeyboard:
00000BA6  4E56 FFFC  880          link      A6,#-4
                     881   ; char c ;
                     882   ; while(1)    {
                     883   FlushKeyboard_1:
                     884   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000BAA  1039 0040  885          move.b    4194368,D0
00000BAE  0040      
00000BB0  C03C 0001  886          and.b     #1,D0
00000BB4  0C00 0001  887          cmp.b     #1,D0
00000BB8  6610       888          bne.s     FlushKeyboard_4
                     889   ; c = ((char)(RS232_RxData) & (char)(0x7f)) ;
00000BBA  1039 0040  890          move.b    4194370,D0
00000BBE  0042      
00000BC0  C03C 007F  891          and.b     #127,D0
00000BC4  1D40 FFFF  892          move.b    D0,-1(A6)
00000BC8  6002       893          bra.s     FlushKeyboard_5
                     894   FlushKeyboard_4:
                     895   ; else
                     896   ; return ;
00000BCA  6002       897          bra.s     FlushKeyboard_6
                     898   FlushKeyboard_5:
00000BCC  60DC       899          bra       FlushKeyboard_1
                     900   FlushKeyboard_6:
00000BCE  4E5E       901          unlk      A6
00000BD0  4E75       902          rts
                     903   ; }
                     904   ; }
                     905   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                     906   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                     907   ; char xtod(int c)
                     908   ; {
                     909   _xtod:
00000BD2  4E56 0000  910          link      A6,#0
00000BD6  2F02       911          move.l    D2,-(A7)
00000BD8  242E 0008  912          move.l    8(A6),D2
                     913   ; if ((char)(c) <= (char)('9'))
00000BDC  0C02 0039  914          cmp.b     #57,D2
00000BE0  6E08       915          bgt.s     xtod_1
                     916   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000BE2  1002       917          move.b    D2,D0
00000BE4  0400 0030  918          sub.b     #48,D0
00000BE8  6014       919          bra.s     xtod_3
                     920   xtod_1:
                     921   ; else if((char)(c) > (char)('F'))    // assume lower case
00000BEA  0C02 0046  922          cmp.b     #70,D2
00000BEE  6F08       923          ble.s     xtod_4
                     924   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000BF0  1002       925          move.b    D2,D0
00000BF2  0400 0057  926          sub.b     #87,D0
00000BF6  6006       927          bra.s     xtod_3
                     928   xtod_4:
                     929   ; else
                     930   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000BF8  1002       931          move.b    D2,D0
00000BFA  0400 0037  932          sub.b     #55,D0
                     933   xtod_3:
00000BFE  241F       934          move.l    (A7)+,D2
00000C00  4E5E       935          unlk      A6
00000C02  4E75       936          rts
                     937   ; }
                     938   ; int Get2HexDigits(char *CheckSumPtr)
                     939   ; {
                     940   _Get2HexDigits:
00000C04  4E56 0000  941          link      A6,#0
00000C08  2F02       942          move.l    D2,-(A7)
                     943   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C0A  2F00       944          move.l    D0,-(A7)
00000C0C  4EB8 0B68  945          jsr       __getch
00000C10  2200       946          move.l    D0,D1
00000C12  201F       947          move.l    (A7)+,D0
00000C14  2F01       948          move.l    D1,-(A7)
00000C16  4EB8 0BD2  949          jsr       _xtod
00000C1A  584F       950          addq.w    #4,A7
00000C1C  C0BC 0000  951          and.l     #255,D0
00000C20  00FF      
00000C22  E980       952          asl.l     #4,D0
00000C24  2F00       953          move.l    D0,-(A7)
00000C26  2F01       954          move.l    D1,-(A7)
00000C28  4EB8 0B68  955          jsr       __getch
00000C2C  221F       956          move.l    (A7)+,D1
00000C2E  2F00       957          move.l    D0,-(A7)
00000C30  4EB8 0BD2  958          jsr       _xtod
00000C34  584F       959          addq.w    #4,A7
00000C36  2200       960          move.l    D0,D1
00000C38  201F       961          move.l    (A7)+,D0
00000C3A  C2BC 0000  962          and.l     #255,D1
00000C3E  00FF      
00000C40  8081       963          or.l      D1,D0
00000C42  2400       964          move.l    D0,D2
                     965   ; if(CheckSumPtr)
00000C44  4AAE 0008  966          tst.l     8(A6)
00000C48  6706       967          beq.s     Get2HexDigits_1
                     968   ; *CheckSumPtr += i ;
00000C4A  206E 0008  969          move.l    8(A6),A0
00000C4E  D510       970          add.b     D2,(A0)
                     971   Get2HexDigits_1:
                     972   ; return i ;
00000C50  2002       973          move.l    D2,D0
00000C52  241F       974          move.l    (A7)+,D2
00000C54  4E5E       975          unlk      A6
00000C56  4E75       976          rts
                     977   ; }
                     978   ; int Get4HexDigits(char *CheckSumPtr)
                     979   ; {
                     980   _Get4HexDigits:
00000C58  4E56 0000  981          link      A6,#0
                     982   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C5C  2F2E 0008  983          move.l    8(A6),-(A7)
00000C60  4EB8 0C04  984          jsr       _Get2HexDigits
00000C64  584F       985          addq.w    #4,A7
00000C66  E180       986          asl.l     #8,D0
00000C68  2F00       987          move.l    D0,-(A7)
00000C6A  2F2E 0008  988          move.l    8(A6),-(A7)
00000C6E  4EB8 0C04  989          jsr       _Get2HexDigits
00000C72  584F       990          addq.w    #4,A7
00000C74  2200       991          move.l    D0,D1
00000C76  201F       992          move.l    (A7)+,D0
00000C78  8081       993          or.l      D1,D0
00000C7A  4E5E       994          unlk      A6
00000C7C  4E75       995          rts
                     996   ; }
                     997   ; int Get6HexDigits(char *CheckSumPtr)
                     998   ; {
                     999   _Get6HexDigits:
00000C7E  4E56 0000 1000          link      A6,#0
                    1001   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000C82  2F2E 0008 1002          move.l    8(A6),-(A7)
00000C86  4EB8 0C58 1003          jsr       _Get4HexDigits
00000C8A  584F      1004          addq.w    #4,A7
00000C8C  E180      1005          asl.l     #8,D0
00000C8E  2F00      1006          move.l    D0,-(A7)
00000C90  2F2E 0008 1007          move.l    8(A6),-(A7)
00000C94  4EB8 0C04 1008          jsr       _Get2HexDigits
00000C98  584F      1009          addq.w    #4,A7
00000C9A  2200      1010          move.l    D0,D1
00000C9C  201F      1011          move.l    (A7)+,D0
00000C9E  8081      1012          or.l      D1,D0
00000CA0  4E5E      1013          unlk      A6
00000CA2  4E75      1014          rts
                    1015   ; }
                    1016   ; int Get8HexDigits(char *CheckSumPtr)
                    1017   ; {
                    1018   _Get8HexDigits:
00000CA4  4E56 0000 1019          link      A6,#0
                    1020   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CA8  2F2E 0008 1021          move.l    8(A6),-(A7)
00000CAC  4EB8 0C58 1022          jsr       _Get4HexDigits
00000CB0  584F      1023          addq.w    #4,A7
00000CB2  E180      1024          asl.l     #8,D0
00000CB4  E180      1025          asl.l     #8,D0
00000CB6  2F00      1026          move.l    D0,-(A7)
00000CB8  2F2E 0008 1027          move.l    8(A6),-(A7)
00000CBC  4EB8 0C58 1028          jsr       _Get4HexDigits
00000CC0  584F      1029          addq.w    #4,A7
00000CC2  2200      1030          move.l    D0,D1
00000CC4  201F      1031          move.l    (A7)+,D0
00000CC6  8081      1032          or.l      D1,D0
00000CC8  4E5E      1033          unlk      A6
00000CCA  4E75      1034          rts
                    1035   ; }
                    1036   ; char *strcatInstruction(char *s) {    return strcat(Instruction,s) ; }
                    1037   _strcatInstruction:
00000CCC  4E56 0000 1038          link      A6,#0
00000CD0  2F2E 0008 1039          move.l    8(A6),-(A7)
00000CD4  4879 0B00 1040          pea       _Instruction.L
00000CD8  04E2      
00000CDA  4EB9 0000 1041          jsr       _strcat
00000CDE  5A62      
00000CE0  504F      1042          addq.w    #8,A7
00000CE2  4E5E      1043          unlk      A6
00000CE4  4E75      1044          rts
                    1045   ; char *strcpyInstruction(char *s) {    return strcpy(Instruction,s) ; }
                    1046   _strcpyInstruction:
00000CE6  4E56 0000 1047          link      A6,#0
00000CEA  2F2E 0008 1048          move.l    8(A6),-(A7)
00000CEE  4879 0B00 1049          pea       _Instruction.L
00000CF2  04E2      
00000CF4  4EB9 0000 1050          jsr       _strcpy
00000CF8  5808      
00000CFA  504F      1051          addq.w    #8,A7
00000CFC  4E5E      1052          unlk      A6
00000CFE  4E75      1053          rts
                    1054   ; void DisassembleProgram(void )
                    1055   ; {
                    1056   _DisassembleProgram:
00000D00  4E56 FFF8 1057          link      A6,#-8
00000D04  48E7 3038 1058          movem.l   D2/D3/A2/A3/A4,-(A7)
00000D08  45F9 0B00 1059          lea       _InstructionSize.L,A2
00000D0C  017E      
00000D0E  47F9 0000 1060          lea       _printf.L,A3
00000D12  5AA4      
00000D14  49F9 0B00 1061          lea       _Instruction.L,A4
00000D18  04E2      
                    1062   ; char c ;
                    1063   ; int i, j ;
                    1064   ; unsigned short int *ProgramPtr ; // pointer to where the program is stored
                    1065   ; printf("\r\nEnter Start Address: ") ;
00000D1A  4879 0000 1066          pea       @m68kde~2_5.L
00000D1E  6372      
00000D20  4E93      1067          jsr       (A3)
00000D22  584F      1068          addq.w    #4,A7
                    1069   ; ProgramPtr = Get8HexDigits(0) ;
00000D24  42A7      1070          clr.l     -(A7)
00000D26  4EB8 0CA4 1071          jsr       _Get8HexDigits
00000D2A  584F      1072          addq.w    #4,A7
00000D2C  2400      1073          move.l    D0,D2
                    1074   ; printf("\r\n<ESC> = Abort, SPACE to Continue") ;
00000D2E  4879 0000 1075          pea       @m68kde~2_6.L
00000D32  638A      
00000D34  4E93      1076          jsr       (A3)
00000D36  584F      1077          addq.w    #4,A7
                    1078   ; while(1)    {
                    1079   DisassembleProgram_1:
                    1080   ; for(i = 0; i < 20; i ++)
00000D38  4283      1081          clr.l     D3
                    1082   DisassembleProgram_4:
00000D3A  0C83 0000 1083          cmp.l     #20,D3
00000D3E  0014      
00000D40  6C00 017E 1084          bge       DisassembleProgram_6
                    1085   ; {
                    1086   ; InstructionSize = 1 ;                   // assume all instruction are at least 1 word
00000D44  24BC 0000 1087          move.l    #1,(A2)
00000D48  0001      
                    1088   ; DisassembleInstruction(ProgramPtr) ;    // build up string for disassembled instruction at address in programptr
00000D4A  2F02      1089          move.l    D2,-(A7)
00000D4C  4EB9 0000 1090          jsr       _DisassembleInstruction
00000D50  3966      
00000D52  584F      1091          addq.w    #4,A7
                    1092   ; if(InstructionSize == 1)
00000D54  2012      1093          move.l    (A2),D0
00000D56  0C80 0000 1094          cmp.l     #1,D0
00000D5A  0001      
00000D5C  6620      1095          bne.s     DisassembleProgram_7
                    1096   ; printf("\r\n%08X  %04X                        %s", ProgramPtr, ProgramPtr[0], Instruction) ;
00000D5E  2F0C      1097          move.l    A4,-(A7)
00000D60  2042      1098          move.l    D2,A0
00000D62  3210      1099          move.w    (A0),D1
00000D64  C2BC 0000 1100          and.l     #65535,D1
00000D68  FFFF      
00000D6A  2F01      1101          move.l    D1,-(A7)
00000D6C  2F02      1102          move.l    D2,-(A7)
00000D6E  4879 0000 1103          pea       @m68kde~2_7.L
00000D72  63AE      
00000D74  4E93      1104          jsr       (A3)
00000D76  DEFC 0010 1105          add.w     #16,A7
00000D7A  6000 0138 1106          bra       DisassembleProgram_15
                    1107   DisassembleProgram_7:
                    1108   ; else if(InstructionSize == 2)
00000D7E  2012      1109          move.l    (A2),D0
00000D80  0C80 0000 1110          cmp.l     #2,D0
00000D84  0002      
00000D86  662E      1111          bne.s     DisassembleProgram_9
                    1112   ; printf("\r\n%08X  %04X %04X                   %s", ProgramPtr, ProgramPtr[0], ProgramPtr[1], Instruction) ;
00000D88  2F0C      1113          move.l    A4,-(A7)
00000D8A  2042      1114          move.l    D2,A0
00000D8C  3228 0002 1115          move.w    2(A0),D1
00000D90  C2BC 0000 1116          and.l     #65535,D1
00000D94  FFFF      
00000D96  2F01      1117          move.l    D1,-(A7)
00000D98  2042      1118          move.l    D2,A0
00000D9A  3210      1119          move.w    (A0),D1
00000D9C  C2BC 0000 1120          and.l     #65535,D1
00000DA0  FFFF      
00000DA2  2F01      1121          move.l    D1,-(A7)
00000DA4  2F02      1122          move.l    D2,-(A7)
00000DA6  4879 0000 1123          pea       @m68kde~2_8.L
00000DAA  63D6      
00000DAC  4E93      1124          jsr       (A3)
00000DAE  DEFC 0014 1125          add.w     #20,A7
00000DB2  6000 0100 1126          bra       DisassembleProgram_15
                    1127   DisassembleProgram_9:
                    1128   ; else if(InstructionSize == 3)
00000DB6  2012      1129          move.l    (A2),D0
00000DB8  0C80 0000 1130          cmp.l     #3,D0
00000DBC  0003      
00000DBE  6600 003E 1131          bne       DisassembleProgram_11
                    1132   ; printf("\r\n%08X  %04X %04X %04X              %s", ProgramPtr, ProgramPtr[0], ProgramPtr[1], ProgramPtr[2], Instruction) ;
00000DC2  2F0C      1133          move.l    A4,-(A7)
00000DC4  2042      1134          move.l    D2,A0
00000DC6  3228 0004 1135          move.w    4(A0),D1
00000DCA  C2BC 0000 1136          and.l     #65535,D1
00000DCE  FFFF      
00000DD0  2F01      1137          move.l    D1,-(A7)
00000DD2  2042      1138          move.l    D2,A0
00000DD4  3228 0002 1139          move.w    2(A0),D1
00000DD8  C2BC 0000 1140          and.l     #65535,D1
00000DDC  FFFF      
00000DDE  2F01      1141          move.l    D1,-(A7)
00000DE0  2042      1142          move.l    D2,A0
00000DE2  3210      1143          move.w    (A0),D1
00000DE4  C2BC 0000 1144          and.l     #65535,D1
00000DE8  FFFF      
00000DEA  2F01      1145          move.l    D1,-(A7)
00000DEC  2F02      1146          move.l    D2,-(A7)
00000DEE  4879 0000 1147          pea       @m68kde~2_9.L
00000DF2  63FE      
00000DF4  4E93      1148          jsr       (A3)
00000DF6  DEFC 0018 1149          add.w     #24,A7
00000DFA  6000 00B8 1150          bra       DisassembleProgram_15
                    1151   DisassembleProgram_11:
                    1152   ; else if(InstructionSize == 4)
00000DFE  2012      1153          move.l    (A2),D0
00000E00  0C80 0000 1154          cmp.l     #4,D0
00000E04  0004      
00000E06  6600 004C 1155          bne       DisassembleProgram_13
                    1156   ; printf("\r\n%08X  %04X %04X %04X %04X         %s", ProgramPtr, ProgramPtr[0], ProgramPtr[1], ProgramPtr[2], ProgramPtr[3], Instruction) ;
00000E0A  2F0C      1157          move.l    A4,-(A7)
00000E0C  2042      1158          move.l    D2,A0
00000E0E  3228 0006 1159          move.w    6(A0),D1
00000E12  C2BC 0000 1160          and.l     #65535,D1
00000E16  FFFF      
00000E18  2F01      1161          move.l    D1,-(A7)
00000E1A  2042      1162          move.l    D2,A0
00000E1C  3228 0004 1163          move.w    4(A0),D1
00000E20  C2BC 0000 1164          and.l     #65535,D1
00000E24  FFFF      
00000E26  2F01      1165          move.l    D1,-(A7)
00000E28  2042      1166          move.l    D2,A0
00000E2A  3228 0002 1167          move.w    2(A0),D1
00000E2E  C2BC 0000 1168          and.l     #65535,D1
00000E32  FFFF      
00000E34  2F01      1169          move.l    D1,-(A7)
00000E36  2042      1170          move.l    D2,A0
00000E38  3210      1171          move.w    (A0),D1
00000E3A  C2BC 0000 1172          and.l     #65535,D1
00000E3E  FFFF      
00000E40  2F01      1173          move.l    D1,-(A7)
00000E42  2F02      1174          move.l    D2,-(A7)
00000E44  4879 0000 1175          pea       @m68kde~2_10.L
00000E48  6426      
00000E4A  4E93      1176          jsr       (A3)
00000E4C  DEFC 001C 1177          add.w     #28,A7
00000E50  6000 0062 1178          bra       DisassembleProgram_15
                    1179   DisassembleProgram_13:
                    1180   ; else if(InstructionSize == 5)
00000E54  2012      1181          move.l    (A2),D0
00000E56  0C80 0000 1182          cmp.l     #5,D0
00000E5A  0005      
00000E5C  6600 0056 1183          bne       DisassembleProgram_15
                    1184   ; printf("\r\n%08X  %04X %04X %04X %04X %04X    %s", ProgramPtr, ProgramPtr[0], ProgramPtr[1], ProgramPtr[2], ProgramPtr[3], ProgramPtr[4], Instruction) ;
00000E60  2F0C      1185          move.l    A4,-(A7)
00000E62  2042      1186          move.l    D2,A0
00000E64  3228 0008 1187          move.w    8(A0),D1
00000E68  C2BC 0000 1188          and.l     #65535,D1
00000E6C  FFFF      
00000E6E  2F01      1189          move.l    D1,-(A7)
00000E70  2042      1190          move.l    D2,A0
00000E72  3228 0006 1191          move.w    6(A0),D1
00000E76  C2BC 0000 1192          and.l     #65535,D1
00000E7A  FFFF      
00000E7C  2F01      1193          move.l    D1,-(A7)
00000E7E  2042      1194          move.l    D2,A0
00000E80  3228 0004 1195          move.w    4(A0),D1
00000E84  C2BC 0000 1196          and.l     #65535,D1
00000E88  FFFF      
00000E8A  2F01      1197          move.l    D1,-(A7)
00000E8C  2042      1198          move.l    D2,A0
00000E8E  3228 0002 1199          move.w    2(A0),D1
00000E92  C2BC 0000 1200          and.l     #65535,D1
00000E96  FFFF      
00000E98  2F01      1201          move.l    D1,-(A7)
00000E9A  2042      1202          move.l    D2,A0
00000E9C  3210      1203          move.w    (A0),D1
00000E9E  C2BC 0000 1204          and.l     #65535,D1
00000EA2  FFFF      
00000EA4  2F01      1205          move.l    D1,-(A7)
00000EA6  2F02      1206          move.l    D2,-(A7)
00000EA8  4879 0000 1207          pea       @m68kde~2_11.L
00000EAC  644E      
00000EAE  4E93      1208          jsr       (A3)
00000EB0  DEFC 0020 1209          add.w     #32,A7
                    1210   DisassembleProgram_15:
                    1211   ; ProgramPtr += InstructionSize ;
00000EB4  2012      1212          move.l    (A2),D0
00000EB6  E388      1213          lsl.l     #1,D0
00000EB8  D480      1214          add.l     D0,D2
00000EBA  5283      1215          addq.l    #1,D3
00000EBC  6000 FE7C 1216          bra       DisassembleProgram_4
                    1217   DisassembleProgram_6:
                    1218   ; }
                    1219   ; c = _getch() ;
00000EC0  4EB8 0B68 1220          jsr       __getch
00000EC4  1D40 FFFB 1221          move.b    D0,-5(A6)
                    1222   ; if(c == 0x1b)          // break on ESC
00000EC8  102E FFFB 1223          move.b    -5(A6),D0
00000ECC  0C00 001B 1224          cmp.b     #27,D0
00000ED0  6602      1225          bne.s     DisassembleProgram_17
                    1226   ; return ;
00000ED2  6004      1227          bra.s     DisassembleProgram_19
                    1228   DisassembleProgram_17:
00000ED4  6000 FE62 1229          bra       DisassembleProgram_1
                    1230   DisassembleProgram_19:
00000ED8  4CDF 1C0C 1231          movem.l   (A7)+,D2/D3/A2/A3/A4
00000EDC  4E5E      1232          unlk      A6
00000EDE  4E75      1233          rts
                    1234   ; }
                    1235   ; }
                    1236   ; void DumpMemory(void)   // simple dump memory fn
                    1237   ; {
                    1238   _DumpMemory:
00000EE0  48E7 3C30 1239          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000EE4  45F9 0000 1240          lea       _printf.L,A2
00000EE8  5AA4      
00000EEA  47F9 0000 1241          lea       _putch.L,A3
00000EEE  5996      
                    1242   ; int i, j ;
                    1243   ; unsigned char *RamPtr,c ; // pointer to where the program is download (assumed)
                    1244   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue") ;
00000EF0  4879 0000 1245          pea       @m68kde~2_12.L
00000EF4  6476      
00000EF6  4E92      1246          jsr       (A2)
00000EF8  584F      1247          addq.w    #4,A7
                    1248   ; printf("\r\nEnter Start Address: ") ;
00000EFA  4879 0000 1249          pea       @m68kde~2_5.L
00000EFE  6372      
00000F00  4E92      1250          jsr       (A2)
00000F02  584F      1251          addq.w    #4,A7
                    1252   ; RamPtr = Get8HexDigits(0) ;
00000F04  42A7      1253          clr.l     -(A7)
00000F06  4EB8 0CA4 1254          jsr       _Get8HexDigits
00000F0A  584F      1255          addq.w    #4,A7
00000F0C  2600      1256          move.l    D0,D3
                    1257   ; while(1)    {
                    1258   DumpMemory_1:
                    1259   ; for(i = 0; i < 16; i ++)    {
00000F0E  4285      1260          clr.l     D5
                    1261   DumpMemory_4:
00000F10  0C85 0000 1262          cmp.l     #16,D5
00000F14  0010      
00000F16  6C00 0096 1263          bge       DumpMemory_6
                    1264   ; printf("\r\n%08x ", RamPtr) ;
00000F1A  2F03      1265          move.l    D3,-(A7)
00000F1C  4879 0000 1266          pea       @m68kde~2_13.L
00000F20  64B0      
00000F22  4E92      1267          jsr       (A2)
00000F24  504F      1268          addq.w    #8,A7
                    1269   ; for(j=0; j < 16; j ++)  {
00000F26  4282      1270          clr.l     D2
                    1271   DumpMemory_7:
00000F28  0C82 0000 1272          cmp.l     #16,D2
00000F2C  0010      
00000F2E  6C24      1273          bge.s     DumpMemory_9
                    1274   ; printf("%02X",RamPtr[j]) ;
00000F30  2043      1275          move.l    D3,A0
00000F32  1230 2800 1276          move.b    0(A0,D2.L),D1
00000F36  C2BC 0000 1277          and.l     #255,D1
00000F3A  00FF      
00000F3C  2F01      1278          move.l    D1,-(A7)
00000F3E  4879 0000 1279          pea       @m68kde~2_14.L
00000F42  64B8      
00000F44  4E92      1280          jsr       (A2)
00000F46  504F      1281          addq.w    #8,A7
                    1282   ; putchar(' ') ;
00000F48  4878 0020 1283          pea       32
00000F4C  4E93      1284          jsr       (A3)
00000F4E  584F      1285          addq.w    #4,A7
00000F50  5282      1286          addq.l    #1,D2
00000F52  60D4      1287          bra       DumpMemory_7
                    1288   DumpMemory_9:
                    1289   ; }
                    1290   ; // now display the data as ASCII at the end
                    1291   ; printf("  ") ;
00000F54  4879 0000 1292          pea       @m68kde~2_15.L
00000F58  64BE      
00000F5A  4E92      1293          jsr       (A2)
00000F5C  584F      1294          addq.w    #4,A7
                    1295   ; for(j = 0; j < 16; j++) {
00000F5E  4282      1296          clr.l     D2
                    1297   DumpMemory_10:
00000F60  0C82 0000 1298          cmp.l     #16,D2
00000F64  0010      
00000F66  6C00 003A 1299          bge       DumpMemory_12
                    1300   ; c = ((char)(RamPtr[j]) & 0x7f) ;
00000F6A  2043      1301          move.l    D3,A0
00000F6C  1030 2800 1302          move.b    0(A0,D2.L),D0
00000F70  C03C 007F 1303          and.b     #127,D0
00000F74  1800      1304          move.b    D0,D4
                    1305   ; if((c > (char)(0x7f)) || (c < ' '))
00000F76  0C04 007F 1306          cmp.b     #127,D4
00000F7A  6206      1307          bhi.s     DumpMemory_15
00000F7C  0C04 0020 1308          cmp.b     #32,D4
00000F80  640A      1309          bhs.s     DumpMemory_13
                    1310   DumpMemory_15:
                    1311   ; putchar('.') ;
00000F82  4878 002E 1312          pea       46
00000F86  4E93      1313          jsr       (A3)
00000F88  584F      1314          addq.w    #4,A7
00000F8A  6012      1315          bra.s     DumpMemory_14
                    1316   DumpMemory_13:
                    1317   ; else
                    1318   ; putchar(RamPtr[j]) ;
00000F8C  2043      1319          move.l    D3,A0
00000F8E  1230 2800 1320          move.b    0(A0,D2.L),D1
00000F92  C2BC 0000 1321          and.l     #255,D1
00000F96  00FF      
00000F98  2F01      1322          move.l    D1,-(A7)
00000F9A  4E93      1323          jsr       (A3)
00000F9C  584F      1324          addq.w    #4,A7
                    1325   DumpMemory_14:
00000F9E  5282      1326          addq.l    #1,D2
00000FA0  60BE      1327          bra       DumpMemory_10
                    1328   DumpMemory_12:
                    1329   ; }
                    1330   ; RamPtr = RamPtr + 16 ;
00000FA2  0683 0000 1331          add.l     #16,D3
00000FA6  0010      
00000FA8  5285      1332          addq.l    #1,D5
00000FAA  6000 FF64 1333          bra       DumpMemory_4
                    1334   DumpMemory_6:
                    1335   ; }
                    1336   ; printf("\r\n") ;
00000FAE  4879 0000 1337          pea       @m68kde~2_1.L
00000FB2  6354      
00000FB4  4E92      1338          jsr       (A2)
00000FB6  584F      1339          addq.w    #4,A7
                    1340   ; c = _getch() ;
00000FB8  4EB8 0B68 1341          jsr       __getch
00000FBC  1800      1342          move.b    D0,D4
                    1343   ; if(c == 0x1b)          // break on ESC
00000FBE  0C04 001B 1344          cmp.b     #27,D4
00000FC2  6602      1345          bne.s     DumpMemory_16
                    1346   ; break ;
00000FC4  6004      1347          bra.s     DumpMemory_3
                    1348   DumpMemory_16:
00000FC6  6000 FF46 1349          bra       DumpMemory_1
                    1350   DumpMemory_3:
00000FCA  4CDF 0C3C 1351          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000FCE  4E75      1352          rts
                    1353   ; }
                    1354   ; }
                    1355   ; void FillMemory()
                    1356   ; {
                    1357   _FillMemory:
00000FD0  48E7 3820 1358          movem.l   D2/D3/D4/A2,-(A7)
00000FD4  45F9 0000 1359          lea       _printf.L,A2
00000FD8  5AA4      
                    1360   ; char *StartRamPtr, *EndRamPtr ;
                    1361   ; unsigned char FillData ;
                    1362   ; printf("\r\nFill Memory Block") ;
00000FDA  4879 0000 1363          pea       @m68kde~2_16.L
00000FDE  64C2      
00000FE0  4E92      1364          jsr       (A2)
00000FE2  584F      1365          addq.w    #4,A7
                    1366   ; printf("\r\nEnter Start Address: ") ;
00000FE4  4879 0000 1367          pea       @m68kde~2_5.L
00000FE8  6372      
00000FEA  4E92      1368          jsr       (A2)
00000FEC  584F      1369          addq.w    #4,A7
                    1370   ; StartRamPtr = Get8HexDigits(0) ;
00000FEE  42A7      1371          clr.l     -(A7)
00000FF0  4EB8 0CA4 1372          jsr       _Get8HexDigits
00000FF4  584F      1373          addq.w    #4,A7
00000FF6  2400      1374          move.l    D0,D2
                    1375   ; printf("\r\nEnter End Address: ") ;
00000FF8  4879 0000 1376          pea       @m68kde~2_17.L
00000FFC  64D6      
00000FFE  4E92      1377          jsr       (A2)
00001000  584F      1378          addq.w    #4,A7
                    1379   ; EndRamPtr = Get8HexDigits(0) ;
00001002  42A7      1380          clr.l     -(A7)
00001004  4EB8 0CA4 1381          jsr       _Get8HexDigits
00001008  584F      1382          addq.w    #4,A7
0000100A  2800      1383          move.l    D0,D4
                    1384   ; printf("\r\nEnter Fill Data: ") ;
0000100C  4879 0000 1385          pea       @m68kde~2_18.L
00001010  64EC      
00001012  4E92      1386          jsr       (A2)
00001014  584F      1387          addq.w    #4,A7
                    1388   ; FillData = Get2HexDigits(0) ;
00001016  42A7      1389          clr.l     -(A7)
00001018  4EB8 0C04 1390          jsr       _Get2HexDigits
0000101C  584F      1391          addq.w    #4,A7
0000101E  1600      1392          move.b    D0,D3
                    1393   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData) ;
00001020  C6BC 0000 1394          and.l     #255,D3
00001024  00FF      
00001026  2F03      1395          move.l    D3,-(A7)
00001028  2F04      1396          move.l    D4,-(A7)
0000102A  2F02      1397          move.l    D2,-(A7)
0000102C  4879 0000 1398          pea       @m68kde~2_19.L
00001030  6500      
00001032  4E92      1399          jsr       (A2)
00001034  DEFC 0010 1400          add.w     #16,A7
                    1401   ; while(StartRamPtr < EndRamPtr)
                    1402   FillMemory_1:
00001038  B484      1403          cmp.l     D4,D2
0000103A  6408      1404          bhs.s     FillMemory_3
                    1405   ; *StartRamPtr++ = FillData ;
0000103C  2042      1406          move.l    D2,A0
0000103E  5282      1407          addq.l    #1,D2
00001040  1083      1408          move.b    D3,(A0)
00001042  60F4      1409          bra       FillMemory_1
                    1410   FillMemory_3:
00001044  4CDF 041C 1411          movem.l   (A7)+,D2/D3/D4/A2
00001048  4E75      1412          rts
                    1413   ; }
                    1414   ; void Load_SRecordFile()
                    1415   ; {
                    1416   _Load_SRecordFile:
0000104A  4E56 FFDC 1417          link      A6,#-36
0000104E  48E7 3F3C 1418          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001052  45EE FFFA 1419          lea       -6(A6),A2
00001056  47F8 0C04 1420          lea       _Get2HexDigits.L,A3
0000105A  49F9 0000 1421          lea       _printf.L,A4
0000105E  5AA4      
                    1422   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0 ;
00001060  42AE FFEE 1423          clr.l     -18(A6)
00001064  3A7C 0000 1424          move.w    #0,A5
                    1425   ; int result, ByteCount ;
                    1426   ; char c, CheckSum, ReadCheckSum, HeaderType ;
                    1427   ; char *RamPtr ;                          // pointer to Memory where downloaded program will be stored
                    1428   ; LoadFailed = 0 ;                        //assume LOAD operation will pass
00001068  7E00      1429          moveq     #0,D7
                    1430   ; AddressFail = 0 ;
0000106A  42AE FFEA 1431          clr.l     -22(A6)
                    1432   ; Echo = 0 ;                              // don't echo S records during download
0000106E  42B9 0B00 1433          clr.l     _Echo.L
00001072  00E0      
                    1434   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n") ;
00001074  4879 0000 1435          pea       @m68kde~2_20.L
00001078  6530      
0000107A  4E94      1436          jsr       (A4)
0000107C  584F      1437          addq.w    #4,A7
                    1438   ; while(1)    {
                    1439   Load_SRecordFile_1:
                    1440   ; CheckSum = 0 ;
0000107E  4212      1441          clr.b     (A2)
                    1442   ; do {
                    1443   Load_SRecordFile_4:
                    1444   ; c = toupper(_getch()) ;
00001080  2F00      1445          move.l    D0,-(A7)
00001082  4EB8 0B68 1446          jsr       __getch
00001086  2200      1447          move.l    D0,D1
00001088  201F      1448          move.l    (A7)+,D0
0000108A  2F01      1449          move.l    D1,-(A7)
0000108C  4EB9 0000 1450          jsr       _toupper
00001090  5A78      
00001092  584F      1451          addq.w    #4,A7
00001094  1C00      1452          move.b    D0,D6
                    1453   ; if(c == 0x1b )      // if break
00001096  0C06 001B 1454          cmp.b     #27,D6
0000109A  6604      1455          bne.s     Load_SRecordFile_6
                    1456   ; return;
0000109C  6000 0132 1457          bra       Load_SRecordFile_8
                    1458   Load_SRecordFile_6:
000010A0  0C06 0053 1459          cmp.b     #83,D6
000010A4  66DA      1460          bne       Load_SRecordFile_4
                    1461   ; }while(c != (char)('S'));   // wait for S start of header
                    1462   ; HeaderType = _getch() ;
000010A6  4EB8 0B68 1463          jsr       __getch
000010AA  1600      1464          move.b    D0,D3
                    1465   ; if(HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
000010AC  0C03 0030 1466          cmp.b     #48,D3
000010B0  6706      1467          beq.s     Load_SRecordFile_11
000010B2  0C03 0035 1468          cmp.b     #53,D3
000010B6  6604      1469          bne.s     Load_SRecordFile_9
                    1470   Load_SRecordFile_11:
                    1471   ; continue ;
000010B8  6000 00D2 1472          bra       Load_SRecordFile_23
                    1473   Load_SRecordFile_9:
                    1474   ; if(HeaderType >= (char)('7'))
000010BC  0C03 0037 1475          cmp.b     #55,D3
000010C0  6D04      1476          blt.s     Load_SRecordFile_12
                    1477   ; break ;                 // end load on s7,s8,s9 records
000010C2  6000 00CC 1478          bra       Load_SRecordFile_3
                    1479   Load_SRecordFile_12:
                    1480   ; // get the bytecount
                    1481   ; ByteCount = Get2HexDigits(&CheckSum) ;
000010C6  2F0A      1482          move.l    A2,-(A7)
000010C8  4E93      1483          jsr       (A3)
000010CA  584F      1484          addq.w    #4,A7
000010CC  2D40 FFF6 1485          move.l    D0,-10(A6)
                    1486   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1487   ; if(HeaderType == (char)('1')) {
000010D0  0C03 0031 1488          cmp.b     #49,D3
000010D4  660E      1489          bne.s     Load_SRecordFile_14
                    1490   ; AddressSize = 2 ;       // 2 byte address
000010D6  7A02      1491          moveq     #2,D5
                    1492   ; Address = Get4HexDigits(&CheckSum);
000010D8  2F0A      1493          move.l    A2,-(A7)
000010DA  4EB8 0C58 1494          jsr       _Get4HexDigits
000010DE  584F      1495          addq.w    #4,A7
000010E0  2800      1496          move.l    D0,D4
000010E2  6020      1497          bra.s     Load_SRecordFile_17
                    1498   Load_SRecordFile_14:
                    1499   ; }
                    1500   ; else if (HeaderType == (char)('2')) {
000010E4  0C03 0032 1501          cmp.b     #50,D3
000010E8  660E      1502          bne.s     Load_SRecordFile_16
                    1503   ; AddressSize = 3 ;       // 3 byte address
000010EA  7A03      1504          moveq     #3,D5
                    1505   ; Address = Get6HexDigits(&CheckSum) ;
000010EC  2F0A      1506          move.l    A2,-(A7)
000010EE  4EB8 0C7E 1507          jsr       _Get6HexDigits
000010F2  584F      1508          addq.w    #4,A7
000010F4  2800      1509          move.l    D0,D4
000010F6  600C      1510          bra.s     Load_SRecordFile_17
                    1511   Load_SRecordFile_16:
                    1512   ; }
                    1513   ; else    {
                    1514   ; AddressSize = 4 ;       // 4 byte address
000010F8  7A04      1515          moveq     #4,D5
                    1516   ; Address = Get8HexDigits(&CheckSum) ;
000010FA  2F0A      1517          move.l    A2,-(A7)
000010FC  4EB8 0CA4 1518          jsr       _Get8HexDigits
00001100  584F      1519          addq.w    #4,A7
00001102  2800      1520          move.l    D0,D4
                    1521   Load_SRecordFile_17:
                    1522   ; }
                    1523   ; RamPtr = (char *)(Address) ;                            // point to download area
00001104  2D44 FFFC 1524          move.l    D4,-4(A6)
                    1525   ; NumDataBytesToRead = ByteCount - AddressSize - 1 ;
00001108  202E FFF6 1526          move.l    -10(A6),D0
0000110C  9085      1527          sub.l     D5,D0
0000110E  5380      1528          subq.l    #1,D0
00001110  2D40 FFE2 1529          move.l    D0,-30(A6)
                    1530   ; for(i = 0; i < NumDataBytesToRead; i ++) {     // read in remaining data bytes (ignore address and checksum at the end
00001114  4282      1531          clr.l     D2
                    1532   Load_SRecordFile_18:
00001116  B4AE FFE2 1533          cmp.l     -30(A6),D2
0000111A  6C1E      1534          bge.s     Load_SRecordFile_20
                    1535   ; DataByte = Get2HexDigits(&CheckSum) ;
0000111C  2F0A      1536          move.l    A2,-(A7)
0000111E  4E93      1537          jsr       (A3)
00001120  584F      1538          addq.w    #4,A7
00001122  2D40 FFDE 1539          move.l    D0,-34(A6)
                    1540   ; *RamPtr++ = DataByte ;                      // store downloaded byte in Ram at specified address
00001126  202E FFDE 1541          move.l    -34(A6),D0
0000112A  206E FFFC 1542          move.l    -4(A6),A0
0000112E  52AE FFFC 1543          addq.l    #1,-4(A6)
00001132  1080      1544          move.b    D0,(A0)
                    1545   ; ByteTotal++;
00001134  524D      1546          addq.w    #1,A5
00001136  5282      1547          addq.l    #1,D2
00001138  60DC      1548          bra       Load_SRecordFile_18
                    1549   Load_SRecordFile_20:
                    1550   ; }
                    1551   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1552   ; ReadCheckSum = Get2HexDigits(0) ;
0000113A  42A7      1553          clr.l     -(A7)
0000113C  4E93      1554          jsr       (A3)
0000113E  584F      1555          addq.w    #4,A7
00001140  1D40 FFFB 1556          move.b    D0,-5(A6)
                    1557   ; if((~CheckSum&0Xff) != (ReadCheckSum&0Xff))   {
00001144  1012      1558          move.b    (A2),D0
00001146  4600      1559          not.b     D0
00001148  4880      1560          ext.w     D0
0000114A  C07C 00FF 1561          and.w     #255,D0
0000114E  122E FFFB 1562          move.b    -5(A6),D1
00001152  4881      1563          ext.w     D1
00001154  C27C 00FF 1564          and.w     #255,D1
00001158  B041      1565          cmp.w     D1,D0
0000115A  6708      1566          beq.s     Load_SRecordFile_21
                    1567   ; LoadFailed = 1 ;
0000115C  7E01      1568          moveq     #1,D7
                    1569   ; FailedAddress = Address ;
0000115E  2D44 FFE6 1570          move.l    D4,-26(A6)
                    1571   ; break;
00001162  602C      1572          bra.s     Load_SRecordFile_3
                    1573   Load_SRecordFile_21:
                    1574   ; }
                    1575   ; SRecordCount++ ;
00001164  52AE FFEE 1576          addq.l    #1,-18(A6)
                    1577   ; // display feedback on progress
                    1578   ; if(SRecordCount % 25 == 0)
00001168  2F2E FFEE 1579          move.l    -18(A6),-(A7)
0000116C  4878 0019 1580          pea       25
00001170  4EB9 0000 1581          jsr       LDIV
00001174  582A      
00001176  202F 0004 1582          move.l    4(A7),D0
0000117A  504F      1583          addq.w    #8,A7
0000117C  4A80      1584          tst.l     D0
0000117E  660C      1585          bne.s     Load_SRecordFile_23
                    1586   ; putchar('.') ;
00001180  4878 002E 1587          pea       46
00001184  4EB9 0000 1588          jsr       _putch
00001188  5996      
0000118A  584F      1589          addq.w    #4,A7
                    1590   Load_SRecordFile_23:
0000118C  6000 FEF0 1591          bra       Load_SRecordFile_1
                    1592   Load_SRecordFile_3:
                    1593   ; }
                    1594   ; if(LoadFailed == 1) {
00001190  0C87 0000 1595          cmp.l     #1,D7
00001194  0001      
00001196  6610      1596          bne.s     Load_SRecordFile_25
                    1597   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress) ;
00001198  2F2E FFE6 1598          move.l    -26(A6),-(A7)
0000119C  4879 0000 1599          pea       @m68kde~2_21.L
000011A0  6560      
000011A2  4E94      1600          jsr       (A4)
000011A4  504F      1601          addq.w    #8,A7
000011A6  600C      1602          bra.s     Load_SRecordFile_26
                    1603   Load_SRecordFile_25:
                    1604   ; }
                    1605   ; else
                    1606   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal) ;
000011A8  2F0D      1607          move.l    A5,-(A7)
000011AA  4879 0000 1608          pea       @m68kde~2_22.L
000011AE  6586      
000011B0  4E94      1609          jsr       (A4)
000011B2  504F      1610          addq.w    #8,A7
                    1611   Load_SRecordFile_26:
                    1612   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1613   ; for(i = 0; i < 400000; i ++)
000011B4  4282      1614          clr.l     D2
                    1615   Load_SRecordFile_27:
000011B6  0C82 0006 1616          cmp.l     #400000,D2
000011BA  1A80      
000011BC  6C04      1617          bge.s     Load_SRecordFile_29
000011BE  5282      1618          addq.l    #1,D2
000011C0  60F4      1619          bra       Load_SRecordFile_27
                    1620   Load_SRecordFile_29:
                    1621   ; ;
                    1622   ; FlushKeyboard() ;
000011C2  4EB8 0BA6 1623          jsr       _FlushKeyboard
                    1624   ; Echo = 1;
000011C6  23FC 0000 1625          move.l    #1,_Echo.L
000011CA  0001 0B00 
000011CE  00E0      
                    1626   Load_SRecordFile_8:
000011D0  4CDF 3CFC 1627          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000011D4  4E5E      1628          unlk      A6
000011D6  4E75      1629          rts
                    1630   ; }
                    1631   ; void MemoryChange(void)
                    1632   ; {
                    1633   _MemoryChange:
000011D8  48E7 3820 1634          movem.l   D2/D3/D4/A2,-(A7)
000011DC  45F9 0000 1635          lea       _printf.L,A2
000011E0  5AA4      
                    1636   ; unsigned char *RamPtr,c ; // pointer to memory
                    1637   ; int Data ;
                    1638   ; printf("\r\nExamine and Change Memory") ;
000011E2  4879 0000 1639          pea       @m68kde~2_23.L
000011E6  65A8      
000011E8  4E92      1640          jsr       (A2)
000011EA  584F      1641          addq.w    #4,A7
                    1642   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change") ;
000011EC  4879 0000 1643          pea       @m68kde~2_24.L
000011F0  65C4      
000011F2  4E92      1644          jsr       (A2)
000011F4  584F      1645          addq.w    #4,A7
                    1646   ; printf("\r\nEnter Address: ") ;
000011F6  4879 0000 1647          pea       @m68kde~2_25.L
000011FA  660A      
000011FC  4E92      1648          jsr       (A2)
000011FE  584F      1649          addq.w    #4,A7
                    1650   ; RamPtr = Get8HexDigits(0) ;
00001200  42A7      1651          clr.l     -(A7)
00001202  4EB8 0CA4 1652          jsr       _Get8HexDigits
00001206  584F      1653          addq.w    #4,A7
00001208  2600      1654          move.l    D0,D3
                    1655   ; while(1)    {
                    1656   MemoryChange_1:
                    1657   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr) ;
0000120A  2043      1658          move.l    D3,A0
0000120C  1210      1659          move.b    (A0),D1
0000120E  C2BC 0000 1660          and.l     #255,D1
00001212  00FF      
00001214  2F01      1661          move.l    D1,-(A7)
00001216  2F03      1662          move.l    D3,-(A7)
00001218  4879 0000 1663          pea       @m68kde~2_26.L
0000121C  661C      
0000121E  4E92      1664          jsr       (A2)
00001220  DEFC 000C 1665          add.w     #12,A7
                    1666   ; c = tolower(_getch()) ;
00001224  2F00      1667          move.l    D0,-(A7)
00001226  4EB8 0B68 1668          jsr       __getch
0000122A  2200      1669          move.l    D0,D1
0000122C  201F      1670          move.l    (A7)+,D0
0000122E  2F01      1671          move.l    D1,-(A7)
00001230  4EB9 0000 1672          jsr       _tolower
00001234  5A02      
00001236  584F      1673          addq.w    #4,A7
00001238  1400      1674          move.b    D0,D2
                    1675   ; if(c == (char)(0x1b))
0000123A  0C02 001B 1676          cmp.b     #27,D2
0000123E  6604      1677          bne.s     MemoryChange_4
                    1678   ; return ;                                // abort on escape
00001240  6000 0090 1679          bra       MemoryChange_6
                    1680   MemoryChange_4:
                    1681   ; else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001244  0C02 0030 1682          cmp.b     #48,D2
00001248  6506      1683          blo.s     MemoryChange_10
0000124A  0C02 0039 1684          cmp.b     #57,D2
0000124E  6310      1685          bls.s     MemoryChange_9
                    1686   MemoryChange_10:
00001250  0C02 0061 1687          cmp.b     #97,D2
00001254  6500 006E 1688          blo       MemoryChange_7
00001258  0C02 0066 1689          cmp.b     #102,D2
0000125C  6200 0066 1690          bhi       MemoryChange_7
                    1691   MemoryChange_9:
                    1692   ; Data = (xtod(c) << 4) | (xtod(_getch()));
00001260  C4BC 0000 1693          and.l     #255,D2
00001264  00FF      
00001266  2F02      1694          move.l    D2,-(A7)
00001268  4EB8 0BD2 1695          jsr       _xtod
0000126C  584F      1696          addq.w    #4,A7
0000126E  C0BC 0000 1697          and.l     #255,D0
00001272  00FF      
00001274  E980      1698          asl.l     #4,D0
00001276  2F00      1699          move.l    D0,-(A7)
00001278  2F01      1700          move.l    D1,-(A7)
0000127A  4EB8 0B68 1701          jsr       __getch
0000127E  221F      1702          move.l    (A7)+,D1
00001280  2F00      1703          move.l    D0,-(A7)
00001282  4EB8 0BD2 1704          jsr       _xtod
00001286  584F      1705          addq.w    #4,A7
00001288  2200      1706          move.l    D0,D1
0000128A  201F      1707          move.l    (A7)+,D0
0000128C  C2BC 0000 1708          and.l     #255,D1
00001290  00FF      
00001292  8081      1709          or.l      D1,D0
00001294  2800      1710          move.l    D0,D4
                    1711   ; *RamPtr = (char)(Data) ;
00001296  2043      1712          move.l    D3,A0
00001298  1084      1713          move.b    D4,(A0)
                    1714   ; if(*RamPtr != Data) {
0000129A  2043      1715          move.l    D3,A0
0000129C  1010      1716          move.b    (A0),D0
0000129E  C0BC 0000 1717          and.l     #255,D0
000012A2  00FF      
000012A4  B084      1718          cmp.l     D4,D0
000012A6  671A      1719          beq.s     MemoryChange_11
                    1720   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr) ;
000012A8  2043      1721          move.l    D3,A0
000012AA  1210      1722          move.b    (A0),D1
000012AC  C2BC 0000 1723          and.l     #255,D1
000012B0  00FF      
000012B2  2F01      1724          move.l    D1,-(A7)
000012B4  2F04      1725          move.l    D4,-(A7)
000012B6  4879 0000 1726          pea       @m68kde~2_27.L
000012BA  662E      
000012BC  4E92      1727          jsr       (A2)
000012BE  DEFC 000C 1728          add.w     #12,A7
                    1729   MemoryChange_11:
000012C2  6008      1730          bra.s     MemoryChange_13
                    1731   MemoryChange_7:
                    1732   ; }
                    1733   ; }
                    1734   ; else if(c == (char)('-'))
000012C4  0C02 002D 1735          cmp.b     #45,D2
000012C8  6602      1736          bne.s     MemoryChange_13
                    1737   ; RamPtr -= 2 ; ;
000012CA  5583      1738          subq.l    #2,D3
                    1739   MemoryChange_13:
                    1740   ; RamPtr ++ ;
000012CC  5283      1741          addq.l    #1,D3
000012CE  6000 FF3A 1742          bra       MemoryChange_1
                    1743   MemoryChange_6:
000012D2  4CDF 041C 1744          movem.l   (A7)+,D2/D3/D4/A2
000012D6  4E75      1745          rts
                    1746   ; }
                    1747   ; }
                    1748   ; /*************************************************************
                    1749   ; ** SPI Controller registers
                    1750   ; **************************************************************/
                    1751   ; // SPI Registers
                    1752   ; #define SPI_Control (*(volatile unsigned char *)(0x00408020))
                    1753   ; #define SPI_Status (*(volatile unsigned char *)(0x00408022))
                    1754   ; #define SPI_Data (*(volatile unsigned char *)(0x00408024))
                    1755   ; #define SPI_Ext (*(volatile unsigned char *)(0x00408026))
                    1756   ; #define SPI_CS (*(volatile unsigned char *)(0x00408028))
                    1757   ; // these two macros enable or disable the flash memory chip enable off SSN_O[7..0]
                    1758   ; // in this case we assume there is only 1 device connected to SSN_O[0] so we can
                    1759   ; // write hex FE to the SPI_CS to enable it (the enable on the flash chip is active low)
                    1760   ; // and write FF to disable it
                    1761   ; #define Enable_SPI_CS() SPI_CS = 0xFE
                    1762   ; #define Disable_SPI_CS() SPI_CS = 0xFF
                    1763   ; /******************************************************************************************
                    1764   ; ** The following code is for the SPI controller
                    1765   ; *******************************************************************************************/
                    1766   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1767   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1768   ; int TestForSPITransmitDataComplete(void) {
                    1769   _TestForSPITransmitDataComplete:
                    1770   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    1771   ; /*Parsa Comments
                    1772   ; SPIF comes from the status of the SPI_Status bit 7 being 1.
                    1773   ; */
                    1774   ; if(SPI_Status & (1 << 7) == 1)
                    1775   ; return 1;
                    1776   ; else 
                    1777   ; return 0;
000012D8  4280      1778          clr.l     D0
000012DA  4E75      1779          rts
                    1780   ; }
                    1781   ; /************************************************************************************
                    1782   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1783   ; ************************************************************************************/
                    1784   ; void SPI_Init(void)
                    1785   ; {
                    1786   _SPI_Init:
                    1787   ; //TODO
                    1788   ; //
                    1789   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1790   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1791   ; //
                    1792   ; // Here are some settings we want to create
                    1793   ; //
                    1794   ; // Control Reg - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed = divide by 32 = approx 700Khz
                    1795   ; // Ext Reg - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1796   ; // SPI_CS Reg - control selection of slave SPI chips via their CS# signals
                    1797   ; // Status Reg - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1798   ; SPI_Control = 0x53;
000012DC  13FC 0053 1799          move.b    #83,4227104
000012E0  0040 8020 
                    1800   ; SPI_Ext = 0x00;
000012E4  4239 0040 1801          clr.b     4227110
000012E8  8026      
                    1802   ; Enable_SPI_CS();
000012EA  13FC 00FE 1803          move.b    #254,4227112
000012EE  0040 8028 
                    1804   ; SPI_Status = 0xC0;
000012F2  13FC 00C0 1805          move.b    #192,4227106
000012F6  0040 8022 
000012FA  4E75      1806          rts
                    1807   ; }
                    1808   ; /************************************************************************************
                    1809   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1810   ; ************************************************************************************/
                    1811   ; void WaitForSPITransmitComplete(void)
                    1812   ; {
                    1813   _WaitForSPITransmitComplete:
                    1814   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1815   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1816   ; // just in case they were set
                    1817   ; while(!TestForSPITransmitDataComplete()){
                    1818   WaitForSPITransmitComplete_1:
000012FC  4EB8 12D8 1819          jsr       _TestForSPITransmitDataComplete
00001300  4A80      1820          tst.l     D0
00001302  6602      1821          bne.s     WaitForSPITransmitComplete_3
                    1822   ; }
00001304  60F6      1823          bra       WaitForSPITransmitComplete_1
                    1824   WaitForSPITransmitComplete_3:
                    1825   ; //Clears write collision and interrupt in SPSR[7:6] 0xC0 == 0b1100_0000
                    1826   ; SPI_Status |= 0xC0;
00001306  0039 00C0 1827          or.b      #192,4227106
0000130A  0040 8022 
0000130E  4E75      1828          rts
                    1829   ; }
                    1830   ; /************************************************************************************
                    1831   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    1832   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    1833   ; ************************************************************************************/
                    1834   ; int WriteSPIChar(int c)
                    1835   ; {
                    1836   _WriteSPIChar:
00001310  4E56 0000 1837          link      A6,#0
                    1838   ; // todo - write the byte in parameter 'c' to the SPI data register, this will start it transmitting to the flash device
                    1839   ; // wait for completion of transmission
                    1840   ; // return the received data from Flash chip (which may not be relevent depending upon what we are doing)
                    1841   ; // by reading fom the SPI controller Data Register.
                    1842   ; // note however that in order to get data from an SPI slave device (e.g. flash) chip we have to write a dummy byte to it
                    1843   ; //
                    1844   ; // modify '0' below to return back read byte from data register
                    1845   ; //
                    1846   ; //Parsa: I'm pretty sure the dummy variable that needs to be written is just this line below which is already asked to be done by the todo above anyway
                    1847   ; SPI_Data = c;
00001314  202E 0008 1848          move.l    8(A6),D0
00001318  13C0 0040 1849          move.b    D0,4227108
0000131C  8024      
                    1850   ; WaitForSPITransmitComplete();
0000131E  4EB8 12FC 1851          jsr       _WaitForSPITransmitComplete
                    1852   ; return SPI_Data;
00001322  1039 0040 1853          move.b    4227108,D0
00001326  8024      
00001328  C0BC 0000 1854          and.l     #255,D0
0000132C  00FF      
0000132E  4E5E      1855          unlk      A6
00001330  4E75      1856          rts
                    1857   ; }
                    1858   ; void SPI_Write_Enable() {
                    1859   _SPI_Write_Enable:
                    1860   ; SPI_CS = 0;
00001332  4239 0040 1861          clr.b     4227112
00001336  8028      
                    1862   ; WriteSPIChar(0x06);
00001338  4878 0006 1863          pea       6
0000133C  4EB8 1310 1864          jsr       _WriteSPIChar
00001340  584F      1865          addq.w    #4,A7
                    1866   ; SPI_CS = 1;
00001342  13FC 0001 1867          move.b    #1,4227112
00001346  0040 8028 
                    1868   ; return;
0000134A  4E75      1869          rts
                    1870   ; }
                    1871   ; void SPI_Write_Disable() {
                    1872   _SPI_Write_Disable:
                    1873   ; SPI_CS = 0;
0000134C  4239 0040 1874          clr.b     4227112
00001350  8028      
                    1875   ; WriteSPIChar(0x04);
00001352  4878 0004 1876          pea       4
00001356  4EB8 1310 1877          jsr       _WriteSPIChar
0000135A  584F      1878          addq.w    #4,A7
                    1879   ; SPI_CS = 1;
0000135C  13FC 0001 1880          move.b    #1,4227112
00001360  0040 8028 
                    1881   ; return;
00001364  4E75      1882          rts
                    1883   ; }
                    1884   ; //General SPI command function
                    1885   ; void SPI_Command(int cmd){
                    1886   _SPI_Command:
00001366  4E56 0000 1887          link      A6,#0
                    1888   ; Enable_SPI_CS();
0000136A  13FC 00FE 1889          move.b    #254,4227112
0000136E  0040 8028 
                    1890   ; WriteSPIChar(cmd);
00001372  2F2E 0008 1891          move.l    8(A6),-(A7)
00001376  4EB8 1310 1892          jsr       _WriteSPIChar
0000137A  584F      1893          addq.w    #4,A7
                    1894   ; Disable_SPI_CS();
0000137C  13FC 00FF 1895          move.b    #255,4227112
00001380  0040 8028 
00001384  4E5E      1896          unlk      A6
00001386  4E75      1897          rts
                    1898   ; }
                    1899   ; //Wait for SPI write complete /check if SPI is busy
                    1900   ; void Wait_SPI_Write_Complete(){
                    1901   _Wait_SPI_Write_Complete:
                    1902   ; Enable_SPI_CS();
00001388  13FC 00FE 1903          move.b    #254,4227112
0000138C  0040 8028 
                    1904   ; // status register (SPSR) reset value: 0x05
                    1905   ; WriteSPIChar(0x05);
00001390  4878 0005 1906          pea       5
00001394  4EB8 1310 1907          jsr       _WriteSPIChar
00001398  584F      1908          addq.w    #4,A7
                    1909   ; // WriteSPIChar will return received data, if bit 0 (RFEMPTY) is high,
                    1910   ; // FIFO is empty and write is complete
                    1911   ; while(WriteSPIChar(0x00)&0x01);
                    1912   Wait_SPI_Write_Complete_1:
0000139A  42A7      1913          clr.l     -(A7)
0000139C  4EB8 1310 1914          jsr       _WriteSPIChar
000013A0  584F      1915          addq.w    #4,A7
000013A2  C0BC 0000 1916          and.l     #1,D0
000013A6  0001      
000013A8  6702      1917          beq.s     Wait_SPI_Write_Complete_3
000013AA  60EE      1918          bra       Wait_SPI_Write_Complete_1
                    1919   Wait_SPI_Write_Complete_3:
                    1920   ; Disable_SPI_CS();
000013AC  13FC 00FF 1921          move.b    #255,4227112
000013B0  0040 8028 
000013B4  4E75      1922          rts
                    1923   ; }
                    1924   ; //Erase SPI chip data
                    1925   ; void EraseSPI(void){
                    1926   _EraseSPI:
                    1927   ; SPI_Write_Enable();
000013B6  4EB8 1332 1928          jsr       _SPI_Write_Enable
                    1929   ; SPI_Command(0xC7);
000013BA  4878 00C7 1930          pea       199
000013BE  4EB8 1366 1931          jsr       _SPI_Command
000013C2  584F      1932          addq.w    #4,A7
                    1933   ; Wait_SPI_Write_Complete();
000013C4  4EB8 1388 1934          jsr       _Wait_SPI_Write_Complete
                    1935   ; SPI_Write_Disable();
000013C8  4EB8 134C 1936          jsr       _SPI_Write_Disable
000013CC  4E75      1937          rts
                    1938   ; }
                    1939   ; /*******************************************************************
                    1940   ; ** Write a program to SPI Flash Chip from memory and verify by reading back
                    1941   ; ********************************************************************/
                    1942   ; #define RAM_START 0x08000000
                    1943   ; #define RAM_END 0x08040000
                    1944   ; #define RAM_START 0x08000000
                    1945   ; #define RAM_END 0x08040000
                    1946   ; void ProgramFlashChip(void){
                    1947   _ProgramFlashChip:
000013CE  48E7 3C20 1948          movem.l   D2/D3/D4/D5/A2,-(A7)
000013D2  45F8 1310 1949          lea       _WriteSPIChar.L,A2
                    1950   ; //
                    1951   ; // TODO : put your code here to program the 1st 256k of ram (where user program is held at hex 08000000) to SPI flash chip
                    1952   ; // TODO : then verify by reading it back and comparing to memory
                    1953   ; //
                    1954   ; unsigned char *RamPtr = 0x08000000;
000013D6  263C 0800 1955          move.l    #134217728,D3
000013DA  0000      
                    1956   ; // Define a variable to store the flash address
                    1957   ; int flash_addr = 0x000000;
000013DC  4282      1958          clr.l     D2
                    1959   ; int i = 0;
000013DE  4285      1960          clr.l     D5
                    1961   ; int j = 0;
000013E0  4284      1962          clr.l     D4
                    1963   ; SPI_Write_Enable();
000013E2  4EB8 1332 1964          jsr       _SPI_Write_Enable
                    1965   ; // Write the data from the RAM to the SPI flash chip
                    1966   ; while (RamPtr < (int *)RAM_END){
                    1967   ProgramFlashChip_1:
000013E6  0C83 0804 1968          cmp.l     #134479872,D3
000013EA  0000      
000013EC  6400 004C 1969          bhs       ProgramFlashChip_3
                    1970   ; //Send Page Program Instruction
                    1971   ; WriteSPIChar(0x02);
000013F0  4878 0002 1972          pea       2
000013F4  4E92      1973          jsr       (A2)
000013F6  584F      1974          addq.w    #4,A7
                    1975   ; WriteSPIChar((flash_addr >> 16));
000013F8  2202      1976          move.l    D2,D1
000013FA  E081      1977          asr.l     #8,D1
000013FC  E081      1978          asr.l     #8,D1
000013FE  2F01      1979          move.l    D1,-(A7)
00001400  4E92      1980          jsr       (A2)
00001402  584F      1981          addq.w    #4,A7
                    1982   ; WriteSPIChar((flash_addr >> 8));
00001404  2202      1983          move.l    D2,D1
00001406  E081      1984          asr.l     #8,D1
00001408  2F01      1985          move.l    D1,-(A7)
0000140A  4E92      1986          jsr       (A2)
0000140C  584F      1987          addq.w    #4,A7
                    1988   ; WriteSPIChar(flash_addr);
0000140E  2F02      1989          move.l    D2,-(A7)
00001410  4E92      1990          jsr       (A2)
00001412  584F      1991          addq.w    #4,A7
                    1992   ; // Copy the data from the RAM to the tx buffer
                    1993   ; while (i < 64){
                    1994   ProgramFlashChip_4:
00001414  0C85 0000 1995          cmp.l     #64,D5
00001418  0040      
0000141A  6C16      1996          bge.s     ProgramFlashChip_6
                    1997   ; WriteSPIChar(*RamPtr++);
0000141C  2043      1998          move.l    D3,A0
0000141E  5283      1999          addq.l    #1,D3
00001420  1210      2000          move.b    (A0),D1
00001422  C2BC 0000 2001          and.l     #255,D1
00001426  00FF      
00001428  2F01      2002          move.l    D1,-(A7)
0000142A  4E92      2003          jsr       (A2)
0000142C  584F      2004          addq.w    #4,A7
                    2005   ; i++;
0000142E  5285      2006          addq.l    #1,D5
00001430  60E2      2007          bra       ProgramFlashChip_4
                    2008   ProgramFlashChip_6:
                    2009   ; }
                    2010   ; // Increment the flash address by 256 bytes
                    2011   ; flash_addr += 0x100;
00001432  0682 0000 2012          add.l     #256,D2
00001436  0100      
00001438  60AC      2013          bra       ProgramFlashChip_1
                    2014   ProgramFlashChip_3:
                    2015   ; }
                    2016   ; // Disable the write protection of the SPI flash chip
                    2017   ; //Disable_SPI_CS();
                    2018   ; SPI_Write_Disable();
0000143A  4EB8 134C 2019          jsr       _SPI_Write_Disable
                    2020   ; // Reset the pointer to the start of the RAM
                    2021   ; RamPtr = (int *)RAM_START;
0000143E  263C 0800 2022          move.l    #134217728,D3
00001442  0000      
                    2023   ; // Reset the flash address to 0x000000
                    2024   ; flash_addr = 0x000000;
00001444  4282      2025          clr.l     D2
                    2026   ; // Read the data from the SPI flash chip and compare with the RAM
                    2027   ; while (RamPtr < (int *)RAM_END)
                    2028   ProgramFlashChip_7:
00001446  0C83 0804 2029          cmp.l     #134479872,D3
0000144A  0000      
0000144C  6400 0094 2030          bhs       ProgramFlashChip_9
                    2031   ; {
                    2032   ; // Send the READ command and the flash address
                    2033   ; WriteSPIChar(0x03);
00001450  4878 0003 2034          pea       3
00001454  4E92      2035          jsr       (A2)
00001456  584F      2036          addq.w    #4,A7
                    2037   ; WriteSPIChar((flash_addr >> 16) & 0xFF);
00001458  2202      2038          move.l    D2,D1
0000145A  E081      2039          asr.l     #8,D1
0000145C  E081      2040          asr.l     #8,D1
0000145E  C2BC 0000 2041          and.l     #255,D1
00001462  00FF      
00001464  2F01      2042          move.l    D1,-(A7)
00001466  4E92      2043          jsr       (A2)
00001468  584F      2044          addq.w    #4,A7
                    2045   ; WriteSPIChar((flash_addr >> 8) & 0xFF);
0000146A  2202      2046          move.l    D2,D1
0000146C  E081      2047          asr.l     #8,D1
0000146E  C2BC 0000 2048          and.l     #255,D1
00001472  00FF      
00001474  2F01      2049          move.l    D1,-(A7)
00001476  4E92      2050          jsr       (A2)
00001478  584F      2051          addq.w    #4,A7
                    2052   ; WriteSPIChar(flash_addr & 0xFF);
0000147A  2202      2053          move.l    D2,D1
0000147C  C2BC 0000 2054          and.l     #255,D1
00001480  00FF      
00001482  2F01      2055          move.l    D1,-(A7)
00001484  4E92      2056          jsr       (A2)
00001486  584F      2057          addq.w    #4,A7
                    2058   ; // Compare the data in the rx buffer with the RAM
                    2059   ; for (j = 0; j < 64; j++)
00001488  4284      2060          clr.l     D4
                    2061   ProgramFlashChip_10:
0000148A  0C84 0000 2062          cmp.l     #64,D4
0000148E  0040      
00001490  6C00 0046 2063          bge       ProgramFlashChip_12
                    2064   ; {
                    2065   ; if (WriteSPIChar(0x00) != *RamPtr++)
00001494  42A7      2066          clr.l     -(A7)
00001496  4E92      2067          jsr       (A2)
00001498  584F      2068          addq.w    #4,A7
0000149A  2043      2069          move.l    D3,A0
0000149C  5283      2070          addq.l    #1,D3
0000149E  1210      2071          move.b    (A0),D1
000014A0  C2BC 0000 2072          and.l     #255,D1
000014A4  00FF      
000014A6  B081      2073          cmp.l     D1,D0
000014A8  672A      2074          beq.s     ProgramFlashChip_13
                    2075   ; {
                    2076   ; // Report an error if the data does not match
                    2077   ; printf("Error: Data mismatch at address 0x%06X\n", flash_addr + j*4);
000014AA  2202      2078          move.l    D2,D1
000014AC  2F04      2079          move.l    D4,-(A7)
000014AE  4878 0004 2080          pea       4
000014B2  2F00      2081          move.l    D0,-(A7)
000014B4  4EB9 0000 2082          jsr       LMUL
000014B8  5908      
000014BA  2017      2083          move.l    (A7),D0
000014BC  504F      2084          addq.w    #8,A7
000014BE  201F      2085          move.l    (A7)+,D0
000014C0  D280      2086          add.l     D0,D1
000014C2  2F01      2087          move.l    D1,-(A7)
000014C4  4879 0000 2088          pea       @m68kde~2_28.L
000014C8  6662      
000014CA  4EB9 0000 2089          jsr       _printf
000014CE  5AA4      
000014D0  504F      2090          addq.w    #8,A7
                    2091   ; return;
000014D2  601E      2092          bra.s     ProgramFlashChip_15
                    2093   ProgramFlashChip_13:
000014D4  5284      2094          addq.l    #1,D4
000014D6  60B2      2095          bra       ProgramFlashChip_10
                    2096   ProgramFlashChip_12:
                    2097   ; }
                    2098   ; }
                    2099   ; // Increment the flash address by 256 bytes
                    2100   ; flash_addr += 0x100;
000014D8  0682 0000 2101          add.l     #256,D2
000014DC  0100      
000014DE  6000 FF66 2102          bra       ProgramFlashChip_7
                    2103   ProgramFlashChip_9:
                    2104   ; }
                    2105   ; // Report success if the data matches
                    2106   ; printf("Success: Data verified\n");
000014E2  4879 0000 2107          pea       @m68kde~2_29.L
000014E6  668A      
000014E8  4EB9 0000 2108          jsr       _printf
000014EC  5AA4      
000014EE  584F      2109          addq.w    #4,A7
                    2110   ; return 0;
000014F0  4240      2111          clr       D0
                    2112   ProgramFlashChip_15:
000014F2  4CDF 043C 2113          movem.l   (A7)+,D2/D3/D4/D5/A2
000014F6  4E75      2114          rts
                    2115   ; }
                    2116   ; #define RAM_START 0x08000000
                    2117   ; #define RAM_END 0x08040000
                    2118   ; #define FLASH_START 0x000000
                    2119   ; #define FLASH_END 0x004000
                    2120   ; /*************************************************************************
                    2121   ; ** Load a program from SPI Flash Chip and copy to Dram
                    2122   ; **************************************************************************/
                    2123   ; void LoadFromFlashChip(void)
                    2124   ; {
                    2125   _LoadFromFlashChip:
000014F8  48E7 3820 2126          movem.l   D2/D3/D4/A2,-(A7)
000014FC  45F8 1310 2127          lea       _WriteSPIChar.L,A2
                    2128   ; int *RamPtr = (int *)RAM_START;
00001500  283C 0800 2129          move.l    #134217728,D4
00001504  0000      
                    2130   ; // Define a variable to store the flash address
                    2131   ; int flash_addr = FLASH_START;
00001506  4282      2132          clr.l     D2
                    2133   ; int i;    
                    2134   ; printf("\r\nLoading Program From SPI Flash....") ;
00001508  4879 0000 2135          pea       @m68kde~2_30.L
0000150C  66A2      
0000150E  4EB9 0000 2136          jsr       _printf
00001512  5AA4      
00001514  584F      2137          addq.w    #4,A7
                    2138   ; //
                    2139   ; // TODO : put your code here to read 256k of data from SPI flash chip and store in user ram starting at hex 08000000
                    2140   ; //
                    2141   ; printf("\r\nLoading Program From SPI Flash....") ;
00001516  4879 0000 2142          pea       @m68kde~2_30.L
0000151A  66A2      
0000151C  4EB9 0000 2143          jsr       _printf
00001520  5AA4      
00001522  584F      2144          addq.w    #4,A7
                    2145   ; // Define the start and end addresses of the RAM and the flash chip
                    2146   ; // Define a pointer to access the RAM
                    2147   ; // Initialize the SPI flash chip
                    2148   ; SPI_Init();
00001524  4EB8 12DC 2149          jsr       _SPI_Init
                    2150   ; // Read the data from the flash chip and copy to the RAM
                    2151   ; while (RamPtr < (int *)RAM_END)
                    2152   LoadFromFlashChip_1:
00001528  0C84 0804 2153          cmp.l     #134479872,D4
0000152C  0000      
0000152E  6400 005C 2154          bhs       LoadFromFlashChip_3
                    2155   ; {
                    2156   ; // Send the READ command and the flash address
                    2157   ; WriteSPIChar(0x03);
00001532  4878 0003 2158          pea       3
00001536  4E92      2159          jsr       (A2)
00001538  584F      2160          addq.w    #4,A7
                    2161   ; WriteSPIChar((flash_addr >> 16) & 0xFF);
0000153A  2202      2162          move.l    D2,D1
0000153C  E081      2163          asr.l     #8,D1
0000153E  E081      2164          asr.l     #8,D1
00001540  C2BC 0000 2165          and.l     #255,D1
00001544  00FF      
00001546  2F01      2166          move.l    D1,-(A7)
00001548  4E92      2167          jsr       (A2)
0000154A  584F      2168          addq.w    #4,A7
                    2169   ; WriteSPIChar((flash_addr >> 8) & 0xFF);
0000154C  2202      2170          move.l    D2,D1
0000154E  E081      2171          asr.l     #8,D1
00001550  C2BC 0000 2172          and.l     #255,D1
00001554  00FF      
00001556  2F01      2173          move.l    D1,-(A7)
00001558  4E92      2174          jsr       (A2)
0000155A  584F      2175          addq.w    #4,A7
                    2176   ; WriteSPIChar(flash_addr & 0xFF);
0000155C  2202      2177          move.l    D2,D1
0000155E  C2BC 0000 2178          and.l     #255,D1
00001562  00FF      
00001564  2F01      2179          move.l    D1,-(A7)
00001566  4E92      2180          jsr       (A2)
00001568  584F      2181          addq.w    #4,A7
                    2182   ; // Receive the data from the flash chip and copy to the RAM
                    2183   ; for (i = 0; i < 64; i++)
0000156A  4283      2184          clr.l     D3
                    2185   LoadFromFlashChip_4:
0000156C  0C83 0000 2186          cmp.l     #64,D3
00001570  0040      
00001572  6C10      2187          bge.s     LoadFromFlashChip_6
                    2188   ; {
                    2189   ; *RamPtr++ = WriteSPIChar(0x00);
00001574  42A7      2190          clr.l     -(A7)
00001576  4E92      2191          jsr       (A2)
00001578  584F      2192          addq.w    #4,A7
0000157A  2044      2193          move.l    D4,A0
0000157C  5884      2194          addq.l    #4,D4
0000157E  2080      2195          move.l    D0,(A0)
00001580  5283      2196          addq.l    #1,D3
00001582  60E8      2197          bra       LoadFromFlashChip_4
                    2198   LoadFromFlashChip_6:
                    2199   ; }
                    2200   ; // Increment the flash address by 256 bytes
                    2201   ; flash_addr += 0x100;
00001584  0682 0000 2202          add.l     #256,D2
00001588  0100      
0000158A  609C      2203          bra       LoadFromFlashChip_1
                    2204   LoadFromFlashChip_3:
                    2205   ; }
                    2206   ; // Close the SPI flash chip
                    2207   ; Disable_SPI_CS();
0000158C  13FC 00FF 2208          move.b    #255,4227112
00001590  0040 8028 
00001594  4CDF 041C 2209          movem.l   (A7)+,D2/D3/D4/A2
00001598  4E75      2210          rts
                    2211   ; }
                    2212   ; // get rid of excess spaces
                    2213   ; void FormatInstructionForTrace(void)
                    2214   ; {
                    2215   _FormatInstructionForTrace:
0000159A  4E56 FF9C 2216          link      A6,#-100
0000159E  48E7 3C20 2217          movem.l   D2/D3/D4/D5/A2,-(A7)
000015A2  45EE FF9C 2218          lea       -100(A6),A2
                    2219   ; unsigned short int i ;
                    2220   ; char c, temp[100], *iptr, *tempptr ;
                    2221   ; for(i=0; i < 100; i++)
000015A6  4244      2222          clr.w     D4
                    2223   FormatInstructionForTrace_1:
000015A8  0C44 0064 2224          cmp.w     #100,D4
000015AC  640E      2225          bhs.s     FormatInstructionForTrace_3
                    2226   ; temp[i] = 0 ;
000015AE  C8BC 0000 2227          and.l     #65535,D4
000015B2  FFFF      
000015B4  4232 4800 2228          clr.b     0(A2,D4.L)
000015B8  5244      2229          addq.w    #1,D4
000015BA  60EC      2230          bra       FormatInstructionForTrace_1
                    2231   FormatInstructionForTrace_3:
                    2232   ; iptr = Instruction ;
000015BC  41F9 0B00 2233          lea       _Instruction.L,A0
000015C0  04E2      
000015C2  2408      2234          move.l    A0,D2
                    2235   ; tempptr = temp ;
000015C4  2A0A      2236          move.l    A2,D5
                    2237   ; do{
                    2238   FormatInstructionForTrace_4:
                    2239   ; c = *iptr++ ;
000015C6  2042      2240          move.l    D2,A0
000015C8  5282      2241          addq.l    #1,D2
000015CA  1610      2242          move.b    (A0),D3
                    2243   ; *tempptr++ = c ;  // copy chars over
000015CC  2045      2244          move.l    D5,A0
000015CE  5285      2245          addq.l    #1,D5
000015D0  1083      2246          move.b    D3,(A0)
                    2247   ; if(c == ' ')  {   // if copied space
000015D2  0C03 0020 2248          cmp.b     #32,D3
000015D6  6622      2249          bne.s     FormatInstructionForTrace_6
                    2250   ; while(*iptr == ' ') {
                    2251   FormatInstructionForTrace_8:
000015D8  2042      2252          move.l    D2,A0
000015DA  1010      2253          move.b    (A0),D0
000015DC  0C00 0020 2254          cmp.b     #32,D0
000015E0  660C      2255          bne.s     FormatInstructionForTrace_10
                    2256   ; if(*iptr == 0)  // if end of string then done
000015E2  2042      2257          move.l    D2,A0
000015E4  1010      2258          move.b    (A0),D0
000015E6  6602      2259          bne.s     FormatInstructionForTrace_11
                    2260   ; break ;
000015E8  6004      2261          bra.s     FormatInstructionForTrace_10
                    2262   FormatInstructionForTrace_11:
                    2263   ; iptr++ ; // skip over remaining spaces
000015EA  5282      2264          addq.l    #1,D2
000015EC  60EA      2265          bra       FormatInstructionForTrace_8
                    2266   FormatInstructionForTrace_10:
                    2267   ; }
                    2268   ; strcat(tempptr,iptr) ;
000015EE  2F02      2269          move.l    D2,-(A7)
000015F0  2F05      2270          move.l    D5,-(A7)
000015F2  4EB9 0000 2271          jsr       _strcat
000015F6  5A62      
000015F8  504F      2272          addq.w    #8,A7
                    2273   FormatInstructionForTrace_6:
000015FA  4A03      2274          tst.b     D3
000015FC  66C8      2275          bne       FormatInstructionForTrace_4
                    2276   ; }
                    2277   ; }while(c != 0) ;
                    2278   ; strcpyInstruction(temp) ;
000015FE  2F0A      2279          move.l    A2,-(A7)
00001600  4EB8 0CE6 2280          jsr       _strcpyInstruction
00001604  584F      2281          addq.w    #4,A7
00001606  4CDF 043C 2282          movem.l   (A7)+,D2/D3/D4/D5/A2
0000160A  4E5E      2283          unlk      A6
0000160C  4E75      2284          rts
                    2285   ; }
                    2286   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    2287   ; // IMPORTANT
                    2288   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    2289   ; // has to be done with an interrupt (IRQ Level 6)
                    2290   ; //
                    2291   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    2292   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    2293   ; //
                    2294   ; // on return from the IRQ service handler, the first access to the user memory program space
                    2295   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    2296   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    2297   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    2298   ; // program area
                    2299   ; //
                    2300   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    2301   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    2302   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    2303   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    2304   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    2305   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    2306   ; void DumpRegisters()
                    2307   ; {
                    2308   _DumpRegisters:
0000160E  48E7 3F3C 2309          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001612  45F9 0000 2310          lea       _putch.L,A2
00001616  5996      
00001618  47F9 0000 2311          lea       _printf.L,A3
0000161C  5AA4      
0000161E  49F9 0B00 2312          lea       _SR.L,A4
00001622  012C      
00001624  4BF9 0B00 2313          lea       _WatchPointString.L,A5
00001628  01C2      
                    2314   ; short i, x, j, k ;
                    2315   ; unsigned char c, *BytePointer;
                    2316   ; // buld up strings for displaying watchpoints
                    2317   ; for(x = 0; x < (short)(8); x++)
0000162A  4242      2318          clr.w     D2
                    2319   DumpRegisters_1:
0000162C  0C42 0008 2320          cmp.w     #8,D2
00001630  6C00 01C6 2321          bge       DumpRegisters_3
                    2322   ; {
                    2323   ; if(WatchPointSetOrCleared[x] == 1)
00001634  48C2      2324          ext.l     D2
00001636  2002      2325          move.l    D2,D0
00001638  E588      2326          lsl.l     #2,D0
0000163A  41F9 0B00 2327          lea       _WatchPointSetOrCleared.L,A0
0000163E  01A2      
00001640  2030 0800 2328          move.l    0(A0,D0.L),D0
00001644  0C80 0000 2329          cmp.l     #1,D0
00001648  0001      
0000164A  6600 0186 2330          bne       DumpRegisters_4
                    2331   ; {
                    2332   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]) ;
0000164E  48C2      2333          ext.l     D2
00001650  2202      2334          move.l    D2,D1
00001652  E589      2335          lsl.l     #2,D1
00001654  41F9 0B00 2336          lea       _WatchPointAddress.L,A0
00001658  0182      
0000165A  2F30 1800 2337          move.l    0(A0,D1.L),-(A7)
0000165E  4879 0000 2338          pea       @m68kde~2_31.L
00001662  66C8      
00001664  220D      2339          move.l    A5,D1
00001666  48C2      2340          ext.l     D2
00001668  2F00      2341          move.l    D0,-(A7)
0000166A  2002      2342          move.l    D2,D0
0000166C  C1FC 0064 2343          muls      #100,D0
00001670  D280      2344          add.l     D0,D1
00001672  201F      2345          move.l    (A7)+,D0
00001674  2F01      2346          move.l    D1,-(A7)
00001676  4EB9 0000 2347          jsr       _sprintf
0000167A  5A2E      
0000167C  DEFC 000C 2348          add.w     #12,A7
                    2349   ; BytePointer = (char *)(WatchPointAddress[x]) ;
00001680  48C2      2350          ext.l     D2
00001682  2002      2351          move.l    D2,D0
00001684  E588      2352          lsl.l     #2,D0
00001686  41F9 0B00 2353          lea       _WatchPointAddress.L,A0
0000168A  0182      
0000168C  2A30 0800 2354          move.l    0(A0,D0.L),D5
                    2355   ; for(j = 0; j < (short)(16); j+=2)
00001690  4243      2356          clr.w     D3
                    2357   DumpRegisters_6:
00001692  0C43 0010 2358          cmp.w     #16,D3
00001696  6C00 0082 2359          bge       DumpRegisters_8
                    2360   ; {
                    2361   ; for(k = 0; k < (short)(2); k++)
0000169A  4246      2362          clr.w     D6
                    2363   DumpRegisters_9:
0000169C  0C46 0002 2364          cmp.w     #2,D6
000016A0  6C00 0052 2365          bge       DumpRegisters_11
                    2366   ; {
                    2367   ; sprintf(TempString, "%02X", BytePointer[j+k]) ;
000016A4  2045      2368          move.l    D5,A0
000016A6  48C3      2369          ext.l     D3
000016A8  2203      2370          move.l    D3,D1
000016AA  48C6      2371          ext.l     D6
000016AC  D286      2372          add.l     D6,D1
000016AE  1230 1800 2373          move.b    0(A0,D1.L),D1
000016B2  C2BC 0000 2374          and.l     #255,D1
000016B6  00FF      
000016B8  2F01      2375          move.l    D1,-(A7)
000016BA  4879 0000 2376          pea       @m68kde~2_14.L
000016BE  64B8      
000016C0  4879 0B00 2377          pea       _TempString.L
000016C4  0546      
000016C6  4EB9 0000 2378          jsr       _sprintf
000016CA  5A2E      
000016CC  DEFC 000C 2379          add.w     #12,A7
                    2380   ; strcat(WatchPointString[x], TempString) ;
000016D0  4879 0B00 2381          pea       _TempString.L
000016D4  0546      
000016D6  220D      2382          move.l    A5,D1
000016D8  48C2      2383          ext.l     D2
000016DA  2F00      2384          move.l    D0,-(A7)
000016DC  2002      2385          move.l    D2,D0
000016DE  C1FC 0064 2386          muls      #100,D0
000016E2  D280      2387          add.l     D0,D1
000016E4  201F      2388          move.l    (A7)+,D0
000016E6  2F01      2389          move.l    D1,-(A7)
000016E8  4EB9 0000 2390          jsr       _strcat
000016EC  5A62      
000016EE  504F      2391          addq.w    #8,A7
000016F0  5246      2392          addq.w    #1,D6
000016F2  60A8      2393          bra       DumpRegisters_9
                    2394   DumpRegisters_11:
                    2395   ; }
                    2396   ; strcat(WatchPointString[x]," ") ;
000016F4  4879 0000 2397          pea       @m68kde~2_32.L
000016F8  66D0      
000016FA  220D      2398          move.l    A5,D1
000016FC  48C2      2399          ext.l     D2
000016FE  2F00      2400          move.l    D0,-(A7)
00001700  2002      2401          move.l    D2,D0
00001702  C1FC 0064 2402          muls      #100,D0
00001706  D280      2403          add.l     D0,D1
00001708  201F      2404          move.l    (A7)+,D0
0000170A  2F01      2405          move.l    D1,-(A7)
0000170C  4EB9 0000 2406          jsr       _strcat
00001710  5A62      
00001712  504F      2407          addq.w    #8,A7
00001714  5443      2408          addq.w    #2,D3
00001716  6000 FF7A 2409          bra       DumpRegisters_6
                    2410   DumpRegisters_8:
                    2411   ; }
                    2412   ; strcat(WatchPointString[x], "  ") ;
0000171A  4879 0000 2413          pea       @m68kde~2_15.L
0000171E  64BE      
00001720  220D      2414          move.l    A5,D1
00001722  48C2      2415          ext.l     D2
00001724  2F00      2416          move.l    D0,-(A7)
00001726  2002      2417          move.l    D2,D0
00001728  C1FC 0064 2418          muls      #100,D0
0000172C  D280      2419          add.l     D0,D1
0000172E  201F      2420          move.l    (A7)+,D0
00001730  2F01      2421          move.l    D1,-(A7)
00001732  4EB9 0000 2422          jsr       _strcat
00001736  5A62      
00001738  504F      2423          addq.w    #8,A7
                    2424   ; BytePointer = (char *)(WatchPointAddress[x]) ;
0000173A  48C2      2425          ext.l     D2
0000173C  2002      2426          move.l    D2,D0
0000173E  E588      2427          lsl.l     #2,D0
00001740  41F9 0B00 2428          lea       _WatchPointAddress.L,A0
00001744  0182      
00001746  2A30 0800 2429          move.l    0(A0,D0.L),D5
                    2430   ; for(j = 0; j < (short)(16); j++)
0000174A  4243      2431          clr.w     D3
                    2432   DumpRegisters_12:
0000174C  0C43 0010 2433          cmp.w     #16,D3
00001750  6C00 007E 2434          bge       DumpRegisters_14
                    2435   ; {
                    2436   ; c = ((char)(BytePointer[j]) & 0x7f) ;
00001754  2045      2437          move.l    D5,A0
00001756  48C3      2438          ext.l     D3
00001758  1030 3800 2439          move.b    0(A0,D3.L),D0
0000175C  C03C 007F 2440          and.b     #127,D0
00001760  1E00      2441          move.b    D0,D7
                    2442   ; if((c > (char)(0x7f)) || (c < (char)(' ')))
00001762  0C07 007F 2443          cmp.b     #127,D7
00001766  6206      2444          bhi.s     DumpRegisters_17
00001768  0C07 0020 2445          cmp.b     #32,D7
0000176C  6416      2446          bhs.s     DumpRegisters_15
                    2447   DumpRegisters_17:
                    2448   ; sprintf(TempString, ".") ;
0000176E  4879 0000 2449          pea       @m68kde~2_33.L
00001772  66D2      
00001774  4879 0B00 2450          pea       _TempString.L
00001778  0546      
0000177A  4EB9 0000 2451          jsr       _sprintf
0000177E  5A2E      
00001780  504F      2452          addq.w    #8,A7
00001782  6026      2453          bra.s     DumpRegisters_16
                    2454   DumpRegisters_15:
                    2455   ; else
                    2456   ; sprintf(TempString, "%c", BytePointer[j]) ;
00001784  2045      2457          move.l    D5,A0
00001786  48C3      2458          ext.l     D3
00001788  1230 3800 2459          move.b    0(A0,D3.L),D1
0000178C  C2BC 0000 2460          and.l     #255,D1
00001790  00FF      
00001792  2F01      2461          move.l    D1,-(A7)
00001794  4879 0000 2462          pea       @m68kde~2_34.L
00001798  66D4      
0000179A  4879 0B00 2463          pea       _TempString.L
0000179E  0546      
000017A0  4EB9 0000 2464          jsr       _sprintf
000017A4  5A2E      
000017A6  DEFC 000C 2465          add.w     #12,A7
                    2466   DumpRegisters_16:
                    2467   ; strcat(WatchPointString[x], TempString) ;
000017AA  4879 0B00 2468          pea       _TempString.L
000017AE  0546      
000017B0  220D      2469          move.l    A5,D1
000017B2  48C2      2470          ext.l     D2
000017B4  2F00      2471          move.l    D0,-(A7)
000017B6  2002      2472          move.l    D2,D0
000017B8  C1FC 0064 2473          muls      #100,D0
000017BC  D280      2474          add.l     D0,D1
000017BE  201F      2475          move.l    (A7)+,D0
000017C0  2F01      2476          move.l    D1,-(A7)
000017C2  4EB9 0000 2477          jsr       _strcat
000017C6  5A62      
000017C8  504F      2478          addq.w    #8,A7
000017CA  5243      2479          addq.w    #1,D3
000017CC  6000 FF7E 2480          bra       DumpRegisters_12
                    2481   DumpRegisters_14:
000017D0  6020      2482          bra.s     DumpRegisters_5
                    2483   DumpRegisters_4:
                    2484   ; }
                    2485   ; }
                    2486   ; else
                    2487   ; strcpy(WatchPointString[x], "") ;
000017D2  4879 0000 2488          pea       @m68kde~2_35.L
000017D6  66D8      
000017D8  220D      2489          move.l    A5,D1
000017DA  48C2      2490          ext.l     D2
000017DC  2F00      2491          move.l    D0,-(A7)
000017DE  2002      2492          move.l    D2,D0
000017E0  C1FC 0064 2493          muls      #100,D0
000017E4  D280      2494          add.l     D0,D1
000017E6  201F      2495          move.l    (A7)+,D0
000017E8  2F01      2496          move.l    D1,-(A7)
000017EA  4EB9 0000 2497          jsr       _strcpy
000017EE  5808      
000017F0  504F      2498          addq.w    #8,A7
                    2499   DumpRegisters_5:
000017F2  5242      2500          addq.w    #1,D2
000017F4  6000 FE36 2501          bra       DumpRegisters_1
                    2502   DumpRegisters_3:
                    2503   ; }
                    2504   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X",d0,a0) ;
000017F8  2F39 0B00 2505          move.l    _a0.L,-(A7)
000017FC  0104      
000017FE  2F39 0B00 2506          move.l    _d0.L,-(A7)
00001802  00E4      
00001804  4879 0000 2507          pea       @m68kde~2_36.L
00001808  66DA      
0000180A  4E93      2508          jsr       (A3)
0000180C  DEFC 000C 2509          add.w     #12,A7
                    2510   ; printf("\r\n D1 = $%08X  A1 = $%08X",d1,a1) ;
00001810  2F39 0B00 2511          move.l    _a1.L,-(A7)
00001814  0108      
00001816  2F39 0B00 2512          move.l    _d1.L,-(A7)
0000181A  00E8      
0000181C  4879 0000 2513          pea       @m68kde~2_37.L
00001820  66F6      
00001822  4E93      2514          jsr       (A3)
00001824  DEFC 000C 2515          add.w     #12,A7
                    2516   ; printf("\r\n D2 = $%08X  A2 = $%08X",d2,a2) ;
00001828  2F39 0B00 2517          move.l    _a2.L,-(A7)
0000182C  010C      
0000182E  2F39 0B00 2518          move.l    _d2.L,-(A7)
00001832  00EC      
00001834  4879 0000 2519          pea       @m68kde~2_38.L
00001838  6710      
0000183A  4E93      2520          jsr       (A3)
0000183C  DEFC 000C 2521          add.w     #12,A7
                    2522   ; printf("\r\n D3 = $%08X  A3 = $%08X",d3,a3) ;
00001840  2F39 0B00 2523          move.l    _a3.L,-(A7)
00001844  0110      
00001846  2F39 0B00 2524          move.l    _d3.L,-(A7)
0000184A  00F0      
0000184C  4879 0000 2525          pea       @m68kde~2_39.L
00001850  672A      
00001852  4E93      2526          jsr       (A3)
00001854  DEFC 000C 2527          add.w     #12,A7
                    2528   ; printf("\r\n D4 = $%08X  A4 = $%08X",d4,a4) ;
00001858  2F39 0B00 2529          move.l    _a4.L,-(A7)
0000185C  0114      
0000185E  2F39 0B00 2530          move.l    _d4.L,-(A7)
00001862  00F4      
00001864  4879 0000 2531          pea       @m68kde~2_40.L
00001868  6744      
0000186A  4E93      2532          jsr       (A3)
0000186C  DEFC 000C 2533          add.w     #12,A7
                    2534   ; printf("\r\n D5 = $%08X  A5 = $%08X",d5,a5) ;
00001870  2F39 0B00 2535          move.l    _a5.L,-(A7)
00001874  0118      
00001876  2F39 0B00 2536          move.l    _d5.L,-(A7)
0000187A  00F8      
0000187C  4879 0000 2537          pea       @m68kde~2_41.L
00001880  675E      
00001882  4E93      2538          jsr       (A3)
00001884  DEFC 000C 2539          add.w     #12,A7
                    2540   ; printf("\r\n D6 = $%08X  A6 = $%08X",d6,a6) ;
00001888  2F39 0B00 2541          move.l    _a6.L,-(A7)
0000188C  011C      
0000188E  2F39 0B00 2542          move.l    _d6.L,-(A7)
00001892  00FC      
00001894  4879 0000 2543          pea       @m68kde~2_42.L
00001898  6778      
0000189A  4E93      2544          jsr       (A3)
0000189C  DEFC 000C 2545          add.w     #12,A7
                    2546   ; printf("\r\n D7 = $%08X  A7 = $%08X",d7,((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP) ;
000018A0  3214      2547          move.w    (A4),D1
000018A2  C27C 2000 2548          and.w     #8192,D1
000018A6  0C41 2000 2549          cmp.w     #8192,D1
000018AA  6608      2550          bne.s     DumpRegisters_18
000018AC  2239 0B00 2551          move.l    _SSP.L,D1
000018B0  0124      
000018B2  6006      2552          bra.s     DumpRegisters_19
                    2553   DumpRegisters_18:
000018B4  2239 0B00 2554          move.l    _USP.L,D1
000018B8  0128      
                    2555   DumpRegisters_19:
000018BA  2F01      2556          move.l    D1,-(A7)
000018BC  2F39 0B00 2557          move.l    _d7.L,-(A7)
000018C0  0100      
000018C2  4879 0000 2558          pea       @m68kde~2_43.L
000018C6  6792      
000018C8  4E93      2559          jsr       (A3)
000018CA  DEFC 000C 2560          add.w     #12,A7
                    2561   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP ) ;
000018CE  2F39 0B00 2562          move.l    _USP.L,-(A7)
000018D2  0128      
000018D4  4879 0000 2563          pea       @m68kde~2_44.L
000018D8  67AC      
000018DA  4E93      2564          jsr       (A3)
000018DC  504F      2565          addq.w    #8,A7
                    2566   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP) ;
000018DE  2F39 0B00 2567          move.l    _SSP.L,-(A7)
000018E2  0124      
000018E4  4879 0000 2568          pea       @m68kde~2_45.L
000018E8  67CA      
000018EA  4E93      2569          jsr       (A3)
000018EC  504F      2570          addq.w    #8,A7
                    2571   ; printf("\r\n SR = $%04X   ",SR) ;
000018EE  3214      2572          move.w    (A4),D1
000018F0  C2BC 0000 2573          and.l     #65535,D1
000018F4  FFFF      
000018F6  2F01      2574          move.l    D1,-(A7)
000018F8  4879 0000 2575          pea       @m68kde~2_46.L
000018FC  67EC      
000018FE  4E93      2576          jsr       (A3)
00001900  504F      2577          addq.w    #8,A7
                    2578   ; // display the status word in characters etc.
                    2579   ; printf("   [") ;
00001902  4879 0000 2580          pea       @m68kde~2_47.L
00001906  67FE      
00001908  4E93      2581          jsr       (A3)
0000190A  584F      2582          addq.w    #4,A7
                    2583   ; if((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T') ; else putchar('-') ;      // Trace bit(bit 15)
0000190C  3014      2584          move.w    (A4),D0
0000190E  C07C 8000 2585          and.w     #32768,D0
00001912  0C40 8000 2586          cmp.w     #32768,D0
00001916  660A      2587          bne.s     DumpRegisters_20
00001918  4878 0054 2588          pea       84
0000191C  4E92      2589          jsr       (A2)
0000191E  584F      2590          addq.w    #4,A7
00001920  6008      2591          bra.s     DumpRegisters_21
                    2592   DumpRegisters_20:
00001922  4878 002D 2593          pea       45
00001926  4E92      2594          jsr       (A2)
00001928  584F      2595          addq.w    #4,A7
                    2596   DumpRegisters_21:
                    2597   ; if((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S') ; else putchar('U') ;      // supervisor bit  (bit 13)
0000192A  3014      2598          move.w    (A4),D0
0000192C  C07C 2000 2599          and.w     #8192,D0
00001930  0C40 2000 2600          cmp.w     #8192,D0
00001934  660A      2601          bne.s     DumpRegisters_22
00001936  4878 0053 2602          pea       83
0000193A  4E92      2603          jsr       (A2)
0000193C  584F      2604          addq.w    #4,A7
0000193E  6008      2605          bra.s     DumpRegisters_23
                    2606   DumpRegisters_22:
00001940  4878 0055 2607          pea       85
00001944  4E92      2608          jsr       (A2)
00001946  584F      2609          addq.w    #4,A7
                    2610   DumpRegisters_23:
                    2611   ; if((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1') ; else putchar('0') ;      // IRQ2 Bit (bit 10)
00001948  3014      2612          move.w    (A4),D0
0000194A  C07C 0400 2613          and.w     #1024,D0
0000194E  0C40 0400 2614          cmp.w     #1024,D0
00001952  660A      2615          bne.s     DumpRegisters_24
00001954  4878 0031 2616          pea       49
00001958  4E92      2617          jsr       (A2)
0000195A  584F      2618          addq.w    #4,A7
0000195C  6008      2619          bra.s     DumpRegisters_25
                    2620   DumpRegisters_24:
0000195E  4878 0030 2621          pea       48
00001962  4E92      2622          jsr       (A2)
00001964  584F      2623          addq.w    #4,A7
                    2624   DumpRegisters_25:
                    2625   ; if((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1') ; else putchar('0') ;      // IRQ1 Bit (bit 9)
00001966  3014      2626          move.w    (A4),D0
00001968  C07C 0200 2627          and.w     #512,D0
0000196C  0C40 0200 2628          cmp.w     #512,D0
00001970  660A      2629          bne.s     DumpRegisters_26
00001972  4878 0031 2630          pea       49
00001976  4E92      2631          jsr       (A2)
00001978  584F      2632          addq.w    #4,A7
0000197A  6008      2633          bra.s     DumpRegisters_27
                    2634   DumpRegisters_26:
0000197C  4878 0030 2635          pea       48
00001980  4E92      2636          jsr       (A2)
00001982  584F      2637          addq.w    #4,A7
                    2638   DumpRegisters_27:
                    2639   ; if((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1') ; else putchar('0') ;      // IRQ0 Bit (bit 8)
00001984  3014      2640          move.w    (A4),D0
00001986  C07C 0100 2641          and.w     #256,D0
0000198A  0C40 0100 2642          cmp.w     #256,D0
0000198E  660A      2643          bne.s     DumpRegisters_28
00001990  4878 0031 2644          pea       49
00001994  4E92      2645          jsr       (A2)
00001996  584F      2646          addq.w    #4,A7
00001998  6008      2647          bra.s     DumpRegisters_29
                    2648   DumpRegisters_28:
0000199A  4878 0030 2649          pea       48
0000199E  4E92      2650          jsr       (A2)
000019A0  584F      2651          addq.w    #4,A7
                    2652   DumpRegisters_29:
                    2653   ; if((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X') ; else putchar('-') ;      // X Bit (bit 4)
000019A2  3014      2654          move.w    (A4),D0
000019A4  C07C 0010 2655          and.w     #16,D0
000019A8  0C40 0010 2656          cmp.w     #16,D0
000019AC  660A      2657          bne.s     DumpRegisters_30
000019AE  4878 0058 2658          pea       88
000019B2  4E92      2659          jsr       (A2)
000019B4  584F      2660          addq.w    #4,A7
000019B6  6008      2661          bra.s     DumpRegisters_31
                    2662   DumpRegisters_30:
000019B8  4878 002D 2663          pea       45
000019BC  4E92      2664          jsr       (A2)
000019BE  584F      2665          addq.w    #4,A7
                    2666   DumpRegisters_31:
                    2667   ; if((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N') ; else putchar('-') ;      // N Bit (bit 3)
000019C0  3014      2668          move.w    (A4),D0
000019C2  C07C 0008 2669          and.w     #8,D0
000019C6  0C40 0008 2670          cmp.w     #8,D0
000019CA  660A      2671          bne.s     DumpRegisters_32
000019CC  4878 004E 2672          pea       78
000019D0  4E92      2673          jsr       (A2)
000019D2  584F      2674          addq.w    #4,A7
000019D4  6008      2675          bra.s     DumpRegisters_33
                    2676   DumpRegisters_32:
000019D6  4878 002D 2677          pea       45
000019DA  4E92      2678          jsr       (A2)
000019DC  584F      2679          addq.w    #4,A7
                    2680   DumpRegisters_33:
                    2681   ; if((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z') ; else putchar('-') ;      // Z Bit (bit 2)
000019DE  3014      2682          move.w    (A4),D0
000019E0  C07C 0004 2683          and.w     #4,D0
000019E4  0C40 0004 2684          cmp.w     #4,D0
000019E8  660A      2685          bne.s     DumpRegisters_34
000019EA  4878 005A 2686          pea       90
000019EE  4E92      2687          jsr       (A2)
000019F0  584F      2688          addq.w    #4,A7
000019F2  6008      2689          bra.s     DumpRegisters_35
                    2690   DumpRegisters_34:
000019F4  4878 002D 2691          pea       45
000019F8  4E92      2692          jsr       (A2)
000019FA  584F      2693          addq.w    #4,A7
                    2694   DumpRegisters_35:
                    2695   ; if((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V') ; else putchar('-') ;      // V Bit (bit 1)
000019FC  3014      2696          move.w    (A4),D0
000019FE  C07C 0002 2697          and.w     #2,D0
00001A02  0C40 0002 2698          cmp.w     #2,D0
00001A06  660A      2699          bne.s     DumpRegisters_36
00001A08  4878 0056 2700          pea       86
00001A0C  4E92      2701          jsr       (A2)
00001A0E  584F      2702          addq.w    #4,A7
00001A10  6008      2703          bra.s     DumpRegisters_37
                    2704   DumpRegisters_36:
00001A12  4878 002D 2705          pea       45
00001A16  4E92      2706          jsr       (A2)
00001A18  584F      2707          addq.w    #4,A7
                    2708   DumpRegisters_37:
                    2709   ; if((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C') ; else putchar('-') ;      // C Bit (bit 0)
00001A1A  3014      2710          move.w    (A4),D0
00001A1C  C07C 0001 2711          and.w     #1,D0
00001A20  0C40 0001 2712          cmp.w     #1,D0
00001A24  660A      2713          bne.s     DumpRegisters_38
00001A26  4878 0043 2714          pea       67
00001A2A  4E92      2715          jsr       (A2)
00001A2C  584F      2716          addq.w    #4,A7
00001A2E  6008      2717          bra.s     DumpRegisters_39
                    2718   DumpRegisters_38:
00001A30  4878 002D 2719          pea       45
00001A34  4E92      2720          jsr       (A2)
00001A36  584F      2721          addq.w    #4,A7
                    2722   DumpRegisters_39:
                    2723   ; putchar(']') ;
00001A38  4878 005D 2724          pea       93
00001A3C  4E92      2725          jsr       (A2)
00001A3E  584F      2726          addq.w    #4,A7
                    2727   ; printf("\r\n PC = $%08X  ", PC) ;
00001A40  2F39 0B00 2728          move.l    _PC.L,-(A7)
00001A44  0120      
00001A46  4879 0000 2729          pea       @m68kde~2_48.L
00001A4A  6804      
00001A4C  4E93      2730          jsr       (A3)
00001A4E  504F      2731          addq.w    #8,A7
                    2732   ; if(*(unsigned short int *)(PC) != 0x4e4e)   {
00001A50  2039 0B00 2733          move.l    _PC.L,D0
00001A54  0120      
00001A56  2040      2734          move.l    D0,A0
00001A58  3010      2735          move.w    (A0),D0
00001A5A  0C40 4E4E 2736          cmp.w     #20046,D0
00001A5E  6724      2737          beq.s     DumpRegisters_40
                    2738   ; DisassembleInstruction(PC) ;
00001A60  2F39 0B00 2739          move.l    _PC.L,-(A7)
00001A64  0120      
00001A66  4EB9 0000 2740          jsr       _DisassembleInstruction
00001A6A  3966      
00001A6C  584F      2741          addq.w    #4,A7
                    2742   ; FormatInstructionForTrace() ;
00001A6E  4EB8 159A 2743          jsr       _FormatInstructionForTrace
                    2744   ; printf("%s", Instruction) ;
00001A72  4879 0B00 2745          pea       _Instruction.L
00001A76  04E2      
00001A78  4879 0000 2746          pea       @m68kde~2_49.L
00001A7C  6814      
00001A7E  4E93      2747          jsr       (A3)
00001A80  504F      2748          addq.w    #8,A7
00001A82  600A      2749          bra.s     DumpRegisters_41
                    2750   DumpRegisters_40:
                    2751   ; }
                    2752   ; else
                    2753   ; printf("[BREAKPOINT]") ;
00001A84  4879 0000 2754          pea       @m68kde~2_50.L
00001A88  6818      
00001A8A  4E93      2755          jsr       (A3)
00001A8C  584F      2756          addq.w    #4,A7
                    2757   DumpRegisters_41:
                    2758   ; printf("\r\n") ;
00001A8E  4879 0000 2759          pea       @m68kde~2_1.L
00001A92  6354      
00001A94  4E93      2760          jsr       (A3)
00001A96  584F      2761          addq.w    #4,A7
                    2762   ; for(i=0; i < 8; i++)    {
00001A98  4244      2763          clr.w     D4
                    2764   DumpRegisters_42:
00001A9A  0C44 0008 2765          cmp.w     #8,D4
00001A9E  6C00 0040 2766          bge       DumpRegisters_44
                    2767   ; if(WatchPointSetOrCleared[i] == 1)
00001AA2  48C4      2768          ext.l     D4
00001AA4  2004      2769          move.l    D4,D0
00001AA6  E588      2770          lsl.l     #2,D0
00001AA8  41F9 0B00 2771          lea       _WatchPointSetOrCleared.L,A0
00001AAC  01A2      
00001AAE  2030 0800 2772          move.l    0(A0,D0.L),D0
00001AB2  0C80 0000 2773          cmp.l     #1,D0
00001AB6  0001      
00001AB8  6622      2774          bne.s     DumpRegisters_45
                    2775   ; printf("\r\nWP%d = %s", i, WatchPointString[i]) ;
00001ABA  220D      2776          move.l    A5,D1
00001ABC  48C4      2777          ext.l     D4
00001ABE  2F00      2778          move.l    D0,-(A7)
00001AC0  2004      2779          move.l    D4,D0
00001AC2  C1FC 0064 2780          muls      #100,D0
00001AC6  D280      2781          add.l     D0,D1
00001AC8  201F      2782          move.l    (A7)+,D0
00001ACA  2F01      2783          move.l    D1,-(A7)
00001ACC  48C4      2784          ext.l     D4
00001ACE  2F04      2785          move.l    D4,-(A7)
00001AD0  4879 0000 2786          pea       @m68kde~2_51.L
00001AD4  6826      
00001AD6  4E93      2787          jsr       (A3)
00001AD8  DEFC 000C 2788          add.w     #12,A7
                    2789   DumpRegisters_45:
00001ADC  5244      2790          addq.w    #1,D4
00001ADE  60BA      2791          bra       DumpRegisters_42
                    2792   DumpRegisters_44:
00001AE0  4CDF 3CFC 2793          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001AE4  4E75      2794          rts
                    2795   ; }
                    2796   ; }
                    2797   ; // Trace Exception Handler
                    2798   ; void DumpRegistersandPause(void)
                    2799   ; {
                    2800   _DumpRegistersandPause:
00001AE6  2F0A      2801          move.l    A2,-(A7)
00001AE8  45F9 0000 2802          lea       _printf.L,A2
00001AEC  5AA4      
                    2803   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]") ;
00001AEE  4879 0000 2804          pea       @m68kde~2_52.L
00001AF2  6832      
00001AF4  4E92      2805          jsr       (A2)
00001AF6  584F      2806          addq.w    #4,A7
                    2807   ; printf("\r\nBreak Points :[Disabled]") ;
00001AF8  4879 0000 2808          pea       @m68kde~2_53.L
00001AFC  6852      
00001AFE  4E92      2809          jsr       (A2)
00001B00  584F      2810          addq.w    #4,A7
                    2811   ; DumpRegisters() ;
00001B02  4EB8 160E 2812          jsr       _DumpRegisters
                    2813   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00001B06  4879 0000 2814          pea       @m68kde~2_54.L
00001B0A  686E      
00001B0C  4E92      2815          jsr       (A2)
00001B0E  584F      2816          addq.w    #4,A7
                    2817   ; printf("\r\nPress <ESC> to Resume Program") ;
00001B10  4879 0000 2818          pea       @m68kde~2_55.L
00001B14  689A      
00001B16  4E92      2819          jsr       (A2)
00001B18  584F      2820          addq.w    #4,A7
                    2821   ; menu() ;
00001B1A  4EB9 0000 2822          jsr       _menu
00001B1E  2750      
00001B20  245F      2823          move.l    (A7)+,A2
00001B22  4E75      2824          rts
                    2825   ; }
                    2826   ; void ChangeRegisters(void)
                    2827   ; {
                    2828   _ChangeRegisters:
00001B24  4E56 FFFC 2829          link      A6,#-4
00001B28  48E7 303C 2830          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00001B2C  45F9 0000 2831          lea       _printf.L,A2
00001B30  5AA4      
00001B32  47EE FFFC 2832          lea       -4(A6),A3
00001B36  49F8 0CA4 2833          lea       _Get8HexDigits.L,A4
00001B3A  4BF8 0B68 2834          lea       __getch.L,A5
                    2835   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    2836   ; int reg_val ;
                    2837   ; char c, reg[3] ;
                    2838   ; reg[0] = tolower(_getch()) ;
00001B3E  2F00      2839          move.l    D0,-(A7)
00001B40  4E95      2840          jsr       (A5)
00001B42  2200      2841          move.l    D0,D1
00001B44  201F      2842          move.l    (A7)+,D0
00001B46  2F01      2843          move.l    D1,-(A7)
00001B48  4EB9 0000 2844          jsr       _tolower
00001B4C  5A02      
00001B4E  584F      2845          addq.w    #4,A7
00001B50  1680      2846          move.b    D0,(A3)
                    2847   ; reg[1] = c = tolower(_getch()) ;
00001B52  2F00      2848          move.l    D0,-(A7)
00001B54  4E95      2849          jsr       (A5)
00001B56  2200      2850          move.l    D0,D1
00001B58  201F      2851          move.l    (A7)+,D0
00001B5A  2F01      2852          move.l    D1,-(A7)
00001B5C  4EB9 0000 2853          jsr       _tolower
00001B60  5A02      
00001B62  584F      2854          addq.w    #4,A7
00001B64  1400      2855          move.b    D0,D2
00001B66  1740 0001 2856          move.b    D0,1(A3)
                    2857   ; if(reg[0] == (char)('d'))  {    // change data register
00001B6A  1013      2858          move.b    (A3),D0
00001B6C  0C00 0064 2859          cmp.b     #100,D0
00001B70  6600 00AE 2860          bne       ChangeRegisters_1
                    2861   ; if((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
00001B74  102B 0001 2862          move.b    1(A3),D0
00001B78  0C00 0037 2863          cmp.b     #55,D0
00001B7C  6E0A      2864          bgt.s     ChangeRegisters_5
00001B7E  102B 0001 2865          move.b    1(A3),D0
00001B82  0C00 0030 2866          cmp.b     #48,D0
00001B86  6C0E      2867          bge.s     ChangeRegisters_3
                    2868   ChangeRegisters_5:
                    2869   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n") ;
00001B88  4879 0000 2870          pea       @m68kde~2_56.L
00001B8C  68BA      
00001B8E  4E92      2871          jsr       (A2)
00001B90  584F      2872          addq.w    #4,A7
                    2873   ; return ;
00001B92  6000 0244 2874          bra       ChangeRegisters_6
                    2875   ChangeRegisters_3:
                    2876   ; }
                    2877   ; else {
                    2878   ; printf("\r\nD%c = ", c) ;
00001B96  4882      2879          ext.w     D2
00001B98  48C2      2880          ext.l     D2
00001B9A  2F02      2881          move.l    D2,-(A7)
00001B9C  4879 0000 2882          pea       @m68kde~2_57.L
00001BA0  68E6      
00001BA2  4E92      2883          jsr       (A2)
00001BA4  504F      2884          addq.w    #8,A7
                    2885   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001BA6  42A7      2886          clr.l     -(A7)
00001BA8  4E94      2887          jsr       (A4)
00001BAA  584F      2888          addq.w    #4,A7
00001BAC  2600      2889          move.l    D0,D3
                    2890   ; }
                    2891   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    2892   ; if(c == (char)('0'))
00001BAE  0C02 0030 2893          cmp.b     #48,D2
00001BB2  660A      2894          bne.s     ChangeRegisters_7
                    2895   ; d0 = reg_val ;
00001BB4  23C3 0B00 2896          move.l    D3,_d0.L
00001BB8  00E4      
00001BBA  6000 0060 2897          bra       ChangeRegisters_20
                    2898   ChangeRegisters_7:
                    2899   ; else if(c == (char)('1'))
00001BBE  0C02 0031 2900          cmp.b     #49,D2
00001BC2  660A      2901          bne.s     ChangeRegisters_9
                    2902   ; d1 = reg_val ;
00001BC4  23C3 0B00 2903          move.l    D3,_d1.L
00001BC8  00E8      
00001BCA  6000 0050 2904          bra       ChangeRegisters_20
                    2905   ChangeRegisters_9:
                    2906   ; else if(c == (char)('2'))
00001BCE  0C02 0032 2907          cmp.b     #50,D2
00001BD2  660A      2908          bne.s     ChangeRegisters_11
                    2909   ; d2 = reg_val ;
00001BD4  23C3 0B00 2910          move.l    D3,_d2.L
00001BD8  00EC      
00001BDA  6000 0040 2911          bra       ChangeRegisters_20
                    2912   ChangeRegisters_11:
                    2913   ; else if(c == (char)('3'))
00001BDE  0C02 0033 2914          cmp.b     #51,D2
00001BE2  6608      2915          bne.s     ChangeRegisters_13
                    2916   ; d3 = reg_val ;
00001BE4  23C3 0B00 2917          move.l    D3,_d3.L
00001BE8  00F0      
00001BEA  6030      2918          bra.s     ChangeRegisters_20
                    2919   ChangeRegisters_13:
                    2920   ; else if(c == (char)('4'))
00001BEC  0C02 0034 2921          cmp.b     #52,D2
00001BF0  6608      2922          bne.s     ChangeRegisters_15
                    2923   ; d4 = reg_val ;
00001BF2  23C3 0B00 2924          move.l    D3,_d4.L
00001BF6  00F4      
00001BF8  6022      2925          bra.s     ChangeRegisters_20
                    2926   ChangeRegisters_15:
                    2927   ; else if(c == (char)('5'))
00001BFA  0C02 0035 2928          cmp.b     #53,D2
00001BFE  6608      2929          bne.s     ChangeRegisters_17
                    2930   ; d5 = reg_val ;
00001C00  23C3 0B00 2931          move.l    D3,_d5.L
00001C04  00F8      
00001C06  6014      2932          bra.s     ChangeRegisters_20
                    2933   ChangeRegisters_17:
                    2934   ; else if(c == (char)('6'))
00001C08  0C02 0036 2935          cmp.b     #54,D2
00001C0C  6608      2936          bne.s     ChangeRegisters_19
                    2937   ; d6 = reg_val ;
00001C0E  23C3 0B00 2938          move.l    D3,_d6.L
00001C12  00FC      
00001C14  6006      2939          bra.s     ChangeRegisters_20
                    2940   ChangeRegisters_19:
                    2941   ; else
                    2942   ; d7 = reg_val ;
00001C16  23C3 0B00 2943          move.l    D3,_d7.L
00001C1A  0100      
                    2944   ChangeRegisters_20:
00001C1C  6000 01B6 2945          bra       ChangeRegisters_51
                    2946   ChangeRegisters_1:
                    2947   ; }
                    2948   ; else if(reg[0] == (char)('a'))  {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
00001C20  1013      2949          move.b    (A3),D0
00001C22  0C00 0061 2950          cmp.b     #97,D0
00001C26  6600 00A6 2951          bne       ChangeRegisters_21
                    2952   ; if((c > (char)('7')) || (c < (char)('0'))) {
00001C2A  0C02 0037 2953          cmp.b     #55,D2
00001C2E  6E06      2954          bgt.s     ChangeRegisters_25
00001C30  0C02 0030 2955          cmp.b     #48,D2
00001C34  6C0E      2956          bge.s     ChangeRegisters_23
                    2957   ChangeRegisters_25:
                    2958   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n") ;
00001C36  4879 0000 2959          pea       @m68kde~2_58.L
00001C3A  68F0      
00001C3C  4E92      2960          jsr       (A2)
00001C3E  584F      2961          addq.w    #4,A7
                    2962   ; return ;
00001C40  6000 0196 2963          bra       ChangeRegisters_6
                    2964   ChangeRegisters_23:
                    2965   ; }
                    2966   ; else {
                    2967   ; printf("\r\nA%c = ", c) ;
00001C44  4882      2968          ext.w     D2
00001C46  48C2      2969          ext.l     D2
00001C48  2F02      2970          move.l    D2,-(A7)
00001C4A  4879 0000 2971          pea       @m68kde~2_59.L
00001C4E  691E      
00001C50  4E92      2972          jsr       (A2)
00001C52  504F      2973          addq.w    #8,A7
                    2974   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001C54  42A7      2975          clr.l     -(A7)
00001C56  4E94      2976          jsr       (A4)
00001C58  584F      2977          addq.w    #4,A7
00001C5A  2600      2978          move.l    D0,D3
                    2979   ; }
                    2980   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    2981   ; if(c == (char)('0'))
00001C5C  0C02 0030 2982          cmp.b     #48,D2
00001C60  660A      2983          bne.s     ChangeRegisters_26
                    2984   ; a0 = reg_val ;
00001C62  23C3 0B00 2985          move.l    D3,_a0.L
00001C66  0104      
00001C68  6000 0060 2986          bra       ChangeRegisters_39
                    2987   ChangeRegisters_26:
                    2988   ; else if(c == (char)('1'))
00001C6C  0C02 0031 2989          cmp.b     #49,D2
00001C70  660A      2990          bne.s     ChangeRegisters_28
                    2991   ; a1 = reg_val ;
00001C72  23C3 0B00 2992          move.l    D3,_a1.L
00001C76  0108      
00001C78  6000 0050 2993          bra       ChangeRegisters_39
                    2994   ChangeRegisters_28:
                    2995   ; else if(c == (char)('2'))
00001C7C  0C02 0032 2996          cmp.b     #50,D2
00001C80  660A      2997          bne.s     ChangeRegisters_30
                    2998   ; a2 = reg_val ;
00001C82  23C3 0B00 2999          move.l    D3,_a2.L
00001C86  010C      
00001C88  6000 0040 3000          bra       ChangeRegisters_39
                    3001   ChangeRegisters_30:
                    3002   ; else if(c == (char)('3'))
00001C8C  0C02 0033 3003          cmp.b     #51,D2
00001C90  6608      3004          bne.s     ChangeRegisters_32
                    3005   ; a3 = reg_val ;
00001C92  23C3 0B00 3006          move.l    D3,_a3.L
00001C96  0110      
00001C98  6030      3007          bra.s     ChangeRegisters_39
                    3008   ChangeRegisters_32:
                    3009   ; else if(c == (char)('4'))
00001C9A  0C02 0034 3010          cmp.b     #52,D2
00001C9E  6608      3011          bne.s     ChangeRegisters_34
                    3012   ; a4 = reg_val ;
00001CA0  23C3 0B00 3013          move.l    D3,_a4.L
00001CA4  0114      
00001CA6  6022      3014          bra.s     ChangeRegisters_39
                    3015   ChangeRegisters_34:
                    3016   ; else if(c == (char)('5'))
00001CA8  0C02 0035 3017          cmp.b     #53,D2
00001CAC  6608      3018          bne.s     ChangeRegisters_36
                    3019   ; a5 = reg_val ;
00001CAE  23C3 0B00 3020          move.l    D3,_a5.L
00001CB2  0118      
00001CB4  6014      3021          bra.s     ChangeRegisters_39
                    3022   ChangeRegisters_36:
                    3023   ; else if(c == (char)('6'))
00001CB6  0C02 0036 3024          cmp.b     #54,D2
00001CBA  6608      3025          bne.s     ChangeRegisters_38
                    3026   ; a6 = reg_val ;
00001CBC  23C3 0B00 3027          move.l    D3,_a6.L
00001CC0  011C      
00001CC2  6006      3028          bra.s     ChangeRegisters_39
                    3029   ChangeRegisters_38:
                    3030   ; else
                    3031   ; USP = reg_val ;
00001CC4  23C3 0B00 3032          move.l    D3,_USP.L
00001CC8  0128      
                    3033   ChangeRegisters_39:
00001CCA  6000 0108 3034          bra       ChangeRegisters_51
                    3035   ChangeRegisters_21:
                    3036   ; }
                    3037   ; else if((reg[0] == (char)('u')) && (c == (char)('s')))  {
00001CCE  1013      3038          move.b    (A3),D0
00001CD0  0C00 0075 3039          cmp.b     #117,D0
00001CD4  6600 004E 3040          bne       ChangeRegisters_40
00001CD8  0C02 0073 3041          cmp.b     #115,D2
00001CDC  6600 0046 3042          bne       ChangeRegisters_40
                    3043   ; if(tolower(_getch()) == 'p')  {    // change user stack pointer
00001CE0  2F00      3044          move.l    D0,-(A7)
00001CE2  4E95      3045          jsr       (A5)
00001CE4  2200      3046          move.l    D0,D1
00001CE6  201F      3047          move.l    (A7)+,D0
00001CE8  2F01      3048          move.l    D1,-(A7)
00001CEA  4EB9 0000 3049          jsr       _tolower
00001CEE  5A02      
00001CF0  584F      3050          addq.w    #4,A7
00001CF2  0C80 0000 3051          cmp.l     #112,D0
00001CF6  0070      
00001CF8  6618      3052          bne.s     ChangeRegisters_42
                    3053   ; printf("\r\nUser SP = ") ;
00001CFA  4879 0000 3054          pea       @m68kde~2_60.L
00001CFE  6928      
00001D00  4E92      3055          jsr       (A2)
00001D02  584F      3056          addq.w    #4,A7
                    3057   ; USP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001D04  42A7      3058          clr.l     -(A7)
00001D06  4E94      3059          jsr       (A4)
00001D08  584F      3060          addq.w    #4,A7
00001D0A  23C0 0B00 3061          move.l    D0,_USP.L
00001D0E  0128      
00001D10  600E      3062          bra.s     ChangeRegisters_43
                    3063   ChangeRegisters_42:
                    3064   ; }
                    3065   ; else {
                    3066   ; printf("\r\nIllegal Register....") ;
00001D12  4879 0000 3067          pea       @m68kde~2_61.L
00001D16  6936      
00001D18  4E92      3068          jsr       (A2)
00001D1A  584F      3069          addq.w    #4,A7
                    3070   ; return ;
00001D1C  6000 00BA 3071          bra       ChangeRegisters_6
                    3072   ChangeRegisters_43:
00001D20  6000 00B2 3073          bra       ChangeRegisters_51
                    3074   ChangeRegisters_40:
                    3075   ; }
                    3076   ; }
                    3077   ; else if((reg[0] == (char)('s')) && (c == (char)('s')))  {
00001D24  1013      3078          move.b    (A3),D0
00001D26  0C00 0073 3079          cmp.b     #115,D0
00001D2A  6600 004E 3080          bne       ChangeRegisters_44
00001D2E  0C02 0073 3081          cmp.b     #115,D2
00001D32  6600 0046 3082          bne       ChangeRegisters_44
                    3083   ; if(tolower(_getch()) == 'p')  {    // change system stack pointer
00001D36  2F00      3084          move.l    D0,-(A7)
00001D38  4E95      3085          jsr       (A5)
00001D3A  2200      3086          move.l    D0,D1
00001D3C  201F      3087          move.l    (A7)+,D0
00001D3E  2F01      3088          move.l    D1,-(A7)
00001D40  4EB9 0000 3089          jsr       _tolower
00001D44  5A02      
00001D46  584F      3090          addq.w    #4,A7
00001D48  0C80 0000 3091          cmp.l     #112,D0
00001D4C  0070      
00001D4E  6618      3092          bne.s     ChangeRegisters_46
                    3093   ; printf("\r\nSystem SP = ") ;
00001D50  4879 0000 3094          pea       @m68kde~2_62.L
00001D54  694E      
00001D56  4E92      3095          jsr       (A2)
00001D58  584F      3096          addq.w    #4,A7
                    3097   ; SSP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001D5A  42A7      3098          clr.l     -(A7)
00001D5C  4E94      3099          jsr       (A4)
00001D5E  584F      3100          addq.w    #4,A7
00001D60  23C0 0B00 3101          move.l    D0,_SSP.L
00001D64  0124      
00001D66  600E      3102          bra.s     ChangeRegisters_47
                    3103   ChangeRegisters_46:
                    3104   ; }
                    3105   ; else {
                    3106   ; printf("\r\nIllegal Register....") ;
00001D68  4879 0000 3107          pea       @m68kde~2_61.L
00001D6C  6936      
00001D6E  4E92      3108          jsr       (A2)
00001D70  584F      3109          addq.w    #4,A7
                    3110   ; return ;
00001D72  6000 0064 3111          bra       ChangeRegisters_6
                    3112   ChangeRegisters_47:
00001D76  6000 005C 3113          bra       ChangeRegisters_51
                    3114   ChangeRegisters_44:
                    3115   ; }
                    3116   ; }
                    3117   ; else if((reg[0] == (char)('p')) && (c == (char)('c')))  {    // change program counter
00001D7A  1013      3118          move.b    (A3),D0
00001D7C  0C00 0070 3119          cmp.b     #112,D0
00001D80  6620      3120          bne.s     ChangeRegisters_48
00001D82  0C02 0063 3121          cmp.b     #99,D2
00001D86  661A      3122          bne.s     ChangeRegisters_48
                    3123   ; printf("\r\nPC = ") ;
00001D88  4879 0000 3124          pea       @m68kde~2_63.L
00001D8C  695E      
00001D8E  4E92      3125          jsr       (A2)
00001D90  584F      3126          addq.w    #4,A7
                    3127   ; PC = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00001D92  42A7      3128          clr.l     -(A7)
00001D94  4E94      3129          jsr       (A4)
00001D96  584F      3130          addq.w    #4,A7
00001D98  23C0 0B00 3131          move.l    D0,_PC.L
00001D9C  0120      
00001D9E  6000 0034 3132          bra       ChangeRegisters_51
                    3133   ChangeRegisters_48:
                    3134   ; }
                    3135   ; else if((reg[0] == (char)('s')) && (c == (char)('r')))  {    // change status register
00001DA2  1013      3136          move.b    (A3),D0
00001DA4  0C00 0073 3137          cmp.b     #115,D0
00001DA8  6620      3138          bne.s     ChangeRegisters_50
00001DAA  0C02 0072 3139          cmp.b     #114,D2
00001DAE  661A      3140          bne.s     ChangeRegisters_50
                    3141   ; printf("\r\nSR = ") ;
00001DB0  4879 0000 3142          pea       @m68kde~2_64.L
00001DB4  6966      
00001DB6  4E92      3143          jsr       (A2)
00001DB8  584F      3144          addq.w    #4,A7
                    3145   ; SR = Get4HexDigits(0) ;    // read 16 bit value from user keyboard
00001DBA  42A7      3146          clr.l     -(A7)
00001DBC  4EB8 0C58 3147          jsr       _Get4HexDigits
00001DC0  584F      3148          addq.w    #4,A7
00001DC2  33C0 0B00 3149          move.w    D0,_SR.L
00001DC6  012C      
00001DC8  600A      3150          bra.s     ChangeRegisters_51
                    3151   ChangeRegisters_50:
                    3152   ; }
                    3153   ; else
                    3154   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n") ;
00001DCA  4879 0000 3155          pea       @m68kde~2_65.L
00001DCE  696E      
00001DD0  4E92      3156          jsr       (A2)
00001DD2  584F      3157          addq.w    #4,A7
                    3158   ChangeRegisters_51:
                    3159   ; DumpRegisters() ;
00001DD4  4EB8 160E 3160          jsr       _DumpRegisters
                    3161   ChangeRegisters_6:
00001DD8  4CDF 3C0C 3162          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00001DDC  4E5E      3163          unlk      A6
00001DDE  4E75      3164          rts
                    3165   ; }
                    3166   ; void BreakPointDisplay(void)
                    3167   ; {
                    3168   _BreakPointDisplay:
00001DE0  48E7 3030 3169          movem.l   D2/D3/A2/A3,-(A7)
00001DE4  45F9 0000 3170          lea       _printf.L,A2
00001DE8  5AA4      
00001DEA  47F9 0B00 3171          lea       _BreakPointAddress.L,A3
00001DEE  012E      
                    3172   ; int i, BreakPointsSet = 0 ;
00001DF0  4283      3173          clr.l     D3
                    3174   ; // any break points  set
                    3175   ; for(i = 0; i < 8; i++)  {
00001DF2  4282      3176          clr.l     D2
                    3177   BreakPointDisplay_1:
00001DF4  0C82 0000 3178          cmp.l     #8,D2
00001DF8  0008      
00001DFA  6C1C      3179          bge.s     BreakPointDisplay_3
                    3180   ; if(BreakPointSetOrCleared[i] == 1)
00001DFC  2002      3181          move.l    D2,D0
00001DFE  E588      3182          lsl.l     #2,D0
00001E00  41F9 0B00 3183          lea       _BreakPointSetOrCleared.L,A0
00001E04  015E      
00001E06  2030 0800 3184          move.l    0(A0,D0.L),D0
00001E0A  0C80 0000 3185          cmp.l     #1,D0
00001E0E  0001      
00001E10  6602      3186          bne.s     BreakPointDisplay_4
                    3187   ; BreakPointsSet = 1;
00001E12  7601      3188          moveq     #1,D3
                    3189   BreakPointDisplay_4:
00001E14  5282      3190          addq.l    #1,D2
00001E16  60DC      3191          bra       BreakPointDisplay_1
                    3192   BreakPointDisplay_3:
                    3193   ; }
                    3194   ; if(BreakPointsSet == 1) {
00001E18  0C83 0000 3195          cmp.l     #1,D3
00001E1C  0001      
00001E1E  6616      3196          bne.s     BreakPointDisplay_6
                    3197   ; printf("\r\n\r\nNum     Address      Instruction") ;
00001E20  4879 0000 3198          pea       @m68kde~2_66.L
00001E24  69AA      
00001E26  4E92      3199          jsr       (A2)
00001E28  584F      3200          addq.w    #4,A7
                    3201   ; printf("\r\n---     ---------    -----------") ;
00001E2A  4879 0000 3202          pea       @m68kde~2_67.L
00001E2E  69D0      
00001E30  4E92      3203          jsr       (A2)
00001E32  584F      3204          addq.w    #4,A7
00001E34  600A      3205          bra.s     BreakPointDisplay_7
                    3206   BreakPointDisplay_6:
                    3207   ; }
                    3208   ; else
                    3209   ; printf("\r\nNo BreakPoints Set") ;
00001E36  4879 0000 3210          pea       @m68kde~2_68.L
00001E3A  69F4      
00001E3C  4E92      3211          jsr       (A2)
00001E3E  584F      3212          addq.w    #4,A7
                    3213   BreakPointDisplay_7:
                    3214   ; for(i = 0; i < 8; i++)  {
00001E40  4282      3215          clr.l     D2
                    3216   BreakPointDisplay_8:
00001E42  0C82 0000 3217          cmp.l     #8,D2
00001E46  0008      
00001E48  6C00 0080 3218          bge       BreakPointDisplay_10
                    3219   ; // put opcode back to disassemble it, then put break point back
                    3220   ; if(BreakPointSetOrCleared[i] == 1)  {
00001E4C  2002      3221          move.l    D2,D0
00001E4E  E588      3222          lsl.l     #2,D0
00001E50  41F9 0B00 3223          lea       _BreakPointSetOrCleared.L,A0
00001E54  015E      
00001E56  2030 0800 3224          move.l    0(A0,D0.L),D0
00001E5A  0C80 0000 3225          cmp.l     #1,D0
00001E5E  0001      
00001E60  6600 0062 3226          bne       BreakPointDisplay_11
                    3227   ; *(unsigned short int *)(BreakPointAddress[i]) = BreakPointInstruction[i];
00001E64  2002      3228          move.l    D2,D0
00001E66  E388      3229          lsl.l     #1,D0
00001E68  41F9 0B00 3230          lea       _BreakPointInstruction.L,A0
00001E6C  014E      
00001E6E  2202      3231          move.l    D2,D1
00001E70  E589      3232          lsl.l     #2,D1
00001E72  2233 1800 3233          move.l    0(A3,D1.L),D1
00001E76  2241      3234          move.l    D1,A1
00001E78  32B0 0800 3235          move.w    0(A0,D0.L),(A1)
                    3236   ; DisassembleInstruction(BreakPointAddress[i]) ;
00001E7C  2202      3237          move.l    D2,D1
00001E7E  E589      3238          lsl.l     #2,D1
00001E80  2F33 1800 3239          move.l    0(A3,D1.L),-(A7)
00001E84  4EB9 0000 3240          jsr       _DisassembleInstruction
00001E88  3966      
00001E8A  584F      3241          addq.w    #4,A7
                    3242   ; FormatInstructionForTrace() ;
00001E8C  4EB8 159A 3243          jsr       _FormatInstructionForTrace
                    3244   ; *(unsigned short int *)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e) ;
00001E90  2002      3245          move.l    D2,D0
00001E92  E588      3246          lsl.l     #2,D0
00001E94  2033 0800 3247          move.l    0(A3,D0.L),D0
00001E98  2040      3248          move.l    D0,A0
00001E9A  30BC 4E4E 3249          move.w    #20046,(A0)
                    3250   ; printf("\r\n%3d     $%08x",i, BreakPointAddress[i]) ;
00001E9E  2202      3251          move.l    D2,D1
00001EA0  E589      3252          lsl.l     #2,D1
00001EA2  2F33 1800 3253          move.l    0(A3,D1.L),-(A7)
00001EA6  2F02      3254          move.l    D2,-(A7)
00001EA8  4879 0000 3255          pea       @m68kde~2_69.L
00001EAC  6A0A      
00001EAE  4E92      3256          jsr       (A2)
00001EB0  DEFC 000C 3257          add.w     #12,A7
                    3258   ; printf("    %s", Instruction);
00001EB4  4879 0B00 3259          pea       _Instruction.L
00001EB8  04E2      
00001EBA  4879 0000 3260          pea       @m68kde~2_70.L
00001EBE  6A1A      
00001EC0  4E92      3261          jsr       (A2)
00001EC2  504F      3262          addq.w    #8,A7
                    3263   BreakPointDisplay_11:
00001EC4  5282      3264          addq.l    #1,D2
00001EC6  6000 FF7A 3265          bra       BreakPointDisplay_8
                    3266   BreakPointDisplay_10:
                    3267   ; }
                    3268   ; }
                    3269   ; printf("\r\n") ;
00001ECA  4879 0000 3270          pea       @m68kde~2_1.L
00001ECE  6354      
00001ED0  4E92      3271          jsr       (A2)
00001ED2  584F      3272          addq.w    #4,A7
00001ED4  4CDF 0C0C 3273          movem.l   (A7)+,D2/D3/A2/A3
00001ED8  4E75      3274          rts
                    3275   ; }
                    3276   ; void WatchPointDisplay(void)
                    3277   ; {
                    3278   _WatchPointDisplay:
00001EDA  48E7 3020 3279          movem.l   D2/D3/A2,-(A7)
00001EDE  45F9 0000 3280          lea       _printf.L,A2
00001EE2  5AA4      
                    3281   ; int i ;
                    3282   ; int WatchPointsSet = 0 ;
00001EE4  4283      3283          clr.l     D3
                    3284   ; // any watchpoints set
                    3285   ; for(i = 0; i < 8; i++)  {
00001EE6  4282      3286          clr.l     D2
                    3287   WatchPointDisplay_1:
00001EE8  0C82 0000 3288          cmp.l     #8,D2
00001EEC  0008      
00001EEE  6C1C      3289          bge.s     WatchPointDisplay_3
                    3290   ; if(WatchPointSetOrCleared[i] == 1)
00001EF0  2002      3291          move.l    D2,D0
00001EF2  E588      3292          lsl.l     #2,D0
00001EF4  41F9 0B00 3293          lea       _WatchPointSetOrCleared.L,A0
00001EF8  01A2      
00001EFA  2030 0800 3294          move.l    0(A0,D0.L),D0
00001EFE  0C80 0000 3295          cmp.l     #1,D0
00001F02  0001      
00001F04  6602      3296          bne.s     WatchPointDisplay_4
                    3297   ; WatchPointsSet = 1;
00001F06  7601      3298          moveq     #1,D3
                    3299   WatchPointDisplay_4:
00001F08  5282      3300          addq.l    #1,D2
00001F0A  60DC      3301          bra       WatchPointDisplay_1
                    3302   WatchPointDisplay_3:
                    3303   ; }
                    3304   ; if(WatchPointsSet == 1) {
00001F0C  0C83 0000 3305          cmp.l     #1,D3
00001F10  0001      
00001F12  6616      3306          bne.s     WatchPointDisplay_6
                    3307   ; printf("\r\nNum     Address") ;
00001F14  4879 0000 3308          pea       @m68kde~2_71.L
00001F18  6A22      
00001F1A  4E92      3309          jsr       (A2)
00001F1C  584F      3310          addq.w    #4,A7
                    3311   ; printf("\r\n---     ---------") ;
00001F1E  4879 0000 3312          pea       @m68kde~2_72.L
00001F22  6A34      
00001F24  4E92      3313          jsr       (A2)
00001F26  584F      3314          addq.w    #4,A7
00001F28  600A      3315          bra.s     WatchPointDisplay_7
                    3316   WatchPointDisplay_6:
                    3317   ; }
                    3318   ; else
                    3319   ; printf("\r\nNo WatchPoints Set") ;
00001F2A  4879 0000 3320          pea       @m68kde~2_73.L
00001F2E  6A48      
00001F30  4E92      3321          jsr       (A2)
00001F32  584F      3322          addq.w    #4,A7
                    3323   WatchPointDisplay_7:
                    3324   ; for(i = 0; i < 8; i++)  {
00001F34  4282      3325          clr.l     D2
                    3326   WatchPointDisplay_8:
00001F36  0C82 0000 3327          cmp.l     #8,D2
00001F3A  0008      
00001F3C  6C00 0038 3328          bge       WatchPointDisplay_10
                    3329   ; if(WatchPointSetOrCleared[i] == 1)
00001F40  2002      3330          move.l    D2,D0
00001F42  E588      3331          lsl.l     #2,D0
00001F44  41F9 0B00 3332          lea       _WatchPointSetOrCleared.L,A0
00001F48  01A2      
00001F4A  2030 0800 3333          move.l    0(A0,D0.L),D0
00001F4E  0C80 0000 3334          cmp.l     #1,D0
00001F52  0001      
00001F54  661C      3335          bne.s     WatchPointDisplay_11
                    3336   ; printf("\r\n%3d     $%08x",i, WatchPointAddress[i]) ;
00001F56  2202      3337          move.l    D2,D1
00001F58  E589      3338          lsl.l     #2,D1
00001F5A  41F9 0B00 3339          lea       _WatchPointAddress.L,A0
00001F5E  0182      
00001F60  2F30 1800 3340          move.l    0(A0,D1.L),-(A7)
00001F64  2F02      3341          move.l    D2,-(A7)
00001F66  4879 0000 3342          pea       @m68kde~2_69.L
00001F6A  6A0A      
00001F6C  4E92      3343          jsr       (A2)
00001F6E  DEFC 000C 3344          add.w     #12,A7
                    3345   WatchPointDisplay_11:
00001F72  5282      3346          addq.l    #1,D2
00001F74  60C0      3347          bra       WatchPointDisplay_8
                    3348   WatchPointDisplay_10:
                    3349   ; }
                    3350   ; printf("\r\n") ;
00001F76  4879 0000 3351          pea       @m68kde~2_1.L
00001F7A  6354      
00001F7C  4E92      3352          jsr       (A2)
00001F7E  584F      3353          addq.w    #4,A7
00001F80  4CDF 040C 3354          movem.l   (A7)+,D2/D3/A2
00001F84  4E75      3355          rts
                    3356   ; }
                    3357   ; void BreakPointClear(void)
                    3358   ; {
                    3359   _BreakPointClear:
00001F86  4E56 FFFC 3360          link      A6,#-4
00001F8A  48E7 2020 3361          movem.l   D2/A2,-(A7)
00001F8E  45F9 0000 3362          lea       _printf.L,A2
00001F92  5AA4      
                    3363   ; unsigned int i ;
                    3364   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3365   ; BreakPointDisplay() ;
00001F94  4EB8 1DE0 3366          jsr       _BreakPointDisplay
                    3367   ; printf("\r\nEnter Break Point Number: ") ;
00001F98  4879 0000 3368          pea       @m68kde~2_74.L
00001F9C  6A5E      
00001F9E  4E92      3369          jsr       (A2)
00001FA0  584F      3370          addq.w    #4,A7
                    3371   ; i = xtod(_getch()) ;           // get break pointer number
00001FA2  2F00      3372          move.l    D0,-(A7)
00001FA4  4EB8 0B68 3373          jsr       __getch
00001FA8  2200      3374          move.l    D0,D1
00001FAA  201F      3375          move.l    (A7)+,D0
00001FAC  2F01      3376          move.l    D1,-(A7)
00001FAE  4EB8 0BD2 3377          jsr       _xtod
00001FB2  584F      3378          addq.w    #4,A7
00001FB4  C0BC 0000 3379          and.l     #255,D0
00001FB8  00FF      
00001FBA  2400      3380          move.l    D0,D2
                    3381   ; if((i < 0) || (i > 7))   {
00001FBC  0C82 0000 3382          cmp.l     #0,D2
00001FC0  0000      
00001FC2  6508      3383          blo.s     BreakPointClear_3
00001FC4  0C82 0000 3384          cmp.l     #7,D2
00001FC8  0007      
00001FCA  630E      3385          bls.s     BreakPointClear_1
                    3386   BreakPointClear_3:
                    3387   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00001FCC  4879 0000 3388          pea       @m68kde~2_75.L
00001FD0  6A7C      
00001FD2  4E92      3389          jsr       (A2)
00001FD4  584F      3390          addq.w    #4,A7
                    3391   ; return ;
00001FD6  6000 0080 3392          bra       BreakPointClear_4
                    3393   BreakPointClear_1:
                    3394   ; }
                    3395   ; if(BreakPointSetOrCleared[i] == 1)  {       // if break point set
00001FDA  2002      3396          move.l    D2,D0
00001FDC  E588      3397          lsl.l     #2,D0
00001FDE  41F9 0B00 3398          lea       _BreakPointSetOrCleared.L,A0
00001FE2  015E      
00001FE4  2030 0800 3399          move.l    0(A0,D0.L),D0
00001FE8  0C80 0000 3400          cmp.l     #1,D0
00001FEC  0001      
00001FEE  6600 005A 3401          bne       BreakPointClear_5
                    3402   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program we are about to change
00001FF2  2002      3403          move.l    D2,D0
00001FF4  E588      3404          lsl.l     #2,D0
00001FF6  41F9 0B00 3405          lea       _BreakPointAddress.L,A0
00001FFA  012E      
00001FFC  2D70 0800 3406          move.l    0(A0,D0.L),-4(A6)
00002000  FFFC      
                    3407   ; BreakPointAddress[i] = 0 ;
00002002  2002      3408          move.l    D2,D0
00002004  E588      3409          lsl.l     #2,D0
00002006  41F9 0B00 3410          lea       _BreakPointAddress.L,A0
0000200A  012E      
0000200C  42B0 0800 3411          clr.l     0(A0,D0.L)
                    3412   ; BreakPointSetOrCleared[i] = 0 ;
00002010  2002      3413          move.l    D2,D0
00002012  E588      3414          lsl.l     #2,D0
00002014  41F9 0B00 3415          lea       _BreakPointSetOrCleared.L,A0
00002018  015E      
0000201A  42B0 0800 3416          clr.l     0(A0,D0.L)
                    3417   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
0000201E  2002      3418          move.l    D2,D0
00002020  E388      3419          lsl.l     #1,D0
00002022  41F9 0B00 3420          lea       _BreakPointInstruction.L,A0
00002026  014E      
00002028  226E FFFC 3421          move.l    -4(A6),A1
0000202C  32B0 0800 3422          move.w    0(A0,D0.L),(A1)
                    3423   ; BreakPointInstruction[i] = 0 ;
00002030  2002      3424          move.l    D2,D0
00002032  E388      3425          lsl.l     #1,D0
00002034  41F9 0B00 3426          lea       _BreakPointInstruction.L,A0
00002038  014E      
0000203A  4270 0800 3427          clr.w     0(A0,D0.L)
                    3428   ; printf("\r\nBreak Point Cleared.....\r\n") ;
0000203E  4879 0000 3429          pea       @m68kde~2_76.L
00002042  6A98      
00002044  4E92      3430          jsr       (A2)
00002046  584F      3431          addq.w    #4,A7
00002048  600A      3432          bra.s     BreakPointClear_6
                    3433   BreakPointClear_5:
                    3434   ; }
                    3435   ; else
                    3436   ; printf("\r\nBreak Point wasn't Set.....") ;
0000204A  4879 0000 3437          pea       @m68kde~2_77.L
0000204E  6AB6      
00002050  4E92      3438          jsr       (A2)
00002052  584F      3439          addq.w    #4,A7
                    3440   BreakPointClear_6:
                    3441   ; BreakPointDisplay() ;
00002054  4EB8 1DE0 3442          jsr       _BreakPointDisplay
                    3443   ; return ;
                    3444   BreakPointClear_4:
00002058  4CDF 0404 3445          movem.l   (A7)+,D2/A2
0000205C  4E5E      3446          unlk      A6
0000205E  4E75      3447          rts
                    3448   ; }
                    3449   ; void WatchPointClear(void)
                    3450   ; {
                    3451   _WatchPointClear:
00002060  48E7 2020 3452          movem.l   D2/A2,-(A7)
00002064  45F9 0000 3453          lea       _printf.L,A2
00002068  5AA4      
                    3454   ; unsigned int i ;
                    3455   ; WatchPointDisplay() ;
0000206A  4EB8 1EDA 3456          jsr       _WatchPointDisplay
                    3457   ; printf("\r\nEnter Watch Point Number: ") ;
0000206E  4879 0000 3458          pea       @m68kde~2_78.L
00002072  6AD4      
00002074  4E92      3459          jsr       (A2)
00002076  584F      3460          addq.w    #4,A7
                    3461   ; i = xtod(_getch()) ;           // get watch pointer number
00002078  2F00      3462          move.l    D0,-(A7)
0000207A  4EB8 0B68 3463          jsr       __getch
0000207E  2200      3464          move.l    D0,D1
00002080  201F      3465          move.l    (A7)+,D0
00002082  2F01      3466          move.l    D1,-(A7)
00002084  4EB8 0BD2 3467          jsr       _xtod
00002088  584F      3468          addq.w    #4,A7
0000208A  C0BC 0000 3469          and.l     #255,D0
0000208E  00FF      
00002090  2400      3470          move.l    D0,D2
                    3471   ; if((i < 0) || (i > 7))   {
00002092  0C82 0000 3472          cmp.l     #0,D2
00002096  0000      
00002098  6508      3473          blo.s     WatchPointClear_3
0000209A  0C82 0000 3474          cmp.l     #7,D2
0000209E  0007      
000020A0  630E      3475          bls.s     WatchPointClear_1
                    3476   WatchPointClear_3:
                    3477   ; printf("\r\nIllegal Range : Use 0 - 7") ;
000020A2  4879 0000 3478          pea       @m68kde~2_75.L
000020A6  6A7C      
000020A8  4E92      3479          jsr       (A2)
000020AA  584F      3480          addq.w    #4,A7
                    3481   ; return ;
000020AC  6000 004E 3482          bra       WatchPointClear_4
                    3483   WatchPointClear_1:
                    3484   ; }
                    3485   ; if(WatchPointSetOrCleared[i] == 1)  {       // if watch point set
000020B0  2002      3486          move.l    D2,D0
000020B2  E588      3487          lsl.l     #2,D0
000020B4  41F9 0B00 3488          lea       _WatchPointSetOrCleared.L,A0
000020B8  01A2      
000020BA  2030 0800 3489          move.l    0(A0,D0.L),D0
000020BE  0C80 0000 3490          cmp.l     #1,D0
000020C2  0001      
000020C4  6628      3491          bne.s     WatchPointClear_5
                    3492   ; WatchPointAddress[i] = 0 ;
000020C6  2002      3493          move.l    D2,D0
000020C8  E588      3494          lsl.l     #2,D0
000020CA  41F9 0B00 3495          lea       _WatchPointAddress.L,A0
000020CE  0182      
000020D0  42B0 0800 3496          clr.l     0(A0,D0.L)
                    3497   ; WatchPointSetOrCleared[i] = 0 ;
000020D4  2002      3498          move.l    D2,D0
000020D6  E588      3499          lsl.l     #2,D0
000020D8  41F9 0B00 3500          lea       _WatchPointSetOrCleared.L,A0
000020DC  01A2      
000020DE  42B0 0800 3501          clr.l     0(A0,D0.L)
                    3502   ; printf("\r\nWatch Point Cleared.....\r\n") ;
000020E2  4879 0000 3503          pea       @m68kde~2_79.L
000020E6  6AF2      
000020E8  4E92      3504          jsr       (A2)
000020EA  584F      3505          addq.w    #4,A7
000020EC  600A      3506          bra.s     WatchPointClear_6
                    3507   WatchPointClear_5:
                    3508   ; }
                    3509   ; else
                    3510   ; printf("\r\nWatch Point Was not Set.....") ;
000020EE  4879 0000 3511          pea       @m68kde~2_80.L
000020F2  6B10      
000020F4  4E92      3512          jsr       (A2)
000020F6  584F      3513          addq.w    #4,A7
                    3514   WatchPointClear_6:
                    3515   ; WatchPointDisplay() ;
000020F8  4EB8 1EDA 3516          jsr       _WatchPointDisplay
                    3517   ; return ;
                    3518   WatchPointClear_4:
000020FC  4CDF 0404 3519          movem.l   (A7)+,D2/A2
00002100  4E75      3520          rts
                    3521   ; }
                    3522   ; void DisableBreakPoints(void)
                    3523   ; {
                    3524   _DisableBreakPoints:
00002102  4E56 FFFC 3525          link      A6,#-4
00002106  2F02      3526          move.l    D2,-(A7)
                    3527   ; int i ;
                    3528   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3529   ; for(i = 0; i < 8; i++)  {
00002108  4282      3530          clr.l     D2
                    3531   DisableBreakPoints_1:
0000210A  0C82 0000 3532          cmp.l     #8,D2
0000210E  0008      
00002110  6C00 003E 3533          bge       DisableBreakPoints_3
                    3534   ; if(BreakPointSetOrCleared[i] == 1)    {                                                    // if break point set
00002114  2002      3535          move.l    D2,D0
00002116  E588      3536          lsl.l     #2,D0
00002118  41F9 0B00 3537          lea       _BreakPointSetOrCleared.L,A0
0000211C  015E      
0000211E  2030 0800 3538          move.l    0(A0,D0.L),D0
00002122  0C80 0000 3539          cmp.l     #1,D0
00002126  0001      
00002128  6622      3540          bne.s     DisableBreakPoints_4
                    3541   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
0000212A  2002      3542          move.l    D2,D0
0000212C  E588      3543          lsl.l     #2,D0
0000212E  41F9 0B00 3544          lea       _BreakPointAddress.L,A0
00002132  012E      
00002134  2D70 0800 3545          move.l    0(A0,D0.L),-4(A6)
00002138  FFFC      
                    3546   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
0000213A  2002      3547          move.l    D2,D0
0000213C  E388      3548          lsl.l     #1,D0
0000213E  41F9 0B00 3549          lea       _BreakPointInstruction.L,A0
00002142  014E      
00002144  226E FFFC 3550          move.l    -4(A6),A1
00002148  32B0 0800 3551          move.w    0(A0,D0.L),(A1)
                    3552   DisableBreakPoints_4:
0000214C  5282      3553          addq.l    #1,D2
0000214E  60BA      3554          bra       DisableBreakPoints_1
                    3555   DisableBreakPoints_3:
00002150  241F      3556          move.l    (A7)+,D2
00002152  4E5E      3557          unlk      A6
00002154  4E75      3558          rts
                    3559   ; }
                    3560   ; }
                    3561   ; }
                    3562   ; void EnableBreakPoints(void)
                    3563   ; {
                    3564   _EnableBreakPoints:
00002156  4E56 FFFC 3565          link      A6,#-4
0000215A  2F02      3566          move.l    D2,-(A7)
                    3567   ; int i ;
                    3568   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3569   ; for(i = 0; i < 8; i++)  {
0000215C  4282      3570          clr.l     D2
                    3571   EnableBreakPoints_1:
0000215E  0C82 0000 3572          cmp.l     #8,D2
00002162  0008      
00002164  6C32      3573          bge.s     EnableBreakPoints_3
                    3574   ; if(BreakPointSetOrCleared[i] == 1)    {                                                     // if break point set
00002166  2002      3575          move.l    D2,D0
00002168  E588      3576          lsl.l     #2,D0
0000216A  41F9 0B00 3577          lea       _BreakPointSetOrCleared.L,A0
0000216E  015E      
00002170  2030 0800 3578          move.l    0(A0,D0.L),D0
00002174  0C80 0000 3579          cmp.l     #1,D0
00002178  0001      
0000217A  6618      3580          bne.s     EnableBreakPoints_4
                    3581   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
0000217C  2002      3582          move.l    D2,D0
0000217E  E588      3583          lsl.l     #2,D0
00002180  41F9 0B00 3584          lea       _BreakPointAddress.L,A0
00002184  012E      
00002186  2D70 0800 3585          move.l    0(A0,D0.L),-4(A6)
0000218A  FFFC      
                    3586   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
0000218C  206E FFFC 3587          move.l    -4(A6),A0
00002190  30BC 4E4E 3588          move.w    #20046,(A0)
                    3589   EnableBreakPoints_4:
00002194  5282      3590          addq.l    #1,D2
00002196  60C6      3591          bra       EnableBreakPoints_1
                    3592   EnableBreakPoints_3:
00002198  241F      3593          move.l    (A7)+,D2
0000219A  4E5E      3594          unlk      A6
0000219C  4E75      3595          rts
                    3596   ; }
                    3597   ; }
                    3598   ; }
                    3599   ; void KillAllBreakPoints(void)
                    3600   ; {
                    3601   _KillAllBreakPoints:
0000219E  4E56 FFFC 3602          link      A6,#-4
000021A2  2F02      3603          move.l    D2,-(A7)
                    3604   ; int i ;
                    3605   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3606   ; for(i = 0; i < 8; i++)  {
000021A4  4282      3607          clr.l     D2
                    3608   KillAllBreakPoints_1:
000021A6  0C82 0000 3609          cmp.l     #8,D2
000021AA  0008      
000021AC  6C00 0052 3610          bge       KillAllBreakPoints_3
                    3611   ; // clear BP
                    3612   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
000021B0  2002      3613          move.l    D2,D0
000021B2  E588      3614          lsl.l     #2,D0
000021B4  41F9 0B00 3615          lea       _BreakPointAddress.L,A0
000021B8  012E      
000021BA  2D70 0800 3616          move.l    0(A0,D0.L),-4(A6)
000021BE  FFFC      
                    3617   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
000021C0  2002      3618          move.l    D2,D0
000021C2  E388      3619          lsl.l     #1,D0
000021C4  41F9 0B00 3620          lea       _BreakPointInstruction.L,A0
000021C8  014E      
000021CA  226E FFFC 3621          move.l    -4(A6),A1
000021CE  32B0 0800 3622          move.w    0(A0,D0.L),(A1)
                    3623   ; BreakPointAddress[i] = 0 ;                                                             // set BP address to NULL
000021D2  2002      3624          move.l    D2,D0
000021D4  E588      3625          lsl.l     #2,D0
000021D6  41F9 0B00 3626          lea       _BreakPointAddress.L,A0
000021DA  012E      
000021DC  42B0 0800 3627          clr.l     0(A0,D0.L)
                    3628   ; BreakPointInstruction[i] = 0 ;
000021E0  2002      3629          move.l    D2,D0
000021E2  E388      3630          lsl.l     #1,D0
000021E4  41F9 0B00 3631          lea       _BreakPointInstruction.L,A0
000021E8  014E      
000021EA  4270 0800 3632          clr.w     0(A0,D0.L)
                    3633   ; BreakPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
000021EE  2002      3634          move.l    D2,D0
000021F0  E588      3635          lsl.l     #2,D0
000021F2  41F9 0B00 3636          lea       _BreakPointSetOrCleared.L,A0
000021F6  015E      
000021F8  42B0 0800 3637          clr.l     0(A0,D0.L)
000021FC  5282      3638          addq.l    #1,D2
000021FE  60A6      3639          bra       KillAllBreakPoints_1
                    3640   KillAllBreakPoints_3:
00002200  241F      3641          move.l    (A7)+,D2
00002202  4E5E      3642          unlk      A6
00002204  4E75      3643          rts
                    3644   ; }
                    3645   ; //BreakPointDisplay() ;       // display the break points
                    3646   ; }
                    3647   ; void KillAllWatchPoints(void)
                    3648   ; {
                    3649   _KillAllWatchPoints:
00002206  2F02      3650          move.l    D2,-(A7)
                    3651   ; int i ;
                    3652   ; for(i = 0; i < 8; i++)  {
00002208  4282      3653          clr.l     D2
                    3654   KillAllWatchPoints_1:
0000220A  0C82 0000 3655          cmp.l     #8,D2
0000220E  0008      
00002210  6C20      3656          bge.s     KillAllWatchPoints_3
                    3657   ; WatchPointAddress[i] = 0 ;                                                             // set BP address to NULL
00002212  2002      3658          move.l    D2,D0
00002214  E588      3659          lsl.l     #2,D0
00002216  41F9 0B00 3660          lea       _WatchPointAddress.L,A0
0000221A  0182      
0000221C  42B0 0800 3661          clr.l     0(A0,D0.L)
                    3662   ; WatchPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00002220  2002      3663          move.l    D2,D0
00002222  E588      3664          lsl.l     #2,D0
00002224  41F9 0B00 3665          lea       _WatchPointSetOrCleared.L,A0
00002228  01A2      
0000222A  42B0 0800 3666          clr.l     0(A0,D0.L)
0000222E  5282      3667          addq.l    #1,D2
00002230  60D8      3668          bra       KillAllWatchPoints_1
                    3669   KillAllWatchPoints_3:
00002232  241F      3670          move.l    (A7)+,D2
00002234  4E75      3671          rts
                    3672   ; }
                    3673   ; //WatchPointDisplay() ;       // display the break points
                    3674   ; }
                    3675   ; void SetBreakPoint(void)
                    3676   ; {
                    3677   _SetBreakPoint:
00002236  4E56 FFFC 3678          link      A6,#-4
0000223A  48E7 3830 3679          movem.l   D2/D3/D4/A2/A3,-(A7)
0000223E  45F9 0000 3680          lea       _printf.L,A2
00002242  5AA4      
00002244  47F9 0B00 3681          lea       _BreakPointSetOrCleared.L,A3
00002248  015E      
                    3682   ; int i ;
                    3683   ; int BPNumber;
                    3684   ; int BPAddress;
                    3685   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3686   ; // see if any free break points
                    3687   ; for(i = 0; i < 8; i ++) {
0000224A  4282      3688          clr.l     D2
                    3689   SetBreakPoint_1:
0000224C  0C82 0000 3690          cmp.l     #8,D2
00002250  0008      
00002252  6C10      3691          bge.s     SetBreakPoint_3
                    3692   ; if( BreakPointSetOrCleared[i] == 0)
00002254  2002      3693          move.l    D2,D0
00002256  E588      3694          lsl.l     #2,D0
00002258  2033 0800 3695          move.l    0(A3,D0.L),D0
0000225C  6602      3696          bne.s     SetBreakPoint_4
                    3697   ; break ;         // if spare BP found allow user to set it
0000225E  6004      3698          bra.s     SetBreakPoint_3
                    3699   SetBreakPoint_4:
00002260  5282      3700          addq.l    #1,D2
00002262  60E8      3701          bra       SetBreakPoint_1
                    3702   SetBreakPoint_3:
                    3703   ; }
                    3704   ; if(i == 8) {
00002264  0C82 0000 3705          cmp.l     #8,D2
00002268  0008      
0000226A  660E      3706          bne.s     SetBreakPoint_6
                    3707   ; printf("\r\nNo FREE Break Points.....") ;
0000226C  4879 0000 3708          pea       @m68kde~2_81.L
00002270  6B30      
00002272  4E92      3709          jsr       (A2)
00002274  584F      3710          addq.w    #4,A7
                    3711   ; return ;
00002276  6000 00EC 3712          bra       SetBreakPoint_15
                    3713   SetBreakPoint_6:
                    3714   ; }
                    3715   ; printf("\r\nBreak Point Address: ") ;
0000227A  4879 0000 3716          pea       @m68kde~2_82.L
0000227E  6B4C      
00002280  4E92      3717          jsr       (A2)
00002282  584F      3718          addq.w    #4,A7
                    3719   ; BPAddress = Get8HexDigits(0) ;
00002284  42A7      3720          clr.l     -(A7)
00002286  4EB8 0CA4 3721          jsr       _Get8HexDigits
0000228A  584F      3722          addq.w    #4,A7
0000228C  2600      3723          move.l    D0,D3
                    3724   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BPAddress) ;     // point to the instruction in the user program we are about to change
0000228E  2803      3725          move.l    D3,D4
                    3726   ; if((BPAddress & 0x00000001) == 0x00000001)  {   // cannot set BP at an odd address
00002290  2003      3727          move.l    D3,D0
00002292  C0BC 0000 3728          and.l     #1,D0
00002296  0001      
00002298  0C80 0000 3729          cmp.l     #1,D0
0000229C  0001      
0000229E  660E      3730          bne.s     SetBreakPoint_9
                    3731   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses") ;
000022A0  4879 0000 3732          pea       @m68kde~2_83.L
000022A4  6B64      
000022A6  4E92      3733          jsr       (A2)
000022A8  584F      3734          addq.w    #4,A7
                    3735   ; return ;
000022AA  6000 00B8 3736          bra       SetBreakPoint_15
                    3737   SetBreakPoint_9:
                    3738   ; }
                    3739   ; if(BPAddress < 0x00008000)  {   // cannot set BP in ROM
000022AE  0C83 0000 3740          cmp.l     #32768,D3
000022B2  8000      
000022B4  640E      3741          bhs.s     SetBreakPoint_11
                    3742   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]") ;
000022B6  4879 0000 3743          pea       @m68kde~2_84.L
000022BA  6B9A      
000022BC  4E92      3744          jsr       (A2)
000022BE  584F      3745          addq.w    #4,A7
                    3746   ; return ;
000022C0  6000 00A2 3747          bra       SetBreakPoint_15
                    3748   SetBreakPoint_11:
                    3749   ; }
                    3750   ; // search for first free bp or existing same BP
                    3751   ; for(i = 0; i < 8; i++)  {
000022C4  4282      3752          clr.l     D2
                    3753   SetBreakPoint_13:
000022C6  0C82 0000 3754          cmp.l     #8,D2
000022CA  0008      
000022CC  6C00 0096 3755          bge       SetBreakPoint_15
                    3756   ; if(BreakPointAddress[i] == BPAddress)   {
000022D0  2002      3757          move.l    D2,D0
000022D2  E588      3758          lsl.l     #2,D0
000022D4  41F9 0B00 3759          lea       _BreakPointAddress.L,A0
000022D8  012E      
000022DA  B6B0 0800 3760          cmp.l     0(A0,D0.L),D3
000022DE  6610      3761          bne.s     SetBreakPoint_16
                    3762   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress) ;
000022E0  2F03      3763          move.l    D3,-(A7)
000022E2  4879 0000 3764          pea       @m68kde~2_85.L
000022E6  6BE2      
000022E8  4E92      3765          jsr       (A2)
000022EA  504F      3766          addq.w    #8,A7
                    3767   ; return ;
000022EC  6000 0076 3768          bra       SetBreakPoint_15
                    3769   SetBreakPoint_16:
                    3770   ; }
                    3771   ; if(BreakPointSetOrCleared[i] == 0) {
000022F0  2002      3772          move.l    D2,D0
000022F2  E588      3773          lsl.l     #2,D0
000022F4  2033 0800 3774          move.l    0(A3,D0.L),D0
000022F8  6600 0064 3775          bne       SetBreakPoint_18
                    3776   ; // set BP here
                    3777   ; BreakPointSetOrCleared[i] = 1 ;                                 // mark this breakpoint as set
000022FC  2002      3778          move.l    D2,D0
000022FE  E588      3779          lsl.l     #2,D0
00002300  27BC 0000 3780          move.l    #1,0(A3,D0.L)
00002304  0001 0800 
                    3781   ; BreakPointInstruction[i] = *ProgramBreakPointAddress ;          // copy the user program instruction here so we can put it back afterwards
00002308  2044      3782          move.l    D4,A0
0000230A  2002      3783          move.l    D2,D0
0000230C  E388      3784          lsl.l     #1,D0
0000230E  43F9 0B00 3785          lea       _BreakPointInstruction.L,A1
00002312  014E      
00002314  3390 0800 3786          move.w    (A0),0(A1,D0.L)
                    3787   ; DisassembleInstruction(ProgramBreakPointAddress) ;
00002318  2F04      3788          move.l    D4,-(A7)
0000231A  4EB9 0000 3789          jsr       _DisassembleInstruction
0000231E  3966      
00002320  584F      3790          addq.w    #4,A7
                    3791   ; FormatInstructionForTrace() ;
00002322  4EB8 159A 3792          jsr       _FormatInstructionForTrace
                    3793   ; printf("\r\nBreak Point Set at Address: [$%08x], Instruction = %s", ProgramBreakPointAddress, Instruction) ;
00002326  4879 0B00 3794          pea       _Instruction.L
0000232A  04E2      
0000232C  2F04      3795          move.l    D4,-(A7)
0000232E  4879 0000 3796          pea       @m68kde~2_86.L
00002332  6C1A      
00002334  4E92      3797          jsr       (A2)
00002336  DEFC 000C 3798          add.w     #12,A7
                    3799   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e)    ;   // put a Trap14 instruction at the user specified address
0000233A  2044      3800          move.l    D4,A0
0000233C  30BC 4E4E 3801          move.w    #20046,(A0)
                    3802   ; BreakPointAddress[i] = BPAddress ;                              // record the address of this break point in the debugger
00002340  2002      3803          move.l    D2,D0
00002342  E588      3804          lsl.l     #2,D0
00002344  41F9 0B00 3805          lea       _BreakPointAddress.L,A0
00002348  012E      
0000234A  2183 0800 3806          move.l    D3,0(A0,D0.L)
                    3807   ; printf("\r\n") ;
0000234E  4879 0000 3808          pea       @m68kde~2_1.L
00002352  6354      
00002354  4E92      3809          jsr       (A2)
00002356  584F      3810          addq.w    #4,A7
                    3811   ; BreakPointDisplay() ;       // display the break points
00002358  4EB8 1DE0 3812          jsr       _BreakPointDisplay
                    3813   ; return ;
0000235C  6006      3814          bra.s     SetBreakPoint_15
                    3815   SetBreakPoint_18:
0000235E  5282      3816          addq.l    #1,D2
00002360  6000 FF64 3817          bra       SetBreakPoint_13
                    3818   SetBreakPoint_15:
00002364  4CDF 0C1C 3819          movem.l   (A7)+,D2/D3/D4/A2/A3
00002368  4E5E      3820          unlk      A6
0000236A  4E75      3821          rts
                    3822   ; }
                    3823   ; }
                    3824   ; }
                    3825   ; void SetWatchPoint(void)
                    3826   ; {
                    3827   _SetWatchPoint:
0000236C  4E56 FFF8 3828          link      A6,#-8
00002370  48E7 3030 3829          movem.l   D2/D3/A2/A3,-(A7)
00002374  45F9 0000 3830          lea       _printf.L,A2
00002378  5AA4      
0000237A  47F9 0B00 3831          lea       _WatchPointSetOrCleared.L,A3
0000237E  01A2      
                    3832   ; int i ;
                    3833   ; int WPNumber;
                    3834   ; int WPAddress;
                    3835   ; volatile unsigned short int *ProgramWatchPointAddress ;
                    3836   ; // see if any free break points
                    3837   ; for(i = 0; i < 8; i ++) {
00002380  4282      3838          clr.l     D2
                    3839   SetWatchPoint_1:
00002382  0C82 0000 3840          cmp.l     #8,D2
00002386  0008      
00002388  6C10      3841          bge.s     SetWatchPoint_3
                    3842   ; if( WatchPointSetOrCleared[i] == 0)
0000238A  2002      3843          move.l    D2,D0
0000238C  E588      3844          lsl.l     #2,D0
0000238E  2033 0800 3845          move.l    0(A3,D0.L),D0
00002392  6602      3846          bne.s     SetWatchPoint_4
                    3847   ; break ;         // if spare WP found allow user to set it
00002394  6004      3848          bra.s     SetWatchPoint_3
                    3849   SetWatchPoint_4:
00002396  5282      3850          addq.l    #1,D2
00002398  60E8      3851          bra       SetWatchPoint_1
                    3852   SetWatchPoint_3:
                    3853   ; }
                    3854   ; if(i == 8) {
0000239A  0C82 0000 3855          cmp.l     #8,D2
0000239E  0008      
000023A0  660E      3856          bne.s     SetWatchPoint_6
                    3857   ; printf("\r\nNo FREE Watch Points.....") ;
000023A2  4879 0000 3858          pea       @m68kde~2_87.L
000023A6  6C52      
000023A8  4E92      3859          jsr       (A2)
000023AA  584F      3860          addq.w    #4,A7
                    3861   ; return ;
000023AC  6000 008C 3862          bra       SetWatchPoint_11
                    3863   SetWatchPoint_6:
                    3864   ; }
                    3865   ; printf("\r\nWatch Point Address: ") ;
000023B0  4879 0000 3866          pea       @m68kde~2_88.L
000023B4  6C6E      
000023B6  4E92      3867          jsr       (A2)
000023B8  584F      3868          addq.w    #4,A7
                    3869   ; WPAddress = Get8HexDigits(0) ;
000023BA  42A7      3870          clr.l     -(A7)
000023BC  4EB8 0CA4 3871          jsr       _Get8HexDigits
000023C0  584F      3872          addq.w    #4,A7
000023C2  2600      3873          move.l    D0,D3
                    3874   ; // search for first free wp or existing same wp
                    3875   ; for(i = 0; i < 8; i++)  {
000023C4  4282      3876          clr.l     D2
                    3877   SetWatchPoint_9:
000023C6  0C82 0000 3878          cmp.l     #8,D2
000023CA  0008      
000023CC  6C00 006C 3879          bge       SetWatchPoint_11
                    3880   ; if(WatchPointAddress[i] == WPAddress && WPAddress != 0)   {     //so we can set a wp at 0
000023D0  2002      3881          move.l    D2,D0
000023D2  E588      3882          lsl.l     #2,D0
000023D4  41F9 0B00 3883          lea       _WatchPointAddress.L,A0
000023D8  0182      
000023DA  B6B0 0800 3884          cmp.l     0(A0,D0.L),D3
000023DE  6614      3885          bne.s     SetWatchPoint_12
000023E0  4A83      3886          tst.l     D3
000023E2  6710      3887          beq.s     SetWatchPoint_12
                    3888   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress) ;
000023E4  2F03      3889          move.l    D3,-(A7)
000023E6  4879 0000 3890          pea       @m68kde~2_89.L
000023EA  6C86      
000023EC  4E92      3891          jsr       (A2)
000023EE  504F      3892          addq.w    #8,A7
                    3893   ; return ;
000023F0  6000 0048 3894          bra       SetWatchPoint_11
                    3895   SetWatchPoint_12:
                    3896   ; }
                    3897   ; if(WatchPointSetOrCleared[i] == 0) {
000023F4  2002      3898          move.l    D2,D0
000023F6  E588      3899          lsl.l     #2,D0
000023F8  2033 0800 3900          move.l    0(A3,D0.L),D0
000023FC  6600 0038 3901          bne       SetWatchPoint_14
                    3902   ; WatchPointSetOrCleared[i] = 1 ;                                 // mark this watchpoint as set
00002400  2002      3903          move.l    D2,D0
00002402  E588      3904          lsl.l     #2,D0
00002404  27BC 0000 3905          move.l    #1,0(A3,D0.L)
00002408  0001 0800 
                    3906   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress) ;
0000240C  2F03      3907          move.l    D3,-(A7)
0000240E  4879 0000 3908          pea       @m68kde~2_90.L
00002412  6CBC      
00002414  4E92      3909          jsr       (A2)
00002416  504F      3910          addq.w    #8,A7
                    3911   ; WatchPointAddress[i] = WPAddress ;                              // record the address of this watch point in the debugger
00002418  2002      3912          move.l    D2,D0
0000241A  E588      3913          lsl.l     #2,D0
0000241C  41F9 0B00 3914          lea       _WatchPointAddress.L,A0
00002420  0182      
00002422  2183 0800 3915          move.l    D3,0(A0,D0.L)
                    3916   ; printf("\r\n") ;
00002426  4879 0000 3917          pea       @m68kde~2_1.L
0000242A  6354      
0000242C  4E92      3918          jsr       (A2)
0000242E  584F      3919          addq.w    #4,A7
                    3920   ; WatchPointDisplay() ;       // display the break points
00002430  4EB8 1EDA 3921          jsr       _WatchPointDisplay
                    3922   ; return ;
00002434  6004      3923          bra.s     SetWatchPoint_11
                    3924   SetWatchPoint_14:
00002436  5282      3925          addq.l    #1,D2
00002438  608C      3926          bra       SetWatchPoint_9
                    3927   SetWatchPoint_11:
0000243A  4CDF 0C0C 3928          movem.l   (A7)+,D2/D3/A2/A3
0000243E  4E5E      3929          unlk      A6
00002440  4E75      3930          rts
                    3931   ; }
                    3932   ; }
                    3933   ; }
                    3934   ; void HandleBreakPoint(void)
                    3935   ; {
                    3936   _HandleBreakPoint:
00002442  4E56 FFFC 3937          link      A6,#-4
00002446  48E7 0038 3938          movem.l   A2/A3/A4,-(A7)
0000244A  45F9 0B00 3939          lea       _i.L,A2
0000244E  00C4      
00002450  47F9 0000 3940          lea       _printf.L,A3
00002454  5AA4      
00002456  49F9 0B00 3941          lea       _PC.L,A4
0000245A  0120      
                    3942   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    3943   ; // now we have to put the break point back to run the instruction
                    3944   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    3945   ; PC = PC - 2 ;  // ready for user to resume after reaching breakpoint
0000245C  5594      3946          subq.l    #2,(A4)
                    3947   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT") ;
0000245E  4879 0000 3948          pea       @m68kde~2_91.L
00002462  6CE2      
00002464  4E93      3949          jsr       (A3)
00002466  584F      3950          addq.w    #4,A7
                    3951   ; printf("\r\nSingle Step : [ON]") ;
00002468  4879 0000 3952          pea       @m68kde~2_92.L
0000246C  6CF6      
0000246E  4E93      3953          jsr       (A3)
00002470  584F      3954          addq.w    #4,A7
                    3955   ; printf("\r\nBreakPoints : [Enabled]") ;
00002472  4879 0000 3956          pea       @m68kde~2_93.L
00002476  6D0C      
00002478  4E93      3957          jsr       (A3)
0000247A  584F      3958          addq.w    #4,A7
                    3959   ; // now clear the break point (put original instruction back)
                    3960   ; ProgramBreakPointAddress = PC ;
0000247C  2D54 FFFC 3961          move.l    (A4),-4(A6)
                    3962   ; for(i = 0; i < 8; i ++) {
00002480  4292      3963          clr.l     (A2)
                    3964   HandleBreakPoint_1:
00002482  2012      3965          move.l    (A2),D0
00002484  0C80 0000 3966          cmp.l     #8,D0
00002488  0008      
0000248A  6400 0056 3967          bhs       HandleBreakPoint_3
                    3968   ; if(BreakPointAddress[i] == PC) {        // if we have found the breakpoint
0000248E  2012      3969          move.l    (A2),D0
00002490  E588      3970          lsl.l     #2,D0
00002492  41F9 0B00 3971          lea       _BreakPointAddress.L,A0
00002496  012E      
00002498  2230 0800 3972          move.l    0(A0,D0.L),D1
0000249C  B294      3973          cmp.l     (A4),D1
0000249E  6600 003E 3974          bne       HandleBreakPoint_4
                    3975   ; BreakPointAddress[i] = 0 ;
000024A2  2012      3976          move.l    (A2),D0
000024A4  E588      3977          lsl.l     #2,D0
000024A6  41F9 0B00 3978          lea       _BreakPointAddress.L,A0
000024AA  012E      
000024AC  42B0 0800 3979          clr.l     0(A0,D0.L)
                    3980   ; BreakPointSetOrCleared[i] = 0 ;
000024B0  2012      3981          move.l    (A2),D0
000024B2  E588      3982          lsl.l     #2,D0
000024B4  41F9 0B00 3983          lea       _BreakPointSetOrCleared.L,A0
000024B8  015E      
000024BA  42B0 0800 3984          clr.l     0(A0,D0.L)
                    3985   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
000024BE  2012      3986          move.l    (A2),D0
000024C0  E388      3987          lsl.l     #1,D0
000024C2  41F9 0B00 3988          lea       _BreakPointInstruction.L,A0
000024C6  014E      
000024C8  226E FFFC 3989          move.l    -4(A6),A1
000024CC  32B0 0800 3990          move.w    0(A0,D0.L),(A1)
                    3991   ; BreakPointInstruction[i] = 0 ;
000024D0  2012      3992          move.l    (A2),D0
000024D2  E388      3993          lsl.l     #1,D0
000024D4  41F9 0B00 3994          lea       _BreakPointInstruction.L,A0
000024D8  014E      
000024DA  4270 0800 3995          clr.w     0(A0,D0.L)
                    3996   HandleBreakPoint_4:
000024DE  5292      3997          addq.l    #1,(A2)
000024E0  60A0      3998          bra       HandleBreakPoint_1
                    3999   HandleBreakPoint_3:
                    4000   ; }
                    4001   ; }
                    4002   ; DumpRegisters() ;
000024E2  4EB8 160E 4003          jsr       _DumpRegisters
                    4004   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
000024E6  4879 0000 4005          pea       @m68kde~2_54.L
000024EA  686E      
000024EC  4E93      4006          jsr       (A3)
000024EE  584F      4007          addq.w    #4,A7
                    4008   ; printf("\r\nPress <ESC> to Resume User Program\r\n") ;
000024F0  4879 0000 4009          pea       @m68kde~2_94.L
000024F4  6D26      
000024F6  4E93      4010          jsr       (A3)
000024F8  584F      4011          addq.w    #4,A7
                    4012   ; menu() ;
000024FA  4EB9 0000 4013          jsr       _menu
000024FE  2750      
00002500  4CDF 1C00 4014          movem.l   (A7)+,A2/A3/A4
00002504  4E5E      4015          unlk      A6
00002506  4E75      4016          rts
                    4017   ; }
                    4018   ; void UnknownCommand()
                    4019   ; {
                    4020   _UnknownCommand:
                    4021   ; printf("\r\nUnknown Command.....\r\n") ;
00002508  4879 0000 4022          pea       @m68kde~2_95.L
0000250C  6D4E      
0000250E  4EB9 0000 4023          jsr       _printf
00002512  5AA4      
00002514  584F      4024          addq.w    #4,A7
                    4025   ; Help() ;
00002516  4EB9 0000 4026          jsr       _Help
0000251A  266C      
0000251C  4E75      4027          rts
                    4028   ; }
                    4029   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    4030   ; void CallDebugMonitor(void)
                    4031   ; {
                    4032   _CallDebugMonitor:
                    4033   ; printf("\r\nProgram Ended (TRAP #15)....") ;
0000251E  4879 0000 4034          pea       @m68kde~2_96.L
00002522  6D68      
00002524  4EB9 0000 4035          jsr       _printf
00002528  5AA4      
0000252A  584F      4036          addq.w    #4,A7
                    4037   ; menu();
0000252C  4EB9 0000 4038          jsr       _menu
00002530  2750      
00002532  4E75      4039          rts
                    4040   ; }
                    4041   ; void Breakpoint(void)
                    4042   ; {
                    4043   _Breakpoint:
00002534  2F02      4044          move.l    D2,-(A7)
                    4045   ; char c;
                    4046   ; c = toupper(_getch());
00002536  2F00      4047          move.l    D0,-(A7)
00002538  4EB8 0B68 4048          jsr       __getch
0000253C  2200      4049          move.l    D0,D1
0000253E  201F      4050          move.l    (A7)+,D0
00002540  2F01      4051          move.l    D1,-(A7)
00002542  4EB9 0000 4052          jsr       _toupper
00002546  5A78      
00002548  584F      4053          addq.w    #4,A7
0000254A  1400      4054          move.b    D0,D2
                    4055   ; if( c == (char)('D'))                                      // BreakPoint Display
0000254C  0C02 0044 4056          cmp.b     #68,D2
00002550  6608      4057          bne.s     Breakpoint_1
                    4058   ; BreakPointDisplay() ;
00002552  4EB8 1DE0 4059          jsr       _BreakPointDisplay
00002556  6000 0054 4060          bra       Breakpoint_10
                    4061   Breakpoint_1:
                    4062   ; else if(c == (char)('K')) {                                 // breakpoint Kill
0000255A  0C02 004B 4063          cmp.b     #75,D2
0000255E  6630      4064          bne.s     Breakpoint_3
                    4065   ; printf("\r\nKill All Break Points...(y/n)?") ;
00002560  4879 0000 4066          pea       @m68kde~2_97.L
00002564  6D88      
00002566  4EB9 0000 4067          jsr       _printf
0000256A  5AA4      
0000256C  584F      4068          addq.w    #4,A7
                    4069   ; c = toupper(_getch());
0000256E  2F00      4070          move.l    D0,-(A7)
00002570  4EB8 0B68 4071          jsr       __getch
00002574  2200      4072          move.l    D0,D1
00002576  201F      4073          move.l    (A7)+,D0
00002578  2F01      4074          move.l    D1,-(A7)
0000257A  4EB9 0000 4075          jsr       _toupper
0000257E  5A78      
00002580  584F      4076          addq.w    #4,A7
00002582  1400      4077          move.b    D0,D2
                    4078   ; if(c == (char)('Y'))
00002584  0C02 0059 4079          cmp.b     #89,D2
00002588  6604      4080          bne.s     Breakpoint_5
                    4081   ; KillAllBreakPoints() ;
0000258A  4EB8 219E 4082          jsr       _KillAllBreakPoints
                    4083   Breakpoint_5:
0000258E  601C      4084          bra.s     Breakpoint_10
                    4085   Breakpoint_3:
                    4086   ; }
                    4087   ; else if(c == (char)('S')) {
00002590  0C02 0053 4088          cmp.b     #83,D2
00002594  6606      4089          bne.s     Breakpoint_7
                    4090   ; SetBreakPoint() ;
00002596  4EB8 2236 4091          jsr       _SetBreakPoint
0000259A  6010      4092          bra.s     Breakpoint_10
                    4093   Breakpoint_7:
                    4094   ; }
                    4095   ; else if(c == (char)('C')) {
0000259C  0C02 0043 4096          cmp.b     #67,D2
000025A0  6606      4097          bne.s     Breakpoint_9
                    4098   ; BreakPointClear() ;
000025A2  4EB8 1F86 4099          jsr       _BreakPointClear
000025A6  6004      4100          bra.s     Breakpoint_10
                    4101   Breakpoint_9:
                    4102   ; }
                    4103   ; else
                    4104   ; UnknownCommand() ;
000025A8  4EB8 2508 4105          jsr       _UnknownCommand
                    4106   Breakpoint_10:
000025AC  241F      4107          move.l    (A7)+,D2
000025AE  4E75      4108          rts
                    4109   ; }
                    4110   ; void Watchpoint(void)
                    4111   ; {
                    4112   _Watchpoint:
000025B0  2F02      4113          move.l    D2,-(A7)
                    4114   ; char c;
                    4115   ; c = toupper(_getch());
000025B2  2F00      4116          move.l    D0,-(A7)
000025B4  4EB8 0B68 4117          jsr       __getch
000025B8  2200      4118          move.l    D0,D1
000025BA  201F      4119          move.l    (A7)+,D0
000025BC  2F01      4120          move.l    D1,-(A7)
000025BE  4EB9 0000 4121          jsr       _toupper
000025C2  5A78      
000025C4  584F      4122          addq.w    #4,A7
000025C6  1400      4123          move.b    D0,D2
                    4124   ; if( c == (char)('D'))                                      // WatchPoint Display
000025C8  0C02 0044 4125          cmp.b     #68,D2
000025CC  6608      4126          bne.s     Watchpoint_1
                    4127   ; WatchPointDisplay() ;
000025CE  4EB8 1EDA 4128          jsr       _WatchPointDisplay
000025D2  6000 0054 4129          bra       Watchpoint_10
                    4130   Watchpoint_1:
                    4131   ; else if(c == (char)('K')) {                                 // wtahcpoint Kill
000025D6  0C02 004B 4132          cmp.b     #75,D2
000025DA  6630      4133          bne.s     Watchpoint_3
                    4134   ; printf("\r\nKill All Watch Points...(y/n)?") ;
000025DC  4879 0000 4135          pea       @m68kde~2_98.L
000025E0  6DAA      
000025E2  4EB9 0000 4136          jsr       _printf
000025E6  5AA4      
000025E8  584F      4137          addq.w    #4,A7
                    4138   ; c = toupper(_getch());
000025EA  2F00      4139          move.l    D0,-(A7)
000025EC  4EB8 0B68 4140          jsr       __getch
000025F0  2200      4141          move.l    D0,D1
000025F2  201F      4142          move.l    (A7)+,D0
000025F4  2F01      4143          move.l    D1,-(A7)
000025F6  4EB9 0000 4144          jsr       _toupper
000025FA  5A78      
000025FC  584F      4145          addq.w    #4,A7
000025FE  1400      4146          move.b    D0,D2
                    4147   ; if(c == (char)('Y'))
00002600  0C02 0059 4148          cmp.b     #89,D2
00002604  6604      4149          bne.s     Watchpoint_5
                    4150   ; KillAllWatchPoints() ;
00002606  4EB8 2206 4151          jsr       _KillAllWatchPoints
                    4152   Watchpoint_5:
0000260A  601C      4153          bra.s     Watchpoint_10
                    4154   Watchpoint_3:
                    4155   ; }
                    4156   ; else if(c == (char)('S')) {
0000260C  0C02 0053 4157          cmp.b     #83,D2
00002610  6606      4158          bne.s     Watchpoint_7
                    4159   ; SetWatchPoint() ;
00002612  4EB8 236C 4160          jsr       _SetWatchPoint
00002616  6010      4161          bra.s     Watchpoint_10
                    4162   Watchpoint_7:
                    4163   ; }
                    4164   ; else if(c == (char)('C')) {
00002618  0C02 0043 4165          cmp.b     #67,D2
0000261C  6606      4166          bne.s     Watchpoint_9
                    4167   ; WatchPointClear() ;
0000261E  4EB8 2060 4168          jsr       _WatchPointClear
00002622  6004      4169          bra.s     Watchpoint_10
                    4170   Watchpoint_9:
                    4171   ; }
                    4172   ; else
                    4173   ; UnknownCommand() ;
00002624  4EB8 2508 4174          jsr       _UnknownCommand
                    4175   Watchpoint_10:
00002628  241F      4176          move.l    (A7)+,D2
0000262A  4E75      4177          rts
                    4178   ; }
                    4179   ; void DMenu(void)
                    4180   ; {
                    4181   _DMenu:
0000262C  2F02      4182          move.l    D2,-(A7)
                    4183   ; char c;
                    4184   ; c = toupper(_getch());
0000262E  2F00      4185          move.l    D0,-(A7)
00002630  4EB8 0B68 4186          jsr       __getch
00002634  2200      4187          move.l    D0,D1
00002636  201F      4188          move.l    (A7)+,D0
00002638  2F01      4189          move.l    D1,-(A7)
0000263A  4EB9 0000 4190          jsr       _toupper
0000263E  5A78      
00002640  584F      4191          addq.w    #4,A7
00002642  1400      4192          move.b    D0,D2
                    4193   ; if( c == (char)('U'))                                     // Dump Memory
00002644  0C02 0055 4194          cmp.b     #85,D2
00002648  6606      4195          bne.s     DMenu_1
                    4196   ; DumpMemory() ;
0000264A  4EB8 0EE0 4197          jsr       _DumpMemory
0000264E  6018      4198          bra.s     DMenu_4
                    4199   DMenu_1:
                    4200   ; else if(c == (char)('I'))   {
00002650  0C02 0049 4201          cmp.b     #73,D2
00002654  660E      4202          bne.s     DMenu_3
                    4203   ; DisableBreakPoints() ;
00002656  4EB8 2102 4204          jsr       _DisableBreakPoints
                    4205   ; DisassembleProgram() ;
0000265A  4EB8 0D00 4206          jsr       _DisassembleProgram
                    4207   ; EnableBreakPoints() ;
0000265E  4EB8 2156 4208          jsr       _EnableBreakPoints
00002662  6004      4209          bra.s     DMenu_4
                    4210   DMenu_3:
                    4211   ; }
                    4212   ; else
                    4213   ; UnknownCommand() ;
00002664  4EB8 2508 4214          jsr       _UnknownCommand
                    4215   DMenu_4:
00002668  241F      4216          move.l    (A7)+,D2
0000266A  4E75      4217          rts
                    4218   ; }
                    4219   ; void Help(void)
                    4220   ; {
                    4221   _Help:
0000266C  48E7 2020 4222          movem.l   D2/A2,-(A7)
00002670  45F9 0000 4223          lea       _printf.L,A2
00002674  5AA4      
                    4224   ; char *banner = "\r\n----------------------------------------------------------------" ;
00002676  41F9 0000 4225          lea       @m68kde~2_99.L,A0
0000267A  6DCC      
0000267C  2408      4226          move.l    A0,D2
                    4227   ; printf(banner) ;
0000267E  2F02      4228          move.l    D2,-(A7)
00002680  4E92      4229          jsr       (A2)
00002682  584F      4230          addq.w    #4,A7
                    4231   ; printf("\r\n  Debugger Command Summary") ;
00002684  4879 0000 4232          pea       @m68kde~2_100.L
00002688  6E10      
0000268A  4E92      4233          jsr       (A2)
0000268C  584F      4234          addq.w    #4,A7
                    4235   ; printf(banner) ;
0000268E  2F02      4236          move.l    D2,-(A7)
00002690  4E92      4237          jsr       (A2)
00002692  584F      4238          addq.w    #4,A7
                    4239   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
00002694  4879 0000 4240          pea       @m68kde~2_101.L
00002698  6E2E      
0000269A  4E92      4241          jsr       (A2)
0000269C  584F      4242          addq.w    #4,A7
                    4243   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill") ;
0000269E  4879 0000 4244          pea       @m68kde~2_102.L
000026A2  6E72      
000026A4  4E92      4245          jsr       (A2)
000026A6  584F      4246          addq.w    #4,A7
                    4247   ; printf("\r\n  C            - Copy Program from Flash to Main Memory") ;
000026A8  4879 0000 4248          pea       @m68kde~2_103.L
000026AC  6EAA      
000026AE  4E92      4249          jsr       (A2)
000026B0  584F      4250          addq.w    #4,A7
                    4251   ; printf("\r\n  DI           - Disassemble Program");
000026B2  4879 0000 4252          pea       @m68kde~2_104.L
000026B6  6EE4      
000026B8  4E92      4253          jsr       (A2)
000026BA  584F      4254          addq.w    #4,A7
                    4255   ; printf("\r\n  DU           - Dump Memory Contents to Screen") ;
000026BC  4879 0000 4256          pea       @m68kde~2_105.L
000026C0  6F0C      
000026C2  4E92      4257          jsr       (A2)
000026C4  584F      4258          addq.w    #4,A7
                    4259   ; printf("\r\n  E            - Enter String into Memory") ;
000026C6  4879 0000 4260          pea       @m68kde~2_106.L
000026CA  6F3E      
000026CC  4E92      4261          jsr       (A2)
000026CE  584F      4262          addq.w    #4,A7
                    4263   ; printf("\r\n  F            - Fill Memory with Data") ;
000026D0  4879 0000 4264          pea       @m68kde~2_107.L
000026D4  6F6A      
000026D6  4E92      4265          jsr       (A2)
000026D8  584F      4266          addq.w    #4,A7
                    4267   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC) ;
000026DA  2F39 0B00 4268          move.l    _PC.L,-(A7)
000026DE  0120      
000026E0  4879 0000 4269          pea       @m68kde~2_108.L
000026E4  6F94      
000026E6  4E92      4270          jsr       (A2)
000026E8  504F      4271          addq.w    #8,A7
                    4272   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop") ;
000026EA  4879 0000 4273          pea       @m68kde~2_109.L
000026EE  6FCE      
000026F0  4E92      4274          jsr       (A2)
000026F2  584F      4275          addq.w    #4,A7
                    4276   ; printf("\r\n  M            - Memory Examine and Change");
000026F4  4879 0000 4277          pea       @m68kde~2_110.L
000026F8  7006      
000026FA  4E92      4278          jsr       (A2)
000026FC  584F      4279          addq.w    #4,A7
                    4280   ; printf("\r\n  P            - Program Flash Memory with User Program") ;
000026FE  4879 0000 4281          pea       @m68kde~2_111.L
00002702  7034      
00002704  4E92      4282          jsr       (A2)
00002706  584F      4283          addq.w    #4,A7
                    4284   ; printf("\r\n  R            - Display 68000 Registers") ;
00002708  4879 0000 4285          pea       @m68kde~2_112.L
0000270C  706E      
0000270E  4E92      4286          jsr       (A2)
00002710  584F      4287          addq.w    #4,A7
                    4288   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode") ;
00002712  4879 0000 4289          pea       @m68kde~2_113.L
00002716  709A      
00002718  4E92      4290          jsr       (A2)
0000271A  584F      4291          addq.w    #4,A7
                    4292   ; printf("\r\n  TM           - Test Memory") ;
0000271C  4879 0000 4293          pea       @m68kde~2_114.L
00002720  70CC      
00002722  4E92      4294          jsr       (A2)
00002724  584F      4295          addq.w    #4,A7
                    4296   ; printf("\r\n  TS           - Test Switches: SW7-0") ;
00002726  4879 0000 4297          pea       @m68kde~2_115.L
0000272A  70EC      
0000272C  4E92      4298          jsr       (A2)
0000272E  584F      4299          addq.w    #4,A7
                    4300   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment") ;
00002730  4879 0000 4301          pea       @m68kde~2_116.L
00002734  7114      
00002736  4E92      4302          jsr       (A2)
00002738  584F      4303          addq.w    #4,A7
                    4304   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill") ;
0000273A  4879 0000 4305          pea       @m68kde~2_117.L
0000273E  714A      
00002740  4E92      4306          jsr       (A2)
00002742  584F      4307          addq.w    #4,A7
                    4308   ; printf(banner) ;
00002744  2F02      4309          move.l    D2,-(A7)
00002746  4E92      4310          jsr       (A2)
00002748  584F      4311          addq.w    #4,A7
0000274A  4CDF 0404 4312          movem.l   (A7)+,D2/A2
0000274E  4E75      4313          rts
                    4314   ; }
                    4315   ; void menu(void)
                    4316   ; {
                    4317   _menu:
00002750  48E7 303C 4318          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00002754  45F9 0000 4319          lea       _printf.L,A2
00002758  5AA4      
0000275A  47F9 0B00 4320          lea       _Trace.L,A3
0000275E  00D8      
00002760  49F9 0B00 4321          lea       _x.L,A4
00002764  00C8      
00002766  4BF9 0B00 4322          lea       _SR.L,A5
0000276A  012C      
                    4323   ; char c,c1 ;
                    4324   ; while(1)    {
                    4325   menu_1:
                    4326   ; FlushKeyboard() ;               // dump unread characters from keyboard
0000276C  4EB8 0BA6 4327          jsr       _FlushKeyboard
                    4328   ; printf("\r\n#") ;
00002770  4879 0000 4329          pea       @m68kde~2_118.L
00002774  7182      
00002776  4E92      4330          jsr       (A2)
00002778  584F      4331          addq.w    #4,A7
                    4332   ; c = toupper(_getch());
0000277A  2F00      4333          move.l    D0,-(A7)
0000277C  4EB8 0B68 4334          jsr       __getch
00002780  2200      4335          move.l    D0,D1
00002782  201F      4336          move.l    (A7)+,D0
00002784  2F01      4337          move.l    D1,-(A7)
00002786  4EB9 0000 4338          jsr       _toupper
0000278A  5A78      
0000278C  584F      4339          addq.w    #4,A7
0000278E  1400      4340          move.b    D0,D2
                    4341   ; if( c == (char)('L'))                  // load s record file
00002790  0C02 004C 4342          cmp.b     #76,D2
00002794  6608      4343          bne.s     menu_4
                    4344   ; Load_SRecordFile() ;
00002796  4EB8 104A 4345          jsr       _Load_SRecordFile
0000279A  6000 021E 4346          bra       menu_46
                    4347   menu_4:
                    4348   ; else if( c == (char)('D'))             // dump memory
0000279E  0C02 0044 4349          cmp.b     #68,D2
000027A2  6608      4350          bne.s     menu_6
                    4351   ; DMenu() ;
000027A4  4EB8 262C 4352          jsr       _DMenu
000027A8  6000 0210 4353          bra       menu_46
                    4354   menu_6:
                    4355   ; else if( c == (char)('E'))             // Enter String into memory
000027AC  0C02 0045 4356          cmp.b     #69,D2
000027B0  660A      4357          bne.s     menu_8
                    4358   ; EnterString() ;
000027B2  4EB9 0000 4359          jsr       _EnterString
000027B6  2B02      
000027B8  6000 0200 4360          bra       menu_46
                    4361   menu_8:
                    4362   ; else if( c == (char)('F'))             // fill memory
000027BC  0C02 0046 4363          cmp.b     #70,D2
000027C0  6608      4364          bne.s     menu_10
                    4365   ; FillMemory() ;
000027C2  4EB8 0FD0 4366          jsr       _FillMemory
000027C6  6000 01F2 4367          bra       menu_46
                    4368   menu_10:
                    4369   ; else if( c == (char)('G'))  {           // go user program
000027CA  0C02 0047 4370          cmp.b     #71,D2
000027CE  6626      4371          bne.s     menu_12
                    4372   ; printf("\r\nProgram Running.....") ;
000027D0  4879 0000 4373          pea       @m68kde~2_119.L
000027D4  7186      
000027D6  4E92      4374          jsr       (A2)
000027D8  584F      4375          addq.w    #4,A7
                    4376   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
000027DA  4879 0000 4377          pea       @m68kde~2_120.L
000027DE  719E      
000027E0  4E92      4378          jsr       (A2)
000027E2  584F      4379          addq.w    #4,A7
                    4380   ; GoFlag = 1 ;
000027E4  23FC 0000 4381          move.l    #1,_GoFlag.L
000027E8  0001 0B00 
000027EC  00DC      
                    4382   ; go() ;
000027EE  4EB8 08B8 4383          jsr       _go
000027F2  6000 01C6 4384          bra       menu_46
                    4385   menu_12:
                    4386   ; }
                    4387   ; else if( c == (char)('M'))           // memory examine and modify
000027F6  0C02 004D 4388          cmp.b     #77,D2
000027FA  6608      4389          bne.s     menu_14
                    4390   ; MemoryChange() ;
000027FC  4EB8 11D8 4391          jsr       _MemoryChange
00002800  6000 01B8 4392          bra       menu_46
                    4393   menu_14:
                    4394   ; else if( c == (char)('P'))            // Program Flash Chip
00002804  0C02 0050 4395          cmp.b     #80,D2
00002808  6608      4396          bne.s     menu_16
                    4397   ; ProgramFlashChip() ;
0000280A  4EB8 13CE 4398          jsr       _ProgramFlashChip
0000280E  6000 01AA 4399          bra       menu_46
                    4400   menu_16:
                    4401   ; else if( c == (char)('C'))             // copy flash chip to ram and go
00002812  0C02 0043 4402          cmp.b     #67,D2
00002816  6608      4403          bne.s     menu_18
                    4404   ; LoadFromFlashChip();
00002818  4EB8 14F8 4405          jsr       _LoadFromFlashChip
0000281C  6000 019C 4406          bra       menu_46
                    4407   menu_18:
                    4408   ; else if( c == (char)('R'))             // dump registers
00002820  0C02 0052 4409          cmp.b     #82,D2
00002824  6608      4410          bne.s     menu_20
                    4411   ; DumpRegisters() ;
00002826  4EB8 160E 4412          jsr       _DumpRegisters
0000282A  6000 018E 4413          bra       menu_46
                    4414   menu_20:
                    4415   ; else if( c == (char)('.'))           // change registers
0000282E  0C02 002E 4416          cmp.b     #46,D2
00002832  6608      4417          bne.s     menu_22
                    4418   ; ChangeRegisters() ;
00002834  4EB8 1B24 4419          jsr       _ChangeRegisters
00002838  6000 0180 4420          bra       menu_46
                    4421   menu_22:
                    4422   ; else if( c == (char)('B'))              // breakpoint command
0000283C  0C02 0042 4423          cmp.b     #66,D2
00002840  6608      4424          bne.s     menu_24
                    4425   ; Breakpoint() ;
00002842  4EB8 2534 4426          jsr       _Breakpoint
00002846  6000 0172 4427          bra       menu_46
                    4428   menu_24:
                    4429   ; else if( c == (char)('T'))  {          // Test command
0000284A  0C02 0054 4430          cmp.b     #84,D2
0000284E  6600 0046 4431          bne       menu_26
                    4432   ; c1 = toupper(_getch()) ;
00002852  2F00      4433          move.l    D0,-(A7)
00002854  4EB8 0B68 4434          jsr       __getch
00002858  2200      4435          move.l    D0,D1
0000285A  201F      4436          move.l    (A7)+,D0
0000285C  2F01      4437          move.l    D1,-(A7)
0000285E  4EB9 0000 4438          jsr       _toupper
00002862  5A78      
00002864  584F      4439          addq.w    #4,A7
00002866  1600      4440          move.b    D0,D3
                    4441   ; if(c1 == (char)('M'))                    // memory test
00002868  0C03 004D 4442          cmp.b     #77,D3
0000286C  6608      4443          bne.s     menu_28
                    4444   ; MemoryTest() ;
0000286E  4EB9 0000 4445          jsr       _MemoryTest
00002872  2B52      
00002874  601C      4446          bra.s     menu_33
                    4447   menu_28:
                    4448   ; else if( c1 == (char)('S'))              // Switch Test command
00002876  0C03 0053 4449          cmp.b     #83,D3
0000287A  6606      4450          bne.s     menu_30
                    4451   ; SwitchTest() ;
0000287C  4EB8 0AA4 4452          jsr       _SwitchTest
00002880  6010      4453          bra.s     menu_33
                    4454   menu_30:
                    4455   ; else if( c1 == (char)('D'))              // display Test command
00002882  0C03 0044 4456          cmp.b     #68,D3
00002886  6606      4457          bne.s     menu_32
                    4458   ; TestLEDS() ;
00002888  4EB8 0A50 4459          jsr       _TestLEDS
0000288C  6004      4460          bra.s     menu_33
                    4461   menu_32:
                    4462   ; else
                    4463   ; UnknownCommand() ;
0000288E  4EB8 2508 4464          jsr       _UnknownCommand
                    4465   menu_33:
00002892  6000 0126 4466          bra       menu_46
                    4467   menu_26:
                    4468   ; }
                    4469   ; else if( c == (char)(' ')) {             // Next instruction command
00002896  0C02 0020 4470          cmp.b     #32,D2
0000289A  6636      4471          bne.s     menu_34
                    4472   ; DisableBreakPoints() ;
0000289C  4EB8 2102 4473          jsr       _DisableBreakPoints
                    4474   ; if(Trace == 1 && GoFlag == 1)   {    // if the program is running and trace mode on then 'N' is valid
000028A0  2013      4475          move.l    (A3),D0
000028A2  0C80 0000 4476          cmp.l     #1,D0
000028A6  0001      
000028A8  661A      4477          bne.s     menu_36
000028AA  2039 0B00 4478          move.l    _GoFlag.L,D0
000028AE  00DC      
000028B0  0C80 0000 4479          cmp.l     #1,D0
000028B4  0001      
000028B6  660C      4480          bne.s     menu_36
                    4481   ; TraceException = 1 ;             // generate a trace exception for the next instruction if user wants to single step though next instruction
000028B8  13FC 0001 4482          move.b    #1,4194314
000028BC  0040 000A 
                    4483   ; return ;
000028C0  6000 00FC 4484          bra       menu_38
                    4485   menu_36:
                    4486   ; }
                    4487   ; else
                    4488   ; printf("\r\nError: Press 'G' first to start program") ;
000028C4  4879 0000 4489          pea       @m68kde~2_121.L
000028C8  71CC      
000028CA  4E92      4490          jsr       (A2)
000028CC  584F      4491          addq.w    #4,A7
000028CE  6000 00EA 4492          bra       menu_46
                    4493   menu_34:
                    4494   ; }
                    4495   ; else if( c == (char)('S')) {             // single step
000028D2  0C02 0053 4496          cmp.b     #83,D2
000028D6  6600 008C 4497          bne       menu_39
                    4498   ; if(Trace == 0) {
000028DA  2013      4499          move.l    (A3),D0
000028DC  6600 0050 4500          bne       menu_41
                    4501   ; DisableBreakPoints() ;
000028E0  4EB8 2102 4502          jsr       _DisableBreakPoints
                    4503   ; printf("\r\nSingle Step  :[ON]") ;
000028E4  4879 0000 4504          pea       @m68kde~2_122.L
000028E8  71F6      
000028EA  4E92      4505          jsr       (A2)
000028EC  584F      4506          addq.w    #4,A7
                    4507   ; printf("\r\nBreak Points :[Disabled]") ;
000028EE  4879 0000 4508          pea       @m68kde~2_53.L
000028F2  6852      
000028F4  4E92      4509          jsr       (A2)
000028F6  584F      4510          addq.w    #4,A7
                    4511   ; SR = SR | (unsigned short int)(0x8000) ;    // set T bit in status register
000028F8  0055 8000 4512          or.w      #32768,(A5)
                    4513   ; printf("\r\nPress 'G' to Trace Program from address $%X.....",PC) ;
000028FC  2F39 0B00 4514          move.l    _PC.L,-(A7)
00002900  0120      
00002902  4879 0000 4515          pea       @m68kde~2_123.L
00002906  720C      
00002908  4E92      4516          jsr       (A2)
0000290A  504F      4517          addq.w    #8,A7
                    4518   ; printf("\r\nPush <RESET Button> to Stop.....") ;
0000290C  4879 0000 4519          pea       @m68kde~2_124.L
00002910  7240      
00002912  4E92      4520          jsr       (A2)
00002914  584F      4521          addq.w    #4,A7
                    4522   ; DumpRegisters() ;
00002916  4EB8 160E 4523          jsr       _DumpRegisters
                    4524   ; Trace = 1;
0000291A  26BC 0000 4525          move.l    #1,(A3)
0000291E  0001      
                    4526   ; TraceException = 1;
00002920  13FC 0001 4527          move.b    #1,4194314
00002924  0040 000A 
                    4528   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002928  28B8 0074 4529          move.l    116,(A4)
0000292C  6032      4530          bra.s     menu_42
                    4531   menu_41:
                    4532   ; }
                    4533   ; else {
                    4534   ; Trace = 0 ;
0000292E  4293      4535          clr.l     (A3)
                    4536   ; TraceException = 0 ;
00002930  4239 0040 4537          clr.b     4194314
00002934  000A      
                    4538   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
00002936  28B8 0074 4539          move.l    116,(A4)
                    4540   ; EnableBreakPoints() ;
0000293A  4EB8 2156 4541          jsr       _EnableBreakPoints
                    4542   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
0000293E  0255 7FFF 4543          and.w     #32767,(A5)
                    4544   ; printf("\r\nSingle Step : [OFF]") ;
00002942  4879 0000 4545          pea       @m68kde~2_125.L
00002946  7264      
00002948  4E92      4546          jsr       (A2)
0000294A  584F      4547          addq.w    #4,A7
                    4548   ; printf("\r\nBreak Points :[Enabled]") ;
0000294C  4879 0000 4549          pea       @m68kde~2_126.L
00002950  727A      
00002952  4E92      4550          jsr       (A2)
00002954  584F      4551          addq.w    #4,A7
                    4552   ; printf("\r\nPress <ESC> to Resume User Program.....") ;
00002956  4879 0000 4553          pea       @m68kde~2_127.L
0000295A  7294      
0000295C  4E92      4554          jsr       (A2)
0000295E  584F      4555          addq.w    #4,A7
                    4556   menu_42:
00002960  6000 0058 4557          bra       menu_46
                    4558   menu_39:
                    4559   ; }
                    4560   ; }
                    4561   ; else if(c == (char)(0x1b))  {   // if user choses to end trace and run program
00002964  0C02 001B 4562          cmp.b     #27,D2
00002968  6600 0040 4563          bne       menu_43
                    4564   ; Trace = 0;
0000296C  4293      4565          clr.l     (A3)
                    4566   ; TraceException = 0;
0000296E  4239 0040 4567          clr.b     4194314
00002972  000A      
                    4568   ; x = *(unsigned int *)(0x00000074) ;   // read IRQ 5 vector to reset trace vector generator
00002974  28B8 0074 4569          move.l    116,(A4)
                    4570   ; EnableBreakPoints() ;
00002978  4EB8 2156 4571          jsr       _EnableBreakPoints
                    4572   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
0000297C  0255 7FFF 4573          and.w     #32767,(A5)
                    4574   ; printf("\r\nSingle Step  :[OFF]") ;
00002980  4879 0000 4575          pea       @m68kde~2_128.L
00002984  72BE      
00002986  4E92      4576          jsr       (A2)
00002988  584F      4577          addq.w    #4,A7
                    4578   ; printf("\r\nBreak Points :[Enabled]");
0000298A  4879 0000 4579          pea       @m68kde~2_126.L
0000298E  727A      
00002990  4E92      4580          jsr       (A2)
00002992  584F      4581          addq.w    #4,A7
                    4582   ; printf("\r\nProgram Running.....") ;
00002994  4879 0000 4583          pea       @m68kde~2_119.L
00002998  7186      
0000299A  4E92      4584          jsr       (A2)
0000299C  584F      4585          addq.w    #4,A7
                    4586   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
0000299E  4879 0000 4587          pea       @m68kde~2_120.L
000029A2  719E      
000029A4  4E92      4588          jsr       (A2)
000029A6  584F      4589          addq.w    #4,A7
                    4590   ; return ;
000029A8  6014      4591          bra.s     menu_38
                    4592   menu_43:
                    4593   ; }
                    4594   ; else if( c == (char)('W'))              // Watchpoint command
000029AA  0C02 0057 4595          cmp.b     #87,D2
000029AE  6606      4596          bne.s     menu_45
                    4597   ; Watchpoint() ;
000029B0  4EB8 25B0 4598          jsr       _Watchpoint
000029B4  6004      4599          bra.s     menu_46
                    4600   menu_45:
                    4601   ; else
                    4602   ; UnknownCommand() ;
000029B6  4EB8 2508 4603          jsr       _UnknownCommand
                    4604   menu_46:
000029BA  6000 FDB0 4605          bra       menu_1
                    4606   menu_38:
000029BE  4CDF 3C0C 4607          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
000029C2  4E75      4608          rts
                    4609   ; }
                    4610   ; }
                    4611   ; void PrintErrorMessageandAbort(char *string) {
                    4612   _PrintErrorMessageandAbort:
000029C4  4E56 0000 4613          link      A6,#0
                    4614   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n") ;
000029C8  4879 0000 4615          pea       @m68kde~2_129.L
000029CC  72D4      
000029CE  4EB9 0000 4616          jsr       _printf
000029D2  5AA4      
000029D4  584F      4617          addq.w    #4,A7
                    4618   ; printf("%s\r\n", string) ;
000029D6  2F2E 0008 4619          move.l    8(A6),-(A7)
000029DA  4879 0000 4620          pea       @m68kde~2_130.L
000029DE  72F0      
000029E0  4EB9 0000 4621          jsr       _printf
000029E4  5AA4      
000029E6  504F      4622          addq.w    #8,A7
                    4623   ; menu() ;
000029E8  4EB8 2750 4624          jsr       _menu
000029EC  4E5E      4625          unlk      A6
000029EE  4E75      4626          rts
                    4627   ; }
                    4628   ; void IRQMessage(int level) {
                    4629   _IRQMessage:
000029F0  4E56 0000 4630          link      A6,#0
                    4631   ; printf("\r\n\r\nProgram ABORT !!!!!");
000029F4  4879 0000 4632          pea       @m68kde~2_131.L
000029F8  72F6      
000029FA  4EB9 0000 4633          jsr       _printf
000029FE  5AA4      
00002A00  584F      4634          addq.w    #4,A7
                    4635   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level) ;
00002A02  2F2E 0008 4636          move.l    8(A6),-(A7)
00002A06  4879 0000 4637          pea       @m68kde~2_132.L
00002A0A  730E      
00002A0C  4EB9 0000 4638          jsr       _printf
00002A10  5AA4      
00002A12  504F      4639          addq.w    #8,A7
                    4640   ; menu() ;
00002A14  4EB8 2750 4641          jsr       _menu
00002A18  4E5E      4642          unlk      A6
00002A1A  4E75      4643          rts
                    4644   ; }
                    4645   ; void UnhandledIRQ1(void) {
                    4646   _UnhandledIRQ1:
                    4647   ; IRQMessage(1);
00002A1C  4878 0001 4648          pea       1
00002A20  4EB8 29F0 4649          jsr       _IRQMessage
00002A24  584F      4650          addq.w    #4,A7
00002A26  4E75      4651          rts
                    4652   ; }
                    4653   ; void UnhandledIRQ2(void) {
                    4654   _UnhandledIRQ2:
                    4655   ; IRQMessage(2);
00002A28  4878 0002 4656          pea       2
00002A2C  4EB8 29F0 4657          jsr       _IRQMessage
00002A30  584F      4658          addq.w    #4,A7
00002A32  4E75      4659          rts
                    4660   ; }
                    4661   ; void UnhandledIRQ3(void){
                    4662   _UnhandledIRQ3:
                    4663   ; IRQMessage(3);
00002A34  4878 0003 4664          pea       3
00002A38  4EB8 29F0 4665          jsr       _IRQMessage
00002A3C  584F      4666          addq.w    #4,A7
00002A3E  4E75      4667          rts
                    4668   ; }
                    4669   ; void UnhandledIRQ4(void) {
                    4670   _UnhandledIRQ4:
                    4671   ; IRQMessage(4);
00002A40  4878 0004 4672          pea       4
00002A44  4EB8 29F0 4673          jsr       _IRQMessage
00002A48  584F      4674          addq.w    #4,A7
00002A4A  4E75      4675          rts
                    4676   ; }
                    4677   ; void UnhandledIRQ5(void) {
                    4678   _UnhandledIRQ5:
                    4679   ; IRQMessage(5);
00002A4C  4878 0005 4680          pea       5
00002A50  4EB8 29F0 4681          jsr       _IRQMessage
00002A54  584F      4682          addq.w    #4,A7
00002A56  4E75      4683          rts
                    4684   ; }
                    4685   ; void UnhandledIRQ6(void) {
                    4686   _UnhandledIRQ6:
                    4687   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....") ;
00002A58  4879 0000 4688          pea       @m68kde~2_133.L
00002A5C  7332      
00002A5E  4EB8 29C4 4689          jsr       _PrintErrorMessageandAbort
00002A62  584F      4690          addq.w    #4,A7
                    4691   ; menu() ;
00002A64  4EB8 2750 4692          jsr       _menu
00002A68  4E75      4693          rts
                    4694   ; }
                    4695   ; void UnhandledIRQ7(void) {
                    4696   _UnhandledIRQ7:
                    4697   ; IRQMessage(7);
00002A6A  4878 0007 4698          pea       7
00002A6E  4EB8 29F0 4699          jsr       _IRQMessage
00002A72  584F      4700          addq.w    #4,A7
00002A74  4E75      4701          rts
                    4702   ; }
                    4703   ; void UnhandledTrap(void) {
                    4704   _UnhandledTrap:
                    4705   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!") ;
00002A76  4879 0000 4706          pea       @m68kde~2_134.L
00002A7A  7372      
00002A7C  4EB8 29C4 4707          jsr       _PrintErrorMessageandAbort
00002A80  584F      4708          addq.w    #4,A7
00002A82  4E75      4709          rts
                    4710   ; }
                    4711   ; void BusError() {
                    4712   _BusError:
                    4713   ; PrintErrorMessageandAbort("BUS Error!") ;
00002A84  4879 0000 4714          pea       @m68kde~2_135.L
00002A88  7388      
00002A8A  4EB8 29C4 4715          jsr       _PrintErrorMessageandAbort
00002A8E  584F      4716          addq.w    #4,A7
00002A90  4E75      4717          rts
                    4718   ; }
                    4719   ; void AddressError() {
                    4720   _AddressError:
                    4721   ; PrintErrorMessageandAbort("ADDRESS Error!") ;
00002A92  4879 0000 4722          pea       @m68kde~2_136.L
00002A96  7394      
00002A98  4EB8 29C4 4723          jsr       _PrintErrorMessageandAbort
00002A9C  584F      4724          addq.w    #4,A7
00002A9E  4E75      4725          rts
                    4726   ; }
                    4727   ; void IllegalInstruction() {
                    4728   _IllegalInstruction:
                    4729   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION") ;
00002AA0  4879 0000 4730          pea       @m68kde~2_137.L
00002AA4  73A4      
00002AA6  4EB8 29C4 4731          jsr       _PrintErrorMessageandAbort
00002AAA  584F      4732          addq.w    #4,A7
00002AAC  4E75      4733          rts
                    4734   ; }
                    4735   ; void Dividebyzero() {
                    4736   _Dividebyzero:
                    4737   ; PrintErrorMessageandAbort("DIVIDE BY ZERO") ;
00002AAE  4879 0000 4738          pea       @m68kde~2_138.L
00002AB2  73B8      
00002AB4  4EB8 29C4 4739          jsr       _PrintErrorMessageandAbort
00002AB8  584F      4740          addq.w    #4,A7
00002ABA  4E75      4741          rts
                    4742   ; }
                    4743   ; void Check() {
                    4744   _Check:
                    4745   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION") ;
00002ABC  4879 0000 4746          pea       @m68kde~2_139.L
00002AC0  73C8      
00002AC2  4EB8 29C4 4747          jsr       _PrintErrorMessageandAbort
00002AC6  584F      4748          addq.w    #4,A7
00002AC8  4E75      4749          rts
                    4750   ; }
                    4751   ; void Trapv() {
                    4752   _Trapv:
                    4753   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION") ;
00002ACA  4879 0000 4754          pea       @m68kde~2_140.L
00002ACE  73DA      
00002AD0  4EB8 29C4 4755          jsr       _PrintErrorMessageandAbort
00002AD4  584F      4756          addq.w    #4,A7
00002AD6  4E75      4757          rts
                    4758   ; }
                    4759   ; void PrivError() {
                    4760   _PrivError:
                    4761   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION") ;
00002AD8  4879 0000 4762          pea       @m68kde~2_141.L
00002ADC  73EC      
00002ADE  4EB8 29C4 4763          jsr       _PrintErrorMessageandAbort
00002AE2  584F      4764          addq.w    #4,A7
00002AE4  4E75      4765          rts
                    4766   ; }
                    4767   ; void UnitIRQ() {
                    4768   _UnitIRQ:
                    4769   ; PrintErrorMessageandAbort("UNINITIALISED IRQ") ;
00002AE6  4879 0000 4770          pea       @m68kde~2_142.L
00002AEA  7400      
00002AEC  4EB8 29C4 4771          jsr       _PrintErrorMessageandAbort
00002AF0  584F      4772          addq.w    #4,A7
00002AF2  4E75      4773          rts
                    4774   ; }
                    4775   ; void Spurious() {
                    4776   _Spurious:
                    4777   ; PrintErrorMessageandAbort("SPURIOUS IRQ") ;
00002AF4  4879 0000 4778          pea       @m68kde~2_143.L
00002AF8  7412      
00002AFA  4EB8 29C4 4779          jsr       _PrintErrorMessageandAbort
00002AFE  584F      4780          addq.w    #4,A7
00002B00  4E75      4781          rts
                    4782   ; }
                    4783   ; void EnterString(void)
                    4784   ; {
                    4785   _EnterString:
00002B02  4E56 FFFC 4786          link      A6,#-4
00002B06  2F02      4787          move.l    D2,-(A7)
                    4788   ; unsigned char *Start;
                    4789   ; unsigned char c;
                    4790   ; printf("\r\nStart Address in Memory: ");
00002B08  4879 0000 4791          pea       @m68kde~2_144.L
00002B0C  7420      
00002B0E  4EB9 0000 4792          jsr       _printf
00002B12  5AA4      
00002B14  584F      4793          addq.w    #4,A7
                    4794   ; Start = Get8HexDigits(0) ;
00002B16  42A7      4795          clr.l     -(A7)
00002B18  4EB8 0CA4 4796          jsr       _Get8HexDigits
00002B1C  584F      4797          addq.w    #4,A7
00002B1E  2400      4798          move.l    D0,D2
                    4799   ; printf("\r\nEnter String (ESC to end) :") ;
00002B20  4879 0000 4800          pea       @m68kde~2_145.L
00002B24  743C      
00002B26  4EB9 0000 4801          jsr       _printf
00002B2A  5AA4      
00002B2C  584F      4802          addq.w    #4,A7
                    4803   ; while((c = getchar()) != 0x1b)
                    4804   EnterString_1:
00002B2E  4EB9 0000 4805          jsr       _getch
00002B32  59C6      
00002B34  1D40 FFFF 4806          move.b    D0,-1(A6)
00002B38  0C00 001B 4807          cmp.b     #27,D0
00002B3C  670A      4808          beq.s     EnterString_3
                    4809   ; *Start++ = c ;
00002B3E  2042      4810          move.l    D2,A0
00002B40  5282      4811          addq.l    #1,D2
00002B42  10AE FFFF 4812          move.b    -1(A6),(A0)
00002B46  60E6      4813          bra       EnterString_1
                    4814   EnterString_3:
                    4815   ; *Start = 0x00;  // terminate with a null
00002B48  2042      4816          move.l    D2,A0
00002B4A  4210      4817          clr.b     (A0)
00002B4C  241F      4818          move.l    (A7)+,D2
00002B4E  4E5E      4819          unlk      A6
00002B50  4E75      4820          rts
                    4821   ; }
                    4822   ; void MemoryTest(void)
                    4823   ; {
                    4824   _MemoryTest:
00002B52  4E56 FFF8 4825          link      A6,#-8
00002B56  48E7 3F30 4826          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
00002B5A  45F9 0000 4827          lea       _printf.L,A2
00002B5E  5AA4      
                    4828   ; unsigned long long int *RamPtr;
                    4829   ; unsigned int counter1=0x8cb;
00002B60  2A3C 0000 4830          move.l    #2251,D5
00002B64  08CB      
                    4831   ; register unsigned int i ;
                    4832   ; unsigned int Start, End ;
                    4833   ; char c ;
                    4834   ; unsigned long int data, write_data;
                    4835   ; unsigned int bwl=0;
00002B66  4286      4836          clr.l     D6
                    4837   ; // input validation of addresses, user should know that for word and long word addresses shoudl align to even.
                    4838   ; do{
                    4839   MemoryTest_1:
                    4840   ; printf("\r\nStart Address");
00002B68  4879 0000 4841          pea       @m68kde~2_146.L
00002B6C  745A      
00002B6E  4E92      4842          jsr       (A2)
00002B70  584F      4843          addq.w    #4,A7
                    4844   ; Start = Get8HexDigits(0);
00002B72  42A7      4845          clr.l     -(A7)
00002B74  4EB8 0CA4 4846          jsr       _Get8HexDigits
00002B78  584F      4847          addq.w    #4,A7
00002B7A  2E00      4848          move.l    D0,D7
00002B7C  0C87 0900 4849          cmp.l     #150994944,D7
00002B80  0000      
00002B82  65E4      4850          blo       MemoryTest_1
00002B84  0C87 097F 4851          cmp.l     #159383551,D7
00002B88  FFFF      
00002B8A  62DC      4852          bhi       MemoryTest_1
                    4853   ; } while (0x09000000  > Start || 0x097FFFFF < Start);
                    4854   ; // Start = 0x08020000;
                    4855   ; do {
                    4856   MemoryTest_3:
                    4857   ; printf("\r\nEnd Address") ;
00002B8C  4879 0000 4858          pea       @m68kde~2_147.L
00002B90  746A      
00002B92  4E92      4859          jsr       (A2)
00002B94  584F      4860          addq.w    #4,A7
                    4861   ; End = Get8HexDigits(0) ;
00002B96  42A7      4862          clr.l     -(A7)
00002B98  4EB8 0CA4 4863          jsr       _Get8HexDigits
00002B9C  584F      4864          addq.w    #4,A7
00002B9E  2640      4865          move.l    D0,A3
00002BA0  BE8B      4866          cmp.l     A3,D7
00002BA2  62E8      4867          bhi       MemoryTest_3
00002BA4  200B      4868          move.l    A3,D0
00002BA6  0C80 097F 4869          cmp.l     #159383551,D0
00002BAA  FFFF      
00002BAC  62DE      4870          bhi       MemoryTest_3
                    4871   ; } while (Start > End || End > 0x097FFFFF);
                    4872   ; // End = 0x08030000;
                    4873   ; // Get test pattern and set data appropriately
                    4874   ; while(1)    {
                    4875   MemoryTest_5:
                    4876   ; FlushKeyboard() ;               // dump unread characters from keyboard
00002BAE  4EB8 0BA6 4877          jsr       _FlushKeyboard
                    4878   ; printf("\r\nTest pattern: \r\n0: 55\r\n1: AA\r\n2: FF\r\n3: 00");
00002BB2  4879 0000 4879          pea       @m68kde~2_148.L
00002BB6  7478      
00002BB8  4E92      4880          jsr       (A2)
00002BBA  584F      4881          addq.w    #4,A7
                    4882   ; printf("\r\n#") ;
00002BBC  4879 0000 4883          pea       @m68kde~2_118.L
00002BC0  7182      
00002BC2  4E92      4884          jsr       (A2)
00002BC4  584F      4885          addq.w    #4,A7
                    4886   ; c = toupper(_getch());
00002BC6  2F00      4887          move.l    D0,-(A7)
00002BC8  4EB8 0B68 4888          jsr       __getch
00002BCC  2200      4889          move.l    D0,D1
00002BCE  201F      4890          move.l    (A7)+,D0
00002BD0  2F01      4891          move.l    D1,-(A7)
00002BD2  4EB9 0000 4892          jsr       _toupper
00002BD6  5A78      
00002BD8  584F      4893          addq.w    #4,A7
00002BDA  1800      4894          move.b    D0,D4
                    4895   ; if( c == (char)('0')){
00002BDC  0C04 0030 4896          cmp.b     #48,D4
00002BE0  6604      4897          bne.s     MemoryTest_8
                    4898   ; data = 0x55;
00002BE2  7455      4899          moveq     #85,D2
                    4900   ; break;
00002BE4  6028      4901          bra.s     MemoryTest_7
                    4902   MemoryTest_8:
                    4903   ; }
                    4904   ; else if( c == (char)('1')){
00002BE6  0C04 0031 4905          cmp.b     #49,D4
00002BEA  6608      4906          bne.s     MemoryTest_10
                    4907   ; data = 0xAA;
00002BEC  243C 0000 4908          move.l    #170,D2
00002BF0  00AA      
                    4909   ; break;
00002BF2  601A      4910          bra.s     MemoryTest_7
                    4911   MemoryTest_10:
                    4912   ; }
                    4913   ; else if( c == (char)('2')){
00002BF4  0C04 0032 4914          cmp.b     #50,D4
00002BF8  6608      4915          bne.s     MemoryTest_12
                    4916   ; data = 0xFF;
00002BFA  243C 0000 4917          move.l    #255,D2
00002BFE  00FF      
                    4918   ; break;
00002C00  600C      4919          bra.s     MemoryTest_7
                    4920   MemoryTest_12:
                    4921   ; }
                    4922   ; else if( c == (char)('3')){
00002C02  0C04 0033 4923          cmp.b     #51,D4
00002C06  6604      4924          bne.s     MemoryTest_14
                    4925   ; data = 0x00;
00002C08  4282      4926          clr.l     D2
                    4927   ; break;
00002C0A  6002      4928          bra.s     MemoryTest_7
                    4929   MemoryTest_14:
00002C0C  60A0      4930          bra       MemoryTest_5
                    4931   MemoryTest_7:
                    4932   ; }
                    4933   ; }
                    4934   ; // Let user know what they selected
                    4935   ; printf("\r\nData selected: 0x%x", data);
00002C0E  2F02      4936          move.l    D2,-(A7)
00002C10  4879 0000 4937          pea       @m68kde~2_149.L
00002C14  74A6      
00002C16  4E92      4938          jsr       (A2)
00002C18  504F      4939          addq.w    #8,A7
                    4940   ; // Get size of test pattern and set data size appropriately
                    4941   ; while(1)    {
                    4942   MemoryTest_16:
                    4943   ; FlushKeyboard() ;               // dump unread characters from keyboard
00002C1A  4EB8 0BA6 4944          jsr       _FlushKeyboard
                    4945   ; printf("\r\nEnter 'B', 'W', or 'L' for bytes, words, or long word: ");
00002C1E  4879 0000 4946          pea       @m68kde~2_150.L
00002C22  74BC      
00002C24  4E92      4947          jsr       (A2)
00002C26  584F      4948          addq.w    #4,A7
                    4949   ; printf("\r\n#") ;
00002C28  4879 0000 4950          pea       @m68kde~2_118.L
00002C2C  7182      
00002C2E  4E92      4951          jsr       (A2)
00002C30  584F      4952          addq.w    #4,A7
                    4953   ; c = toupper(_getch());
00002C32  2F00      4954          move.l    D0,-(A7)
00002C34  4EB8 0B68 4955          jsr       __getch
00002C38  2200      4956          move.l    D0,D1
00002C3A  201F      4957          move.l    (A7)+,D0
00002C3C  2F01      4958          move.l    D1,-(A7)
00002C3E  4EB9 0000 4959          jsr       _toupper
00002C42  5A78      
00002C44  584F      4960          addq.w    #4,A7
00002C46  1800      4961          move.b    D0,D4
                    4962   ; if( c == (char)('B')){
00002C48  0C04 0042 4963          cmp.b     #66,D4
00002C4C  6606      4964          bne.s     MemoryTest_19
                    4965   ; bwl = 0x1;
00002C4E  7C01      4966          moveq     #1,D6
                    4967   ; break;
00002C50  6000 003E 4968          bra       MemoryTest_18
                    4969   MemoryTest_19:
                    4970   ; }
                    4971   ; else if( c == (char)('W')){
00002C54  0C04 0057 4972          cmp.b     #87,D4
00002C58  660C      4973          bne.s     MemoryTest_21
                    4974   ; bwl = 0x2;
00002C5A  7C02      4975          moveq     #2,D6
                    4976   ; data = data | data << 8;
00002C5C  2002      4977          move.l    D2,D0
00002C5E  E188      4978          lsl.l     #8,D0
00002C60  8480      4979          or.l      D0,D2
                    4980   ; break;
00002C62  6000 002C 4981          bra       MemoryTest_18
                    4982   MemoryTest_21:
                    4983   ; }
                    4984   ; else if( c == (char)('L')){
00002C66  0C04 004C 4985          cmp.b     #76,D4
00002C6A  6600 0022 4986          bne       MemoryTest_23
                    4987   ; bwl = 0x3;
00002C6E  7C03      4988          moveq     #3,D6
                    4989   ; data = data | data << 8 | data << 16 | data << 24;
00002C70  2002      4990          move.l    D2,D0
00002C72  2202      4991          move.l    D2,D1
00002C74  E189      4992          lsl.l     #8,D1
00002C76  8081      4993          or.l      D1,D0
00002C78  2202      4994          move.l    D2,D1
00002C7A  E189      4995          lsl.l     #8,D1
00002C7C  E189      4996          lsl.l     #8,D1
00002C7E  8081      4997          or.l      D1,D0
00002C80  2202      4998          move.l    D2,D1
00002C82  E189      4999          lsl.l     #8,D1
00002C84  E189      5000          lsl.l     #8,D1
00002C86  E189      5001          lsl.l     #8,D1
00002C88  8081      5002          or.l      D1,D0
00002C8A  2400      5003          move.l    D0,D2
                    5004   ; break;
00002C8C  6002      5005          bra.s     MemoryTest_18
                    5006   MemoryTest_23:
00002C8E  608A      5007          bra       MemoryTest_16
                    5008   MemoryTest_18:
                    5009   ; }
                    5010   ; }
                    5011   ; // Let user know what they selected
                    5012   ; printf("\r\nbwl selected:");
00002C90  4879 0000 5013          pea       @m68kde~2_151.L
00002C94  74F6      
00002C96  4E92      5014          jsr       (A2)
00002C98  584F      5015          addq.w    #4,A7
                    5016   ; if(bwl == (unsigned int)(0x3)) printf("Long word");
00002C9A  0C86 0000 5017          cmp.l     #3,D6
00002C9E  0003      
00002CA0  660A      5018          bne.s     MemoryTest_25
00002CA2  4879 0000 5019          pea       @m68kde~2_152.L
00002CA6  7506      
00002CA8  4E92      5020          jsr       (A2)
00002CAA  584F      5021          addq.w    #4,A7
                    5022   MemoryTest_25:
                    5023   ; if(bwl == (unsigned int)(0x2)) printf("Word");
00002CAC  0C86 0000 5024          cmp.l     #2,D6
00002CB0  0002      
00002CB2  660A      5025          bne.s     MemoryTest_27
00002CB4  4879 0000 5026          pea       @m68kde~2_153.L
00002CB8  7510      
00002CBA  4E92      5027          jsr       (A2)
00002CBC  584F      5028          addq.w    #4,A7
                    5029   MemoryTest_27:
                    5030   ; if(bwl == (unsigned int)(0x1)) printf("Bytes");
00002CBE  0C86 0000 5031          cmp.l     #1,D6
00002CC2  0001      
00002CC4  660A      5032          bne.s     MemoryTest_29
00002CC6  4879 0000 5033          pea       @m68kde~2_154.L
00002CCA  7516      
00002CCC  4E92      5034          jsr       (A2)
00002CCE  584F      5035          addq.w    #4,A7
                    5036   MemoryTest_29:
                    5037   ; // Set pointer to start addr
                    5038   ; RamPtr = Start;
00002CD0  2607      5039          move.l    D7,D3
                    5040   ; // Write loop
                    5041   ; while(1){
                    5042   MemoryTest_31:
                    5043   ; // When end addr is reached
                    5044   ; if (RamPtr > End){
00002CD2  B68B      5045          cmp.l     A3,D3
00002CD4  630C      5046          bls.s     MemoryTest_34
                    5047   ; printf("\r\nWrite complete. Starting read.");
00002CD6  4879 0000 5048          pea       @m68kde~2_155.L
00002CDA  751C      
00002CDC  4E92      5049          jsr       (A2)
00002CDE  584F      5050          addq.w    #4,A7
                    5051   ; break;
00002CE0  6026      5052          bra.s     MemoryTest_33
                    5053   MemoryTest_34:
                    5054   ; }
                    5055   ; // Set data at address to specified by user
                    5056   ; *RamPtr = data;
00002CE2  2043      5057          move.l    D3,A0
00002CE4  2082      5058          move.l    D2,(A0)
                    5059   ; counter1++;
00002CE6  5285      5060          addq.l    #1,D5
                    5061   ; // Dont check every time, just check some time incl first time
                    5062   ; if (counter1 == 0x8cc){
00002CE8  0C85 0000 5063          cmp.l     #2252,D5
00002CEC  08CC      
00002CEE  6614      5064          bne.s     MemoryTest_36
                    5065   ; printf("\r\nWrite: 0x%x to addr 0x%x", *RamPtr, RamPtr);
00002CF0  2F03      5066          move.l    D3,-(A7)
00002CF2  2043      5067          move.l    D3,A0
00002CF4  2F10      5068          move.l    (A0),-(A7)
00002CF6  4879 0000 5069          pea       @m68kde~2_156.L
00002CFA  753E      
00002CFC  4E92      5070          jsr       (A2)
00002CFE  DEFC 000C 5071          add.w     #12,A7
                    5072   ; counter1 = 1;
00002D02  7A01      5073          moveq     #1,D5
                    5074   MemoryTest_36:
                    5075   ; }
                    5076   ; // Increment address
                    5077   ; RamPtr++;
00002D04  5883      5078          addq.l    #4,D3
00002D06  60CA      5079          bra       MemoryTest_31
                    5080   MemoryTest_33:
                    5081   ; }
                    5082   ; // Reset pointer to start addr
                    5083   ; RamPtr = Start;
00002D08  2607      5084          move.l    D7,D3
                    5085   ; // Reset counter to default
                    5086   ; counter1 = 0x8cb;
00002D0A  2A3C 0000 5087          move.l    #2251,D5
00002D0E  08CB      
                    5088   ; // Read loop
                    5089   ; while(1){
                    5090   MemoryTest_38:
                    5091   ; // When end addr is reached
                    5092   ; if (RamPtr > End){
00002D10  B68B      5093          cmp.l     A3,D3
00002D12  6318      5094          bls.s     MemoryTest_41
                    5095   ; printf("\r\nRead complete.");
00002D14  4879 0000 5096          pea       @m68kde~2_157.L
00002D18  755A      
00002D1A  4E92      5097          jsr       (A2)
00002D1C  584F      5098          addq.w    #4,A7
                    5099   ; printf("\r\nNo error in mem test");
00002D1E  4879 0000 5100          pea       @m68kde~2_158.L
00002D22  756C      
00002D24  4E92      5101          jsr       (A2)
00002D26  584F      5102          addq.w    #4,A7
                    5103   ; break;
00002D28  6000 004A 5104          bra       MemoryTest_40
                    5105   MemoryTest_41:
                    5106   ; }
                    5107   ; // Read check every address to specified data by user
                    5108   ; if (*RamPtr != data){
00002D2C  2043      5109          move.l    D3,A0
00002D2E  B490      5110          cmp.l     (A0),D2
00002D30  6720      5111          beq.s     MemoryTest_43
                    5112   ; printf("\r\nERROR: Address 0x%x data is 0x%x but should be 0x%x", RamPtr, *RamPtr, data);
00002D32  2F02      5113          move.l    D2,-(A7)
00002D34  2043      5114          move.l    D3,A0
00002D36  2F10      5115          move.l    (A0),-(A7)
00002D38  2F03      5116          move.l    D3,-(A7)
00002D3A  4879 0000 5117          pea       @m68kde~2_159.L
00002D3E  7584      
00002D40  4E92      5118          jsr       (A2)
00002D42  DEFC 0010 5119          add.w     #16,A7
                    5120   ; printf("\r\nFAIL: Mem test did not complete successfully.");
00002D46  4879 0000 5121          pea       @m68kde~2_160.L
00002D4A  75BA      
00002D4C  4E92      5122          jsr       (A2)
00002D4E  584F      5123          addq.w    #4,A7
                    5124   ; break;
00002D50  6022      5125          bra.s     MemoryTest_40
                    5126   MemoryTest_43:
                    5127   ; }
                    5128   ; counter1++;
00002D52  5285      5129          addq.l    #1,D5
                    5130   ; // Dont check every time, just check some time incl first time
                    5131   ; if (counter1 == 0x8cc){
00002D54  0C85 0000 5132          cmp.l     #2252,D5
00002D58  08CC      
00002D5A  6614      5133          bne.s     MemoryTest_45
                    5134   ; printf("\r\nRead: Address 0x%x data is 0x%x", RamPtr, *RamPtr);
00002D5C  2043      5135          move.l    D3,A0
00002D5E  2F10      5136          move.l    (A0),-(A7)
00002D60  2F03      5137          move.l    D3,-(A7)
00002D62  4879 0000 5138          pea       @m68kde~2_161.L
00002D66  75EA      
00002D68  4E92      5139          jsr       (A2)
00002D6A  DEFC 000C 5140          add.w     #12,A7
                    5141   ; counter1 = 1;
00002D6E  7A01      5142          moveq     #1,D5
                    5143   MemoryTest_45:
                    5144   ; }
                    5145   ; RamPtr++;
00002D70  5883      5146          addq.l    #4,D3
00002D72  609C      5147          bra       MemoryTest_38
                    5148   MemoryTest_40:
00002D74  4CDF 0CFC 5149          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
00002D78  4E5E      5150          unlk      A6
00002D7A  4E75      5151          rts
                    5152   ; }
                    5153   ; }
                    5154   ; void main(void)
                    5155   ; {
                    5156   _main:
00002D7C  4E56 FFF4 5157          link      A6,#-12
00002D80  48E7 3030 5158          movem.l   D2/D3/A2/A3,-(A7)
00002D84  45F8 0A30 5159          lea       _InstallExceptionHandler.L,A2
00002D88  47F9 0000 5160          lea       _printf.L,A3
00002D8C  5AA4      
                    5161   ; char c ;
                    5162   ; int i, j ;
                    5163   ; char *BugMessage = "Lab3";
00002D8E  41F9 0000 5164          lea       @m68kde~2_162.L,A0
00002D92  760C      
00002D94  2608      5165          move.l    A0,D3
                    5166   ; char *CopyrightMessage = "Aaran Poon 36228203\nParsa Keshmiri 35727379";
00002D96  41F9 0000 5167          lea       @m68kde~2_163.L,A0
00002D9A  7612      
00002D9C  2D48 FFFC 5168          move.l    A0,-4(A6)
                    5169   ; KillAllBreakPoints() ;
00002DA0  4EB8 219E 5170          jsr       _KillAllBreakPoints
                    5171   ; i = x = y = z = PortA_Count = 0;
00002DA4  42B9 0B00 5172          clr.l     _PortA_Count.L
00002DA8  00D4      
00002DAA  42B9 0B00 5173          clr.l     _z.L
00002DAE  00D0      
00002DB0  42B9 0B00 5174          clr.l     _y.L
00002DB4  00CC      
00002DB6  42B9 0B00 5175          clr.l     _x.L
00002DBA  00C8      
00002DBC  4282      5176          clr.l     D2
                    5177   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
00002DBE  42B9 0B00 5178          clr.l     _GoFlag.L
00002DC2  00DC      
00002DC4  42B9 0B00 5179          clr.l     _Trace.L
00002DC8  00D8      
                    5180   ; Echo = 1 ;
00002DCA  23FC 0000 5181          move.l    #1,_Echo.L
00002DCE  0001 0B00 
00002DD2  00E0      
                    5182   ; d0=d1=d2=d3=d4=d5=d6=d7=0 ;
00002DD4  42B9 0B00 5183          clr.l     _d7.L
00002DD8  0100      
00002DDA  42B9 0B00 5184          clr.l     _d6.L
00002DDE  00FC      
00002DE0  42B9 0B00 5185          clr.l     _d5.L
00002DE4  00F8      
00002DE6  42B9 0B00 5186          clr.l     _d4.L
00002DEA  00F4      
00002DEC  42B9 0B00 5187          clr.l     _d3.L
00002DF0  00F0      
00002DF2  42B9 0B00 5188          clr.l     _d2.L
00002DF6  00EC      
00002DF8  42B9 0B00 5189          clr.l     _d1.L
00002DFC  00E8      
00002DFE  42B9 0B00 5190          clr.l     _d0.L
00002E02  00E4      
                    5191   ; a0=a1=a2=a3=a4=a5=a6=0 ;
00002E04  42B9 0B00 5192          clr.l     _a6.L
00002E08  011C      
00002E0A  42B9 0B00 5193          clr.l     _a5.L
00002E0E  0118      
00002E10  42B9 0B00 5194          clr.l     _a4.L
00002E14  0114      
00002E16  42B9 0B00 5195          clr.l     _a3.L
00002E1A  0110      
00002E1C  42B9 0B00 5196          clr.l     _a2.L
00002E20  010C      
00002E22  42B9 0B00 5197          clr.l     _a1.L
00002E26  0108      
00002E28  42B9 0B00 5198          clr.l     _a0.L
00002E2C  0104      
                    5199   ; PC = ProgramStart, SSP=TopOfStack, USP = TopOfStack;
00002E2E  23FC 0800 5200          move.l    #134217728,_PC.L
00002E32  0000 0B00 
00002E36  0120      
00002E38  23FC 0C00 5201          move.l    #201326592,_SSP.L
00002E3C  0000 0B00 
00002E40  0124      
00002E42  23FC 0C00 5202          move.l    #201326592,_USP.L
00002E46  0000 0B00 
00002E4A  0128      
                    5203   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
00002E4C  33FC 2000 5204          move.w    #8192,_SR.L
00002E50  0B00 012C 
                    5205   ; // Initialise Breakpoint variables
                    5206   ; for(i = 0; i < 8; i++)  {
00002E54  4282      5207          clr.l     D2
                    5208   main_1:
00002E56  0C82 0000 5209          cmp.l     #8,D2
00002E5A  0008      
00002E5C  6C00 004C 5210          bge       main_3
                    5211   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
00002E60  2002      5212          move.l    D2,D0
00002E62  E588      5213          lsl.l     #2,D0
00002E64  41F9 0B00 5214          lea       _BreakPointAddress.L,A0
00002E68  012E      
00002E6A  42B0 0800 5215          clr.l     0(A0,D0.L)
                    5216   ; WatchPointAddress[i] = 0 ;
00002E6E  2002      5217          move.l    D2,D0
00002E70  E588      5218          lsl.l     #2,D0
00002E72  41F9 0B00 5219          lea       _WatchPointAddress.L,A0
00002E76  0182      
00002E78  42B0 0800 5220          clr.l     0(A0,D0.L)
                    5221   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
00002E7C  2002      5222          move.l    D2,D0
00002E7E  E388      5223          lsl.l     #1,D0
00002E80  41F9 0B00 5224          lea       _BreakPointInstruction.L,A0
00002E84  014E      
00002E86  4270 0800 5225          clr.w     0(A0,D0.L)
                    5226   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
00002E8A  2002      5227          move.l    D2,D0
00002E8C  E588      5228          lsl.l     #2,D0
00002E8E  41F9 0B00 5229          lea       _BreakPointSetOrCleared.L,A0
00002E92  015E      
00002E94  42B0 0800 5230          clr.l     0(A0,D0.L)
                    5231   ; WatchPointSetOrCleared[i] = 0;
00002E98  2002      5232          move.l    D2,D0
00002E9A  E588      5233          lsl.l     #2,D0
00002E9C  41F9 0B00 5234          lea       _WatchPointSetOrCleared.L,A0
00002EA0  01A2      
00002EA2  42B0 0800 5235          clr.l     0(A0,D0.L)
00002EA6  5282      5236          addq.l    #1,D2
00002EA8  60AC      5237          bra       main_1
                    5238   main_3:
                    5239   ; }
                    5240   ; Init_RS232() ;     // initialise the RS232 port
00002EAA  4EB8 0B12 5241          jsr       _Init_RS232
                    5242   ; Init_LCD() ;
00002EAE  4EB8 095E 5243          jsr       _Init_LCD
                    5244   ; for( i = 32; i < 48; i++)
00002EB2  7420      5245          moveq     #32,D2
                    5246   main_4:
00002EB4  0C82 0000 5247          cmp.l     #48,D2
00002EB8  0030      
00002EBA  6C0E      5248          bge.s     main_6
                    5249   ; InstallExceptionHandler(UnhandledTrap, i) ;		        // install Trap exception handler on vector 32-47
00002EBC  2F02      5250          move.l    D2,-(A7)
00002EBE  4878 2A76 5251          pea       _UnhandledTrap.L
00002EC2  4E92      5252          jsr       (A2)
00002EC4  504F      5253          addq.w    #8,A7
00002EC6  5282      5254          addq.l    #1,D2
00002EC8  60EA      5255          bra       main_4
                    5256   main_6:
                    5257   ; InstallExceptionHandler(menu, 47) ;		                   // TRAP #15 call debug and end program
00002ECA  4878 002F 5258          pea       47
00002ECE  4878 2750 5259          pea       _menu.L
00002ED2  4E92      5260          jsr       (A2)
00002ED4  504F      5261          addq.w    #8,A7
                    5262   ; InstallExceptionHandler(UnhandledIRQ1, 25) ;		      // install handler for interrupts
00002ED6  4878 0019 5263          pea       25
00002EDA  4878 2A1C 5264          pea       _UnhandledIRQ1.L
00002EDE  4E92      5265          jsr       (A2)
00002EE0  504F      5266          addq.w    #8,A7
                    5267   ; InstallExceptionHandler(UnhandledIRQ2, 26) ;		      // install handler for interrupts
00002EE2  4878 001A 5268          pea       26
00002EE6  4878 2A28 5269          pea       _UnhandledIRQ2.L
00002EEA  4E92      5270          jsr       (A2)
00002EEC  504F      5271          addq.w    #8,A7
                    5272   ; InstallExceptionHandler(UnhandledIRQ3, 27) ;		      // install handler for interrupts
00002EEE  4878 001B 5273          pea       27
00002EF2  4878 2A34 5274          pea       _UnhandledIRQ3.L
00002EF6  4E92      5275          jsr       (A2)
00002EF8  504F      5276          addq.w    #8,A7
                    5277   ; InstallExceptionHandler(UnhandledIRQ4, 28) ;		      // install handler for interrupts
00002EFA  4878 001C 5278          pea       28
00002EFE  4878 2A40 5279          pea       _UnhandledIRQ4.L
00002F02  4E92      5280          jsr       (A2)
00002F04  504F      5281          addq.w    #8,A7
                    5282   ; InstallExceptionHandler(UnhandledIRQ5, 29) ;		      // install handler for interrupts
00002F06  4878 001D 5283          pea       29
00002F0A  4878 2A4C 5284          pea       _UnhandledIRQ5.L
00002F0E  4E92      5285          jsr       (A2)
00002F10  504F      5286          addq.w    #8,A7
                    5287   ; InstallExceptionHandler(UnhandledIRQ6, 30) ;		      // install handler for interrupts
00002F12  4878 001E 5288          pea       30
00002F16  4878 2A58 5289          pea       _UnhandledIRQ6.L
00002F1A  4E92      5290          jsr       (A2)
00002F1C  504F      5291          addq.w    #8,A7
                    5292   ; InstallExceptionHandler(UnhandledIRQ7, 31) ;		      // install handler for interrupts
00002F1E  4878 001F 5293          pea       31
00002F22  4878 2A6A 5294          pea       _UnhandledIRQ7.L
00002F26  4E92      5295          jsr       (A2)
00002F28  504F      5296          addq.w    #8,A7
                    5297   ; InstallExceptionHandler(HandleBreakPoint, 46) ;		           // install Trap 14 Break Point exception handler on vector 46
00002F2A  4878 002E 5298          pea       46
00002F2E  4878 2442 5299          pea       _HandleBreakPoint.L
00002F32  4E92      5300          jsr       (A2)
00002F34  504F      5301          addq.w    #8,A7
                    5302   ; InstallExceptionHandler(DumpRegistersandPause, 29) ;		   // install TRACE handler for IRQ5 on vector 29
00002F36  4878 001D 5303          pea       29
00002F3A  4878 1AE6 5304          pea       _DumpRegistersandPause.L
00002F3E  4E92      5305          jsr       (A2)
00002F40  504F      5306          addq.w    #8,A7
                    5307   ; InstallExceptionHandler(BusError,2) ;                          // install Bus error handler
00002F42  4878 0002 5308          pea       2
00002F46  4878 2A84 5309          pea       _BusError.L
00002F4A  4E92      5310          jsr       (A2)
00002F4C  504F      5311          addq.w    #8,A7
                    5312   ; InstallExceptionHandler(AddressError,3) ;                      // install address error handler (doesn't work on soft core 68k implementation)
00002F4E  4878 0003 5313          pea       3
00002F52  4878 2A92 5314          pea       _AddressError.L
00002F56  4E92      5315          jsr       (A2)
00002F58  504F      5316          addq.w    #8,A7
                    5317   ; InstallExceptionHandler(IllegalInstruction,4) ;                // install illegal instruction exception handler
00002F5A  4878 0004 5318          pea       4
00002F5E  4878 2AA0 5319          pea       _IllegalInstruction.L
00002F62  4E92      5320          jsr       (A2)
00002F64  504F      5321          addq.w    #8,A7
                    5322   ; InstallExceptionHandler(Dividebyzero,5) ;                      // install /0 exception handler
00002F66  4878 0005 5323          pea       5
00002F6A  4878 2AAE 5324          pea       _Dividebyzero.L
00002F6E  4E92      5325          jsr       (A2)
00002F70  504F      5326          addq.w    #8,A7
                    5327   ; InstallExceptionHandler(Check,6) ;                             // install check instruction exception handler
00002F72  4878 0006 5328          pea       6
00002F76  4878 2ABC 5329          pea       _Check.L
00002F7A  4E92      5330          jsr       (A2)
00002F7C  504F      5331          addq.w    #8,A7
                    5332   ; InstallExceptionHandler(Trapv,7) ;                             // install trapv instruction exception handler
00002F7E  4878 0007 5333          pea       7
00002F82  4878 2ACA 5334          pea       _Trapv.L
00002F86  4E92      5335          jsr       (A2)
00002F88  504F      5336          addq.w    #8,A7
                    5337   ; InstallExceptionHandler(PrivError,8) ;                         // install Priv Violation exception handler
00002F8A  4878 0008 5338          pea       8
00002F8E  4878 2AD8 5339          pea       _PrivError.L
00002F92  4E92      5340          jsr       (A2)
00002F94  504F      5341          addq.w    #8,A7
                    5342   ; InstallExceptionHandler(UnitIRQ,15) ;                          // install uninitialised IRQ exception handler
00002F96  4878 000F 5343          pea       15
00002F9A  4878 2AE6 5344          pea       _UnitIRQ.L
00002F9E  4E92      5345          jsr       (A2)
00002FA0  504F      5346          addq.w    #8,A7
                    5347   ; InstallExceptionHandler(Check,24) ;                            // install spurious IRQ exception handler
00002FA2  4878 0018 5348          pea       24
00002FA6  4878 2ABC 5349          pea       _Check.L
00002FAA  4E92      5350          jsr       (A2)
00002FAC  504F      5351          addq.w    #8,A7
                    5352   ; FlushKeyboard() ;                        // dump unread characters from keyboard
00002FAE  4EB8 0BA6 5353          jsr       _FlushKeyboard
                    5354   ; TraceException = 0 ;                     // clear trace exception port to remove any software generated single step/trace
00002FB2  4239 0040 5355          clr.b     4194314
00002FB6  000A      
                    5356   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    5357   ; while(((char)(PortB & 0x02)) == (char)(0x02))    {
                    5358   main_7:
00002FB8  1039 0040 5359          move.b    4194306,D0
00002FBC  0002      
00002FBE  C03C 0002 5360          and.b     #2,D0
00002FC2  0C00 0002 5361          cmp.b     #2,D0
00002FC6  662A      5362          bne.s     main_9
                    5363   ; LoadFromFlashChip();
00002FC8  4EB8 14F8 5364          jsr       _LoadFromFlashChip
                    5365   ; printf("\r\nRunning.....") ;
00002FCC  4879 0000 5366          pea       @m68kde~2_164.L
00002FD0  763E      
00002FD2  4E93      5367          jsr       (A3)
00002FD4  584F      5368          addq.w    #4,A7
                    5369   ; Oline1("Running.....") ;
00002FD6  4879 0000 5370          pea       @m68kde~2_165.L
00002FDA  764E      
00002FDC  4EB8 0A02 5371          jsr       _Oline1
00002FE0  584F      5372          addq.w    #4,A7
                    5373   ; GoFlag = 1;
00002FE2  23FC 0000 5374          move.l    #1,_GoFlag.L
00002FE6  0001 0B00 
00002FEA  00DC      
                    5375   ; go() ;
00002FEC  4EB8 08B8 5376          jsr       _go
00002FF0  60C6      5377          bra       main_7
                    5378   main_9:
                    5379   ; }
                    5380   ; // otherwise start the debug monitor
                    5381   ; Oline0(BugMessage) ;
00002FF2  2F03      5382          move.l    D3,-(A7)
00002FF4  4EB8 09D4 5383          jsr       _Oline0
00002FF8  584F      5384          addq.w    #4,A7
                    5385   ; Oline1("By: PJ Davies") ;
00002FFA  4879 0000 5386          pea       @m68kde~2_166.L
00002FFE  765C      
00003000  4EB8 0A02 5387          jsr       _Oline1
00003004  584F      5388          addq.w    #4,A7
                    5389   ; printf("\r\n%s", BugMessage) ;
00003006  2F03      5390          move.l    D3,-(A7)
00003008  4879 0000 5391          pea       @m68kde~2_167.L
0000300C  766A      
0000300E  4E93      5392          jsr       (A3)
00003010  504F      5393          addq.w    #8,A7
                    5394   ; printf("\r\n%s", CopyrightMessage) ;
00003012  2F2E FFFC 5395          move.l    -4(A6),-(A7)
00003016  4879 0000 5396          pea       @m68kde~2_167.L
0000301A  766A      
0000301C  4E93      5397          jsr       (A3)
0000301E  504F      5398          addq.w    #8,A7
                    5399   ; menu();
00003020  4EB8 2750 5400          jsr       _menu
00003024  4CDF 0C0C 5401          movem.l   (A7)+,D2/D3/A2/A3
00003028  4E5E      5402          unlk      A6
0000302A  4E75      5403          rts
                    5404   ; }
                    5405   ; void FormatInstruction(void)    // for disassembly
                    5406   ; {
                    5407   _FormatInstruction:
0000302C  4E56 FEC0 5408          link      A6,#-320
00003030  48E7 3C20 5409          movem.l   D2/D3/D4/D5/A2,-(A7)
00003034  45EE FEC0 5410          lea       -320(A6),A2
                    5411   ; short i, ilen = 0 ;
00003038  4245      5412          clr.w     D5
                    5413   ; char *iptr = Instruction ;
0000303A  41F9 0B00 5414          lea       _Instruction.L,A0
0000303E  04E2      
00003040  2608      5415          move.l    A0,D3
                    5416   ; char *Formatted[80], *fptr ;
                    5417   ; fptr = Formatted ;
00003042  280A      5418          move.l    A2,D4
                    5419   ; for(i = 0; i < (short)(80); i ++)
00003044  4242      5420          clr.w     D2
                    5421   FormatInstruction_1:
00003046  0C42 0050 5422          cmp.w     #80,D2
0000304A  6C0E      5423          bge.s     FormatInstruction_3
                    5424   ; Formatted[i] = (char)(0);          // set formatted string to null
0000304C  48C2      5425          ext.l     D2
0000304E  2002      5426          move.l    D2,D0
00003050  E588      5427          lsl.l     #2,D0
00003052  42B2 0800 5428          clr.l     0(A2,D0.L)
00003056  5242      5429          addq.w    #1,D2
00003058  60EC      5430          bra       FormatInstruction_1
                    5431   FormatInstruction_3:
                    5432   ; while((*iptr != ' '))   {   // while ot a space char
                    5433   FormatInstruction_4:
0000305A  2043      5434          move.l    D3,A0
0000305C  1010      5435          move.b    (A0),D0
0000305E  0C00 0020 5436          cmp.b     #32,D0
00003062  6718      5437          beq.s     FormatInstruction_6
                    5438   ; *fptr++ = *iptr++ ;     // copy string until space or end encountered
00003064  2043      5439          move.l    D3,A0
00003066  5283      5440          addq.l    #1,D3
00003068  2244      5441          move.l    D4,A1
0000306A  5284      5442          addq.l    #1,D4
0000306C  1290      5443          move.b    (A0),(A1)
                    5444   ; ilen ++ ;               // count length of string as we go
0000306E  5245      5445          addq.w    #1,D5
                    5446   ; if(*iptr == 0)          // if we got the end and copied the NUL then return
00003070  2043      5447          move.l    D3,A0
00003072  1010      5448          move.b    (A0),D0
00003074  6604      5449          bne.s     FormatInstruction_7
                    5450   ; return ;
00003076  6000 003E 5451          bra       FormatInstruction_9
                    5452   FormatInstruction_7:
0000307A  60DE      5453          bra       FormatInstruction_4
                    5454   FormatInstruction_6:
                    5455   ; }
                    5456   ; // must still be more text to process otherwise we would have returned above if got to the end
                    5457   ; for(i = 0; i < ((short)(8) - ilen); i++)
0000307C  4242      5458          clr.w     D2
                    5459   FormatInstruction_10:
0000307E  7008      5460          moveq     #8,D0
00003080  4880      5461          ext.w     D0
00003082  9045      5462          sub.w     D5,D0
00003084  B440      5463          cmp.w     D0,D2
00003086  6C0C      5464          bge.s     FormatInstruction_12
                    5465   ; *fptr++ = ' ' ;        // make sure first operand appears in field 8 of formatted string
00003088  2044      5466          move.l    D4,A0
0000308A  5284      5467          addq.l    #1,D4
0000308C  10BC 0020 5468          move.b    #32,(A0)
00003090  5242      5469          addq.w    #1,D2
00003092  60EA      5470          bra       FormatInstruction_10
                    5471   FormatInstruction_12:
                    5472   ; // now skip over any spaces in original unformatted string before copying the rest
                    5473   ; while((*iptr == ' '))
                    5474   FormatInstruction_13:
00003094  2043      5475          move.l    D3,A0
00003096  1010      5476          move.b    (A0),D0
00003098  0C00 0020 5477          cmp.b     #32,D0
0000309C  6604      5478          bne.s     FormatInstruction_15
                    5479   ; iptr++ ;
0000309E  5283      5480          addq.l    #1,D3
000030A0  60F2      5481          bra       FormatInstruction_13
                    5482   FormatInstruction_15:
                    5483   ; strcat(fptr,iptr) ;
000030A2  2F03      5484          move.l    D3,-(A7)
000030A4  2F04      5485          move.l    D4,-(A7)
000030A6  4EB9 0000 5486          jsr       _strcat
000030AA  5A62      
000030AC  504F      5487          addq.w    #8,A7
                    5488   ; strcpyInstruction(Formatted) ;
000030AE  2F0A      5489          move.l    A2,-(A7)
000030B0  4EB8 0CE6 5490          jsr       _strcpyInstruction
000030B4  584F      5491          addq.w    #4,A7
                    5492   FormatInstruction_9:
000030B6  4CDF 043C 5493          movem.l   (A7)+,D2/D3/D4/D5/A2
000030BA  4E5E      5494          unlk      A6
000030BC  4E75      5495          rts
                    5496   ; }
                    5497   ; unsigned short int Decode2BitOperandSize(unsigned short int OpCode)
                    5498   ; {
                    5499   _Decode2BitOperandSize:
000030BE  4E56 0000 5500          link      A6,#0
000030C2  48E7 3020 5501          movem.l   D2/D3/A2,-(A7)
000030C6  362E 000A 5502          move.w    10(A6),D3
000030CA  C6BC 0000 5503          and.l     #65535,D3
000030CE  FFFF      
000030D0  45F8 0CCC 5504          lea       _strcatInstruction.L,A2
                    5505   ; unsigned short int DataSize ;       // used to determine the size of data following say an immediate instruction such as addi etc
                    5506   ; OpCode = (OpCode & (unsigned short int)(0x00C0)) >> 6 ;             // get bits 7 and 6 into positions 1,0
000030D4  3003      5507          move.w    D3,D0
000030D6  C07C 00C0 5508          and.w     #192,D0
000030DA  EC48      5509          lsr.w     #6,D0
000030DC  3600      5510          move.w    D0,D3
                    5511   ; if(OpCode == (unsigned short int)(0))   {
000030DE  4A43      5512          tst.w     D3
000030E0  660E      5513          bne.s     Decode2BitOperandSize_1
                    5514   ; strcatInstruction(".B ") ;
000030E2  4879 0000 5515          pea       @m68kde~2_168.L
000030E6  7670      
000030E8  4E92      5516          jsr       (A2)
000030EA  584F      5517          addq.w    #4,A7
                    5518   ; DataSize = 1 ;
000030EC  7401      5519          moveq     #1,D2
000030EE  6020      5520          bra.s     Decode2BitOperandSize_4
                    5521   Decode2BitOperandSize_1:
                    5522   ; }
                    5523   ; else if(OpCode == (unsigned short int)(1)) {
000030F0  0C43 0001 5524          cmp.w     #1,D3
000030F4  660E      5525          bne.s     Decode2BitOperandSize_3
                    5526   ; strcatInstruction(".W ") ;
000030F6  4879 0000 5527          pea       @m68kde~2_169.L
000030FA  7674      
000030FC  4E92      5528          jsr       (A2)
000030FE  584F      5529          addq.w    #4,A7
                    5530   ; DataSize = 1 ;
00003100  7401      5531          moveq     #1,D2
00003102  600C      5532          bra.s     Decode2BitOperandSize_4
                    5533   Decode2BitOperandSize_3:
                    5534   ; }
                    5535   ; else {
                    5536   ; strcatInstruction(".L ") ;
00003104  4879 0000 5537          pea       @m68kde~2_170.L
00003108  7678      
0000310A  4E92      5538          jsr       (A2)
0000310C  584F      5539          addq.w    #4,A7
                    5540   ; DataSize = 2 ;
0000310E  7402      5541          moveq     #2,D2
                    5542   Decode2BitOperandSize_4:
                    5543   ; }
                    5544   ; return DataSize;
00003110  3002      5545          move.w    D2,D0
00003112  4CDF 040C 5546          movem.l   (A7)+,D2/D3/A2
00003116  4E5E      5547          unlk      A6
00003118  4E75      5548          rts
                    5549   ; }
                    5550   ; void Decode3BitDataRegister(unsigned short int OpCode)                // Data Register in Bits 11, 10 and 9
                    5551   ; {
                    5552   _Decode3BitDataRegister:
0000311A  4E56 FFFC 5553          link      A6,#-4
0000311E  2F0A      5554          move.l    A2,-(A7)
00003120  45EE FFFC 5555          lea       -4(A6),A2
                    5556   ; unsigned char RegNumber[3] ;
                    5557   ; RegNumber[0] = 'D' ;
00003124  14BC 0044 5558          move.b    #68,(A2)
                    5559   ; RegNumber[1] = (unsigned char)(0x30) + (unsigned char)((OpCode & 0x0E00) >> 9) ;   // get data register number in bits 2,1,0 and convert to ASCII equiv
00003128  7030      5560          moveq     #48,D0
0000312A  322E 000A 5561          move.w    10(A6),D1
0000312E  C27C 0E00 5562          and.w     #3584,D1
00003132  E049      5563          lsr.w     #8,D1
00003134  E249      5564          lsr.w     #1,D1
00003136  D001      5565          add.b     D1,D0
00003138  1540 0001 5566          move.b    D0,1(A2)
                    5567   ; RegNumber[2] = 0 ;
0000313C  422A 0002 5568          clr.b     2(A2)
                    5569   ; strcatInstruction(RegNumber) ;        // write register number to the disassembled instruction
00003140  2F0A      5570          move.l    A2,-(A7)
00003142  4EB8 0CCC 5571          jsr       _strcatInstruction
00003146  584F      5572          addq.w    #4,A7
00003148  245F      5573          move.l    (A7)+,A2
0000314A  4E5E      5574          unlk      A6
0000314C  4E75      5575          rts
                    5576   ; }
                    5577   ; void Decode3BitAddressRegister(unsigned short int Reg)                // Address Register in Bits 2,1,0
                    5578   ; {
                    5579   _Decode3BitAddressRegister:
0000314E  4E56 FFFC 5580          link      A6,#-4
00003152  2F0A      5581          move.l    A2,-(A7)
00003154  45EE FFFC 5582          lea       -4(A6),A2
                    5583   ; unsigned char RegNumber[3];
                    5584   ; RegNumber[0] = 'A' ;
00003158  14BC 0041 5585          move.b    #65,(A2)
                    5586   ; RegNumber[1] = (unsigned char)(0x30) + (unsigned char)(Reg) ;   // get data register number in bits 2,1,0 and convert to ASCII equiv
0000315C  7030      5587          moveq     #48,D0
0000315E  322E 000A 5588          move.w    10(A6),D1
00003162  D001      5589          add.b     D1,D0
00003164  1540 0001 5590          move.b    D0,1(A2)
                    5591   ; RegNumber[2] = 0 ;
00003168  422A 0002 5592          clr.b     2(A2)
                    5593   ; strcatInstruction(RegNumber) ;        // write register number to the disassembled instruction
0000316C  2F0A      5594          move.l    A2,-(A7)
0000316E  4EB8 0CCC 5595          jsr       _strcatInstruction
00003172  584F      5596          addq.w    #4,A7
00003174  245F      5597          move.l    (A7)+,A2
00003176  4E5E      5598          unlk      A6
00003178  4E75      5599          rts
                    5600   ; }
                    5601   ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5602   ; // Special function is used to print 8,16, 32 bit operands after move #
                    5603   ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5604   ; void DecodeBWLDataAfterOpCodeForMove(unsigned short int *OpCode )
                    5605   ; {
                    5606   _DecodeBWLDataAfterOpCodeForMove:
0000317A  4E56 0000 5607          link      A6,#0
0000317E  48E7 3030 5608          movem.l   D2/D3/A2/A3,-(A7)
00003182  242E 0008 5609          move.l    8(A6),D2
00003186  45F9 0B00 5610          lea       _TempString.L,A2
0000318A  0546      
0000318C  47F9 0000 5611          lea       _sprintf.L,A3
00003190  5A2E      
                    5612   ; unsigned char OperandSize ;
                    5613   ; OperandSize = (*OpCode >> 12) & (unsigned short int)(0x0003) ;               // get bits 13,12 into 1,0 as these define size of #operand
00003192  2042      5614          move.l    D2,A0
00003194  3010      5615          move.w    (A0),D0
00003196  E048      5616          lsr.w     #8,D0
00003198  E848      5617          lsr.w     #4,D0
0000319A  C07C 0003 5618          and.w     #3,D0
0000319E  1600      5619          move.b    D0,D3
                    5620   ; InstructionSize += 1;
000031A0  52B9 0B00 5621          addq.l    #1,_InstructionSize.L
000031A4  017E      
                    5622   ; if(OperandSize == (char)(1))                // #byte value
000031A6  0C03 0001 5623          cmp.b     #1,D3
000031AA  6620      5624          bne.s     DecodeBWLDataAfterOpCodeForMove_1
                    5625   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
000031AC  2042      5626          move.l    D2,A0
000031AE  3228 0002 5627          move.w    2(A0),D1
000031B2  C2BC 0000 5628          and.l     #65535,D1
000031B6  FFFF      
000031B8  2F01      5629          move.l    D1,-(A7)
000031BA  4879 0000 5630          pea       @m68kde~2_171.L
000031BE  767C      
000031C0  2F0A      5631          move.l    A2,-(A7)
000031C2  4E93      5632          jsr       (A3)
000031C4  DEFC 000C 5633          add.w     #12,A7
000031C8  6000 0068 5634          bra       DecodeBWLDataAfterOpCodeForMove_5
                    5635   DecodeBWLDataAfterOpCodeForMove_1:
                    5636   ; else if(OperandSize == (char)(3))          // #word value
000031CC  0C03 0003 5637          cmp.b     #3,D3
000031D0  6620      5638          bne.s     DecodeBWLDataAfterOpCodeForMove_3
                    5639   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
000031D2  2042      5640          move.l    D2,A0
000031D4  3228 0002 5641          move.w    2(A0),D1
000031D8  C2BC 0000 5642          and.l     #65535,D1
000031DC  FFFF      
000031DE  2F01      5643          move.l    D1,-(A7)
000031E0  4879 0000 5644          pea       @m68kde~2_171.L
000031E4  767C      
000031E6  2F0A      5645          move.l    A2,-(A7)
000031E8  4E93      5646          jsr       (A3)
000031EA  DEFC 000C 5647          add.w     #12,A7
000031EE  6000 0042 5648          bra       DecodeBWLDataAfterOpCodeForMove_5
                    5649   DecodeBWLDataAfterOpCodeForMove_3:
                    5650   ; else if(OperandSize == (char)(2)) {                                       // long value
000031F2  0C03 0002 5651          cmp.b     #2,D3
000031F6  6600 003A 5652          bne       DecodeBWLDataAfterOpCodeForMove_5
                    5653   ; sprintf(TempString, "#$%X", ((unsigned int)(OpCode[1]) << 16) | (unsigned int)(OpCode[2])); // create 3
000031FA  2042      5654          move.l    D2,A0
000031FC  3228 0002 5655          move.w    2(A0),D1
00003200  C2BC 0000 5656          and.l     #65535,D1
00003204  FFFF      
00003206  E189      5657          lsl.l     #8,D1
00003208  E189      5658          lsl.l     #8,D1
0000320A  2042      5659          move.l    D2,A0
0000320C  2F00      5660          move.l    D0,-(A7)
0000320E  3028 0004 5661          move.w    4(A0),D0
00003212  C0BC 0000 5662          and.l     #65535,D0
00003216  FFFF      
00003218  8280      5663          or.l      D0,D1
0000321A  201F      5664          move.l    (A7)+,D0
0000321C  2F01      5665          move.l    D1,-(A7)
0000321E  4879 0000 5666          pea       @m68kde~2_171.L
00003222  767C      
00003224  2F0A      5667          move.l    A2,-(A7)
00003226  4E93      5668          jsr       (A3)
00003228  DEFC 000C 5669          add.w     #12,A7
                    5670   ; InstructionSize += 1;
0000322C  52B9 0B00 5671          addq.l    #1,_InstructionSize.L
00003230  017E      
                    5672   DecodeBWLDataAfterOpCodeForMove_5:
                    5673   ; }
                    5674   ; strcatInstruction(TempString) ;
00003232  2F0A      5675          move.l    A2,-(A7)
00003234  4EB8 0CCC 5676          jsr       _strcatInstruction
00003238  584F      5677          addq.w    #4,A7
0000323A  4CDF 0C0C 5678          movem.l   (A7)+,D2/D3/A2/A3
0000323E  4E5E      5679          unlk      A6
00003240  4E75      5680          rts
                    5681   ; }
                    5682   ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5683   ; // This function is used to print 8,16, 32 bit operands after the opcode, this is in instruction like ADD # where immediate addressing is used as source
                    5684   ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5685   ; void DecodeBWLDataAfterOpCode(unsigned short int *OpCode )
                    5686   ; {
                    5687   _DecodeBWLDataAfterOpCode:
00003242  4E56 0000 5688          link      A6,#0
00003246  48E7 3038 5689          movem.l   D2/D3/A2/A3/A4,-(A7)
0000324A  262E 0008 5690          move.l    8(A6),D3
0000324E  45F9 0B00 5691          lea       _TempString.L,A2
00003252  0546      
00003254  47F9 0000 5692          lea       _sprintf.L,A3
00003258  5A2E      
0000325A  49F9 0B00 5693          lea       _InstructionSize.L,A4
0000325E  017E      
                    5694   ; unsigned char OperandSize ;
                    5695   ; OperandSize = (*OpCode & (unsigned short int)(0x01C0)) >> 6 ;               // get bits 8,7 and 6 into positions 1,0, these define size of operand
00003260  2043      5696          move.l    D3,A0
00003262  3010      5697          move.w    (A0),D0
00003264  C07C 01C0 5698          and.w     #448,D0
00003268  EC48      5699          lsr.w     #6,D0
0000326A  1400      5700          move.b    D0,D2
                    5701   ; InstructionSize += 1;
0000326C  5294      5702          addq.l    #1,(A4)
                    5703   ; if((OperandSize == (char)(0)) || (OperandSize == (char)(4)))                // #byte value
0000326E  4A02      5704          tst.b     D2
00003270  6706      5705          beq.s     DecodeBWLDataAfterOpCode_3
00003272  0C02 0004 5706          cmp.b     #4,D2
00003276  6620      5707          bne.s     DecodeBWLDataAfterOpCode_1
                    5708   DecodeBWLDataAfterOpCode_3:
                    5709   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
00003278  2043      5710          move.l    D3,A0
0000327A  3228 0002 5711          move.w    2(A0),D1
0000327E  C2BC 0000 5712          and.l     #65535,D1
00003282  FFFF      
00003284  2F01      5713          move.l    D1,-(A7)
00003286  4879 0000 5714          pea       @m68kde~2_171.L
0000328A  767C      
0000328C  2F0A      5715          move.l    A2,-(A7)
0000328E  4E93      5716          jsr       (A3)
00003290  DEFC 000C 5717          add.w     #12,A7
00003294  6000 007C 5718          bra       DecodeBWLDataAfterOpCode_7
                    5719   DecodeBWLDataAfterOpCode_1:
                    5720   ; // #word value 7 is used by divs.w instruction (not divu)
                    5721   ; // however used by instructions like adda, cmpa, suba # to mean long value -
                    5722   ; // bugger - have to build a special case and look at opcode to see what instruction is
                    5723   ; else if((OperandSize == (char)(1)) || (OperandSize == (char)(5)) || (OperandSize == (char)(3)))         //# byte or word value
00003298  0C02 0001 5724          cmp.b     #1,D2
0000329C  670C      5725          beq.s     DecodeBWLDataAfterOpCode_6
0000329E  0C02 0005 5726          cmp.b     #5,D2
000032A2  6706      5727          beq.s     DecodeBWLDataAfterOpCode_6
000032A4  0C02 0003 5728          cmp.b     #3,D2
000032A8  6620      5729          bne.s     DecodeBWLDataAfterOpCode_4
                    5730   DecodeBWLDataAfterOpCode_6:
                    5731   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
000032AA  2043      5732          move.l    D3,A0
000032AC  3228 0002 5733          move.w    2(A0),D1
000032B0  C2BC 0000 5734          and.l     #65535,D1
000032B4  FFFF      
000032B6  2F01      5735          move.l    D1,-(A7)
000032B8  4879 0000 5736          pea       @m68kde~2_171.L
000032BC  767C      
000032BE  2F0A      5737          move.l    A2,-(A7)
000032C0  4E93      5738          jsr       (A3)
000032C2  DEFC 000C 5739          add.w     #12,A7
000032C6  6000 004A 5740          bra       DecodeBWLDataAfterOpCode_7
                    5741   DecodeBWLDataAfterOpCode_4:
                    5742   ; else if((OperandSize == (char)(2))  || (OperandSize == (char)(6)) || (OperandSize == (char)(7)))    {    //# long value
000032CA  0C02 0002 5743          cmp.b     #2,D2
000032CE  670E      5744          beq.s     DecodeBWLDataAfterOpCode_9
000032D0  0C02 0006 5745          cmp.b     #6,D2
000032D4  6708      5746          beq.s     DecodeBWLDataAfterOpCode_9
000032D6  0C02 0007 5747          cmp.b     #7,D2
000032DA  6600 0036 5748          bne       DecodeBWLDataAfterOpCode_7
                    5749   DecodeBWLDataAfterOpCode_9:
                    5750   ; sprintf(TempString, "#$%X", ((unsigned int)(OpCode[1]) << 16) | (unsigned int)(OpCode[2]) ); // create 3
000032DE  2043      5751          move.l    D3,A0
000032E0  3228 0002 5752          move.w    2(A0),D1
000032E4  C2BC 0000 5753          and.l     #65535,D1
000032E8  FFFF      
000032EA  E189      5754          lsl.l     #8,D1
000032EC  E189      5755          lsl.l     #8,D1
000032EE  2043      5756          move.l    D3,A0
000032F0  2F00      5757          move.l    D0,-(A7)
000032F2  3028 0004 5758          move.w    4(A0),D0
000032F6  C0BC 0000 5759          and.l     #65535,D0
000032FA  FFFF      
000032FC  8280      5760          or.l      D0,D1
000032FE  201F      5761          move.l    (A7)+,D0
00003300  2F01      5762          move.l    D1,-(A7)
00003302  4879 0000 5763          pea       @m68kde~2_171.L
00003306  767C      
00003308  2F0A      5764          move.l    A2,-(A7)
0000330A  4E93      5765          jsr       (A3)
0000330C  DEFC 000C 5766          add.w     #12,A7
                    5767   ; InstructionSize += 1;
00003310  5294      5768          addq.l    #1,(A4)
                    5769   DecodeBWLDataAfterOpCode_7:
                    5770   ; }
                    5771   ; // special case for divs - bugger!!!
                    5772   ; if((*OpCode & (unsigned short int)(0xF1C0)) == (unsigned short int)(0x81C0)) // it's the divs instruction
00003312  2043      5773          move.l    D3,A0
00003314  3010      5774          move.w    (A0),D0
00003316  C07C F1C0 5775          and.w     #61888,D0
0000331A  0C40 81C0 5776          cmp.w     #33216,D0
0000331E  6622      5777          bne.s     DecodeBWLDataAfterOpCode_10
                    5778   ; {
                    5779   ; InstructionSize = 2 ;
00003320  28BC 0000 5780          move.l    #2,(A4)
00003324  0002      
                    5781   ; sprintf(TempString, "#$%X", (unsigned int)(OpCode[1]));
00003326  2043      5782          move.l    D3,A0
00003328  3228 0002 5783          move.w    2(A0),D1
0000332C  C2BC 0000 5784          and.l     #65535,D1
00003330  FFFF      
00003332  2F01      5785          move.l    D1,-(A7)
00003334  4879 0000 5786          pea       @m68kde~2_171.L
00003338  767C      
0000333A  2F0A      5787          move.l    A2,-(A7)
0000333C  4E93      5788          jsr       (A3)
0000333E  DEFC 000C 5789          add.w     #12,A7
                    5790   DecodeBWLDataAfterOpCode_10:
                    5791   ; }
                    5792   ; strcatInstruction(TempString) ;
00003342  2F0A      5793          move.l    A2,-(A7)
00003344  4EB8 0CCC 5794          jsr       _strcatInstruction
00003348  584F      5795          addq.w    #4,A7
0000334A  4CDF 1C0C 5796          movem.l   (A7)+,D2/D3/A2/A3/A4
0000334E  4E5E      5797          unlk      A6
00003350  4E75      5798          rts
                    5799   ; }
                    5800   ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5801   ; // This function decodes the MODE|EA bits opcode in bits 5,4,3,2,1,0 or 11-6
                    5802   ; // DataSize is used to gain access to the operand used by EA, e.g. ADDI  #$2344422,$234234
                    5803   ; // since the data following the opcode is actually the immediate data which could be 1 or 2 words
                    5804   ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    5805   ; void Decode6BitEA(unsigned short int *OpCode, int EAChoice, unsigned short int DataSize, unsigned short int IsItMoveInstruction)     // decode Mode/Register
                    5806   ; {
                    5807   _Decode6BitEA:
00003352  4E56 FFF4 5808          link      A6,#-12
00003356  48E7 3F3C 5809          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0000335A  45F8 0CCC 5810          lea       _strcatInstruction.L,A2
0000335E  47F9 0B00 5811          lea       _TempString.L,A3
00003362  0546      
00003364  282E 0008 5812          move.l    8(A6),D4
00003368  49F9 0000 5813          lea       _sprintf.L,A4
0000336C  5A2E      
0000336E  4BF9 0B00 5814          lea       _InstructionSize.L,A5
00003372  017E      
00003374  3C2E 0012 5815          move.w    18(A6),D6
00003378  CCBC 0000 5816          and.l     #65535,D6
0000337C  FFFF      
                    5817   ; unsigned char OperandMode, OperandRegister, OperandSize;
                    5818   ; short int ExWord1, ExWord2 ;                       // get any extra 16 bit word associated with EA
                    5819   ; unsigned char RegNumber[3];
                    5820   ; signed char offset ;
                    5821   ; unsigned short int Xn, XnSize ;
                    5822   ; if(EAChoice == 0)   {   // if EA in bits 5-0
0000337E  202E 000C 5823          move.l    12(A6),D0
00003382  6620      5824          bne.s     Decode6BitEA_1
                    5825   ; OperandMode = ((unsigned char)(*OpCode >> 3) & (unsigned short int)(0x7)) ;    // get bits 5,4,3 into position 2,1,0
00003384  2044      5826          move.l    D4,A0
00003386  3010      5827          move.w    (A0),D0
00003388  E648      5828          lsr.w     #3,D0
0000338A  C07C 00FF 5829          and.w     #255,D0
0000338E  C07C 0007 5830          and.w     #7,D0
00003392  1A00      5831          move.b    D0,D5
                    5832   ; OperandRegister = ((unsigned char)(*OpCode) & (unsigned short int)(0x7)) ;
00003394  2044      5833          move.l    D4,A0
00003396  3010      5834          move.w    (A0),D0
00003398  C07C 00FF 5835          and.w     #255,D0
0000339C  C07C 0007 5836          and.w     #7,D0
000033A0  1600      5837          move.b    D0,D3
000033A2  6022      5838          bra.s     Decode6BitEA_2
                    5839   Decode6BitEA_1:
                    5840   ; }
                    5841   ; else    {               // else EA in bits 11-6
                    5842   ; OperandMode = ((unsigned char)(*OpCode >> 6) & (unsigned short int)(0x7)) ;
000033A4  2044      5843          move.l    D4,A0
000033A6  3010      5844          move.w    (A0),D0
000033A8  EC48      5845          lsr.w     #6,D0
000033AA  C07C 00FF 5846          and.w     #255,D0
000033AE  C07C 0007 5847          and.w     #7,D0
000033B2  1A00      5848          move.b    D0,D5
                    5849   ; OperandRegister = ((unsigned char)(*OpCode >> 9) & (unsigned short int)(0x7)) ;
000033B4  2044      5850          move.l    D4,A0
000033B6  3010      5851          move.w    (A0),D0
000033B8  E048      5852          lsr.w     #8,D0
000033BA  E248      5853          lsr.w     #1,D0
000033BC  C07C 00FF 5854          and.w     #255,D0
000033C0  C07C 0007 5855          and.w     #7,D0
000033C4  1600      5856          move.b    D0,D3
                    5857   Decode6BitEA_2:
                    5858   ; }
                    5859   ; if(EAChoice == 0)    {
000033C6  202E 000C 5860          move.l    12(A6),D0
000033CA  6600 0034 5861          bne       Decode6BitEA_3
                    5862   ; ExWord1 = OpCode[1+DataSize] ;
000033CE  2044      5863          move.l    D4,A0
000033D0  7001      5864          moveq     #1,D0
000033D2  4880      5865          ext.w     D0
000033D4  48C0      5866          ext.l     D0
000033D6  CCBC 0000 5867          and.l     #65535,D6
000033DA  FFFF      
000033DC  D086      5868          add.l     D6,D0
000033DE  E388      5869          lsl.l     #1,D0
000033E0  3430 0800 5870          move.w    0(A0,D0.L),D2
                    5871   ; ExWord2 = OpCode[2+DataSize] ;
000033E4  2044      5872          move.l    D4,A0
000033E6  7002      5873          moveq     #2,D0
000033E8  4880      5874          ext.w     D0
000033EA  48C0      5875          ext.l     D0
000033EC  CCBC 0000 5876          and.l     #65535,D6
000033F0  FFFF      
000033F2  D086      5877          add.l     D6,D0
000033F4  E388      5878          lsl.l     #1,D0
000033F6  3D70 0800 5879          move.w    0(A0,D0.L),-8(A6)
000033FA  FFF8      
000033FC  6000 007E 5880          bra       Decode6BitEA_7
                    5881   Decode6BitEA_3:
                    5882   ; }
                    5883   ; else if(EAChoice == 1)   {
00003400  202E 000C 5884          move.l    12(A6),D0
00003404  0C80 0000 5885          cmp.l     #1,D0
00003408  0001      
0000340A  6600 0034 5886          bne       Decode6BitEA_5
                    5887   ; ExWord1 = OpCode[3+DataSize] ;
0000340E  2044      5888          move.l    D4,A0
00003410  7003      5889          moveq     #3,D0
00003412  4880      5890          ext.w     D0
00003414  48C0      5891          ext.l     D0
00003416  CCBC 0000 5892          and.l     #65535,D6
0000341A  FFFF      
0000341C  D086      5893          add.l     D6,D0
0000341E  E388      5894          lsl.l     #1,D0
00003420  3430 0800 5895          move.w    0(A0,D0.L),D2
                    5896   ; ExWord2 = OpCode[4+DataSize] ;
00003424  2044      5897          move.l    D4,A0
00003426  7004      5898          moveq     #4,D0
00003428  4880      5899          ext.w     D0
0000342A  48C0      5900          ext.l     D0
0000342C  CCBC 0000 5901          and.l     #65535,D6
00003430  FFFF      
00003432  D086      5902          add.l     D6,D0
00003434  E388      5903          lsl.l     #1,D0
00003436  3D70 0800 5904          move.w    0(A0,D0.L),-8(A6)
0000343A  FFF8      
0000343C  6000 003E 5905          bra       Decode6BitEA_7
                    5906   Decode6BitEA_5:
                    5907   ; }
                    5908   ; else if(EAChoice == 2)   {  // for move instruction
00003440  202E 000C 5909          move.l    12(A6),D0
00003444  0C80 0000 5910          cmp.l     #2,D0
00003448  0002      
0000344A  6600 0030 5911          bne       Decode6BitEA_7
                    5912   ; ExWord1 = OpCode[1+DataSize] ;
0000344E  2044      5913          move.l    D4,A0
00003450  7001      5914          moveq     #1,D0
00003452  4880      5915          ext.w     D0
00003454  48C0      5916          ext.l     D0
00003456  CCBC 0000 5917          and.l     #65535,D6
0000345A  FFFF      
0000345C  D086      5918          add.l     D6,D0
0000345E  E388      5919          lsl.l     #1,D0
00003460  3430 0800 5920          move.w    0(A0,D0.L),D2
                    5921   ; ExWord2 = OpCode[2+DataSize] ;
00003464  2044      5922          move.l    D4,A0
00003466  7002      5923          moveq     #2,D0
00003468  4880      5924          ext.w     D0
0000346A  48C0      5925          ext.l     D0
0000346C  CCBC 0000 5926          and.l     #65535,D6
00003470  FFFF      
00003472  D086      5927          add.l     D6,D0
00003474  E388      5928          lsl.l     #1,D0
00003476  3D70 0800 5929          move.w    0(A0,D0.L),-8(A6)
0000347A  FFF8      
                    5930   Decode6BitEA_7:
                    5931   ; }
                    5932   ; if(OperandMode == (unsigned char)(0)) {                    // Effective Address = Dn
0000347C  4A05      5933          tst.b     D5
0000347E  661E      5934          bne.s     Decode6BitEA_9
                    5935   ; RegNumber[0] = 'D' ;
00003480  1D7C 0044 5936          move.b    #68,-6+0(A6)
00003484  FFFA      
                    5937   ; RegNumber[1] = (unsigned char)(0x30 + OperandRegister) ;
00003486  7030      5938          moveq     #48,D0
00003488  D003      5939          add.b     D3,D0
0000348A  1D40 FFFB 5940          move.b    D0,-6+1(A6)
                    5941   ; RegNumber[2] = 0 ;
0000348E  422E FFFC 5942          clr.b     -6+2(A6)
                    5943   ; strcatInstruction(RegNumber) ;
00003492  486E FFFA 5944          pea       -6(A6)
00003496  4E92      5945          jsr       (A2)
00003498  584F      5946          addq.w    #4,A7
0000349A  6000 02D6 5947          bra       Decode6BitEA_44
                    5948   Decode6BitEA_9:
                    5949   ; }
                    5950   ; else if(OperandMode == (unsigned char)(1)) {                    // Effective Address = An
0000349E  0C05 0001 5951          cmp.b     #1,D5
000034A2  6616      5952          bne.s     Decode6BitEA_11
                    5953   ; Decode3BitAddressRegister(OperandRegister) ;
000034A4  C67C 00FF 5954          and.w     #255,D3
000034A8  C6BC 0000 5955          and.l     #65535,D3
000034AC  FFFF      
000034AE  2F03      5956          move.l    D3,-(A7)
000034B0  4EB8 314E 5957          jsr       _Decode3BitAddressRegister
000034B4  584F      5958          addq.w    #4,A7
000034B6  6000 02BA 5959          bra       Decode6BitEA_44
                    5960   Decode6BitEA_11:
                    5961   ; }
                    5962   ; else if(OperandMode == (unsigned char)(2)) {                    // Effective Address = (An)
000034BA  0C05 0002 5963          cmp.b     #2,D5
000034BE  662A      5964          bne.s     Decode6BitEA_13
                    5965   ; strcatInstruction("(") ;
000034C0  4879 0000 5966          pea       @m68kde~2_172.L
000034C4  7682      
000034C6  4E92      5967          jsr       (A2)
000034C8  584F      5968          addq.w    #4,A7
                    5969   ; Decode3BitAddressRegister(OperandRegister) ;
000034CA  C67C 00FF 5970          and.w     #255,D3
000034CE  C6BC 0000 5971          and.l     #65535,D3
000034D2  FFFF      
000034D4  2F03      5972          move.l    D3,-(A7)
000034D6  4EB8 314E 5973          jsr       _Decode3BitAddressRegister
000034DA  584F      5974          addq.w    #4,A7
                    5975   ; strcatInstruction(")") ;
000034DC  4879 0000 5976          pea       @m68kde~2_173.L
000034E0  7684      
000034E2  4E92      5977          jsr       (A2)
000034E4  584F      5978          addq.w    #4,A7
000034E6  6000 028A 5979          bra       Decode6BitEA_44
                    5980   Decode6BitEA_13:
                    5981   ; }
                    5982   ; else if(OperandMode == (unsigned char)(3)) {                    // Effective Address = (An)+
000034EA  0C05 0003 5983          cmp.b     #3,D5
000034EE  662A      5984          bne.s     Decode6BitEA_15
                    5985   ; strcatInstruction("(") ;
000034F0  4879 0000 5986          pea       @m68kde~2_172.L
000034F4  7682      
000034F6  4E92      5987          jsr       (A2)
000034F8  584F      5988          addq.w    #4,A7
                    5989   ; Decode3BitAddressRegister(OperandRegister) ;
000034FA  C67C 00FF 5990          and.w     #255,D3
000034FE  C6BC 0000 5991          and.l     #65535,D3
00003502  FFFF      
00003504  2F03      5992          move.l    D3,-(A7)
00003506  4EB8 314E 5993          jsr       _Decode3BitAddressRegister
0000350A  584F      5994          addq.w    #4,A7
                    5995   ; strcatInstruction(")+") ;
0000350C  4879 0000 5996          pea       @m68kde~2_174.L
00003510  7686      
00003512  4E92      5997          jsr       (A2)
00003514  584F      5998          addq.w    #4,A7
00003516  6000 025A 5999          bra       Decode6BitEA_44
                    6000   Decode6BitEA_15:
                    6001   ; }
                    6002   ; else if(OperandMode == (unsigned char)(4)) {                    // Effective Address = -(An)
0000351A  0C05 0004 6003          cmp.b     #4,D5
0000351E  662A      6004          bne.s     Decode6BitEA_17
                    6005   ; strcatInstruction("-(") ;
00003520  4879 0000 6006          pea       @m68kde~2_175.L
00003524  768A      
00003526  4E92      6007          jsr       (A2)
00003528  584F      6008          addq.w    #4,A7
                    6009   ; Decode3BitAddressRegister(OperandRegister) ;
0000352A  C67C 00FF 6010          and.w     #255,D3
0000352E  C6BC 0000 6011          and.l     #65535,D3
00003532  FFFF      
00003534  2F03      6012          move.l    D3,-(A7)
00003536  4EB8 314E 6013          jsr       _Decode3BitAddressRegister
0000353A  584F      6014          addq.w    #4,A7
                    6015   ; strcatInstruction(")") ;
0000353C  4879 0000 6016          pea       @m68kde~2_173.L
00003540  7684      
00003542  4E92      6017          jsr       (A2)
00003544  584F      6018          addq.w    #4,A7
00003546  6000 022A 6019          bra       Decode6BitEA_44
                    6020   Decode6BitEA_17:
                    6021   ; }
                    6022   ; else if(OperandMode == (unsigned char)(5)) {                    // Effective Address = (d16, An)
0000354A  0C05 0005 6023          cmp.b     #5,D5
0000354E  6626      6024          bne.s     Decode6BitEA_19
                    6025   ; sprintf(TempString, "%d(A%d)", ExWord1, OperandRegister) ;
00003550  C6BC 0000 6026          and.l     #255,D3
00003554  00FF      
00003556  2F03      6027          move.l    D3,-(A7)
00003558  48C2      6028          ext.l     D2
0000355A  2F02      6029          move.l    D2,-(A7)
0000355C  4879 0000 6030          pea       @m68kde~2_176.L
00003560  768E      
00003562  2F0B      6031          move.l    A3,-(A7)
00003564  4E94      6032          jsr       (A4)
00003566  DEFC 0010 6033          add.w     #16,A7
                    6034   ; strcatInstruction(TempString) ;
0000356A  2F0B      6035          move.l    A3,-(A7)
0000356C  4E92      6036          jsr       (A2)
0000356E  584F      6037          addq.w    #4,A7
                    6038   ; InstructionSize += 1;
00003570  5295      6039          addq.l    #1,(A5)
00003572  6000 01FE 6040          bra       Decode6BitEA_44
                    6041   Decode6BitEA_19:
                    6042   ; }
                    6043   ; else if(OperandMode == (unsigned char)(6)) {                    // Effective Address = (d8, An, Xn)
00003576  0C05 0006 6044          cmp.b     #6,D5
0000357A  6600 00AA 6045          bne       Decode6BitEA_21
                    6046   ; offset = ExWord1 & (short int)(0x00FF);
0000357E  3002      6047          move.w    D2,D0
00003580  C07C 00FF 6048          and.w     #255,D0
00003584  1D40 FFFD 6049          move.b    D0,-3(A6)
                    6050   ; sprintf(TempString, "%d(A%d,", offset, OperandRegister) ;
00003588  C6BC 0000 6051          and.l     #255,D3
0000358C  00FF      
0000358E  2F03      6052          move.l    D3,-(A7)
00003590  122E FFFD 6053          move.b    -3(A6),D1
00003594  4881      6054          ext.w     D1
00003596  48C1      6055          ext.l     D1
00003598  2F01      6056          move.l    D1,-(A7)
0000359A  4879 0000 6057          pea       @m68kde~2_177.L
0000359E  7696      
000035A0  2F0B      6058          move.l    A3,-(A7)
000035A2  4E94      6059          jsr       (A4)
000035A4  DEFC 0010 6060          add.w     #16,A7
                    6061   ; strcatInstruction(TempString) ;
000035A8  2F0B      6062          move.l    A3,-(A7)
000035AA  4E92      6063          jsr       (A2)
000035AC  584F      6064          addq.w    #4,A7
                    6065   ; InstructionSize += 1;
000035AE  5295      6066          addq.l    #1,(A5)
                    6067   ; // decode the Xn bit
                    6068   ; if((ExWord1 & (unsigned short int)(0x8000)) == (unsigned short int)(0x0000))
000035B0  3002      6069          move.w    D2,D0
000035B2  C07C 8000 6070          and.w     #32768,D0
000035B6  660C      6071          bne.s     Decode6BitEA_23
                    6072   ; strcatInstruction("D") ;
000035B8  4879 0000 6073          pea       @m68kde~2_178.L
000035BC  769E      
000035BE  4E92      6074          jsr       (A2)
000035C0  584F      6075          addq.w    #4,A7
000035C2  600A      6076          bra.s     Decode6BitEA_24
                    6077   Decode6BitEA_23:
                    6078   ; else
                    6079   ; strcatInstruction("A") ;
000035C4  4879 0000 6080          pea       @m68kde~2_179.L
000035C8  76A0      
000035CA  4E92      6081          jsr       (A2)
000035CC  584F      6082          addq.w    #4,A7
                    6083   Decode6BitEA_24:
                    6084   ; Xn = (ExWord1 & (unsigned short int)(0x7000)) >> 12 ;        // get Xn register Number into bits 2,1,0
000035CE  3002      6085          move.w    D2,D0
000035D0  C07C 7000 6086          and.w     #28672,D0
000035D4  E048      6087          lsr.w     #8,D0
000035D6  E848      6088          lsr.w     #4,D0
000035D8  3D40 FFFE 6089          move.w    D0,-2(A6)
                    6090   ; sprintf(TempString, "%d",Xn) ;                               // generate string for reg number 0 -7
000035DC  322E FFFE 6091          move.w    -2(A6),D1
000035E0  C2BC 0000 6092          and.l     #65535,D1
000035E4  FFFF      
000035E6  2F01      6093          move.l    D1,-(A7)
000035E8  4879 0000 6094          pea       @m68kde~2_180.L
000035EC  76A2      
000035EE  2F0B      6095          move.l    A3,-(A7)
000035F0  4E94      6096          jsr       (A4)
000035F2  DEFC 000C 6097          add.w     #12,A7
                    6098   ; strcatInstruction(TempString) ;
000035F6  2F0B      6099          move.l    A3,-(A7)
000035F8  4E92      6100          jsr       (A2)
000035FA  584F      6101          addq.w    #4,A7
                    6102   ; XnSize = (ExWord1 & (unsigned short int)(0x0800)) >> 11 ;    // get xn size into bit 0
000035FC  3002      6103          move.w    D2,D0
000035FE  C07C 0800 6104          and.w     #2048,D0
00003602  E048      6105          lsr.w     #8,D0
00003604  E648      6106          lsr.w     #3,D0
00003606  3E00      6107          move.w    D0,D7
                    6108   ; if(XnSize == 0)
00003608  4A47      6109          tst.w     D7
0000360A  660C      6110          bne.s     Decode6BitEA_25
                    6111   ; strcatInstruction(".W)") ;
0000360C  4879 0000 6112          pea       @m68kde~2_181.L
00003610  76A6      
00003612  4E92      6113          jsr       (A2)
00003614  584F      6114          addq.w    #4,A7
00003616  600A      6115          bra.s     Decode6BitEA_26
                    6116   Decode6BitEA_25:
                    6117   ; else
                    6118   ; strcatInstruction(".L)") ;
00003618  4879 0000 6119          pea       @m68kde~2_182.L
0000361C  76AA      
0000361E  4E92      6120          jsr       (A2)
00003620  584F      6121          addq.w    #4,A7
                    6122   Decode6BitEA_26:
00003622  6000 014E 6123          bra       Decode6BitEA_44
                    6124   Decode6BitEA_21:
                    6125   ; }
                    6126   ; else if(OperandMode == (unsigned char)(7)) {
00003626  0C05 0007 6127          cmp.b     #7,D5
0000362A  6600 0146 6128          bne       Decode6BitEA_44
                    6129   ; if(OperandRegister == 0) {                               // EA = (xxx).W
0000362E  4A03      6130          tst.b     D3
00003630  661E      6131          bne.s     Decode6BitEA_29
                    6132   ; sprintf(TempString, "$%X", ExWord1) ;
00003632  48C2      6133          ext.l     D2
00003634  2F02      6134          move.l    D2,-(A7)
00003636  4879 0000 6135          pea       @m68kde~2_183.L
0000363A  76AE      
0000363C  2F0B      6136          move.l    A3,-(A7)
0000363E  4E94      6137          jsr       (A4)
00003640  DEFC 000C 6138          add.w     #12,A7
                    6139   ; strcatInstruction(TempString) ;
00003644  2F0B      6140          move.l    A3,-(A7)
00003646  4E92      6141          jsr       (A2)
00003648  584F      6142          addq.w    #4,A7
                    6143   ; InstructionSize += 1;
0000364A  5295      6144          addq.l    #1,(A5)
0000364C  6000 0124 6145          bra       Decode6BitEA_44
                    6146   Decode6BitEA_29:
                    6147   ; }
                    6148   ; else if(OperandRegister == 1)   {                         // EA = (xxx).L
00003650  0C03 0001 6149          cmp.b     #1,D3
00003654  6600 0032 6150          bne       Decode6BitEA_31
                    6151   ; sprintf(TempString, "$%X", ((unsigned int)(ExWord1) << 16) | (unsigned int)(ExWord2)); // create 32 bit address
00003658  3202      6152          move.w    D2,D1
0000365A  48C1      6153          ext.l     D1
0000365C  E189      6154          lsl.l     #8,D1
0000365E  E189      6155          lsl.l     #8,D1
00003660  2F00      6156          move.l    D0,-(A7)
00003662  302E FFF8 6157          move.w    -8(A6),D0
00003666  48C0      6158          ext.l     D0
00003668  8280      6159          or.l      D0,D1
0000366A  201F      6160          move.l    (A7)+,D0
0000366C  2F01      6161          move.l    D1,-(A7)
0000366E  4879 0000 6162          pea       @m68kde~2_183.L
00003672  76AE      
00003674  2F0B      6163          move.l    A3,-(A7)
00003676  4E94      6164          jsr       (A4)
00003678  DEFC 000C 6165          add.w     #12,A7
                    6166   ; strcatInstruction(TempString) ;
0000367C  2F0B      6167          move.l    A3,-(A7)
0000367E  4E92      6168          jsr       (A2)
00003680  584F      6169          addq.w    #4,A7
                    6170   ; InstructionSize += 2;
00003682  5495      6171          addq.l    #2,(A5)
00003684  6000 00EC 6172          bra       Decode6BitEA_44
                    6173   Decode6BitEA_31:
                    6174   ; }
                    6175   ; else if(OperandRegister == 4) {                                 // source EA = #Immediate addressing
00003688  0C03 0004 6176          cmp.b     #4,D3
0000368C  661C      6177          bne.s     Decode6BitEA_33
                    6178   ; if(IsItMoveInstruction == 0)        //not move instruction
0000368E  302E 0016 6179          move.w    22(A6),D0
00003692  660A      6180          bne.s     Decode6BitEA_35
                    6181   ; DecodeBWLDataAfterOpCode(OpCode);
00003694  2F04      6182          move.l    D4,-(A7)
00003696  4EB8 3242 6183          jsr       _DecodeBWLDataAfterOpCode
0000369A  584F      6184          addq.w    #4,A7
0000369C  6008      6185          bra.s     Decode6BitEA_36
                    6186   Decode6BitEA_35:
                    6187   ; else
                    6188   ; DecodeBWLDataAfterOpCodeForMove(OpCode);
0000369E  2F04      6189          move.l    D4,-(A7)
000036A0  4EB8 317A 6190          jsr       _DecodeBWLDataAfterOpCodeForMove
000036A4  584F      6191          addq.w    #4,A7
                    6192   Decode6BitEA_36:
000036A6  6000 00CA 6193          bra       Decode6BitEA_44
                    6194   Decode6BitEA_33:
                    6195   ; }
                    6196   ; else if(OperandRegister == 2) {                                 // source EA = (d16,PC)
000036AA  0C03 0002 6197          cmp.b     #2,D3
000036AE  661E      6198          bne.s     Decode6BitEA_37
                    6199   ; sprintf(TempString, "%d(PC)", ExWord1) ;
000036B0  48C2      6200          ext.l     D2
000036B2  2F02      6201          move.l    D2,-(A7)
000036B4  4879 0000 6202          pea       @m68kde~2_184.L
000036B8  76B2      
000036BA  2F0B      6203          move.l    A3,-(A7)
000036BC  4E94      6204          jsr       (A4)
000036BE  DEFC 000C 6205          add.w     #12,A7
                    6206   ; strcatInstruction(TempString) ;
000036C2  2F0B      6207          move.l    A3,-(A7)
000036C4  4E92      6208          jsr       (A2)
000036C6  584F      6209          addq.w    #4,A7
                    6210   ; InstructionSize += 1;
000036C8  5295      6211          addq.l    #1,(A5)
000036CA  6000 00A6 6212          bra       Decode6BitEA_44
                    6213   Decode6BitEA_37:
                    6214   ; }
                    6215   ; else if(OperandRegister == 3) {                                 // source EA = (d8,PC, Xn)
000036CE  0C03 0003 6216          cmp.b     #3,D3
000036D2  6600 009E 6217          bne       Decode6BitEA_44
                    6218   ; offset = ExWord1 & (short int)(0x00FF);
000036D6  3002      6219          move.w    D2,D0
000036D8  C07C 00FF 6220          and.w     #255,D0
000036DC  1D40 FFFD 6221          move.b    D0,-3(A6)
                    6222   ; sprintf(TempString, "%d(PC,", offset ) ;
000036E0  122E FFFD 6223          move.b    -3(A6),D1
000036E4  4881      6224          ext.w     D1
000036E6  48C1      6225          ext.l     D1
000036E8  2F01      6226          move.l    D1,-(A7)
000036EA  4879 0000 6227          pea       @m68kde~2_185.L
000036EE  76BA      
000036F0  2F0B      6228          move.l    A3,-(A7)
000036F2  4E94      6229          jsr       (A4)
000036F4  DEFC 000C 6230          add.w     #12,A7
                    6231   ; strcatInstruction(TempString) ;
000036F8  2F0B      6232          move.l    A3,-(A7)
000036FA  4E92      6233          jsr       (A2)
000036FC  584F      6234          addq.w    #4,A7
                    6235   ; InstructionSize += 1;
000036FE  5295      6236          addq.l    #1,(A5)
                    6237   ; // decode the Xn bit
                    6238   ; if((ExWord1 & (unsigned short int)(0x8000)) == (unsigned short int)(0x0000))
00003700  3002      6239          move.w    D2,D0
00003702  C07C 8000 6240          and.w     #32768,D0
00003706  660C      6241          bne.s     Decode6BitEA_41
                    6242   ; strcatInstruction("D") ;
00003708  4879 0000 6243          pea       @m68kde~2_178.L
0000370C  769E      
0000370E  4E92      6244          jsr       (A2)
00003710  584F      6245          addq.w    #4,A7
00003712  600A      6246          bra.s     Decode6BitEA_42
                    6247   Decode6BitEA_41:
                    6248   ; else
                    6249   ; strcatInstruction("A") ;
00003714  4879 0000 6250          pea       @m68kde~2_179.L
00003718  76A0      
0000371A  4E92      6251          jsr       (A2)
0000371C  584F      6252          addq.w    #4,A7
                    6253   Decode6BitEA_42:
                    6254   ; Xn = (ExWord1 & (unsigned short int)(0x7000)) >> 12 ;        // get Xn register Number into bits 2,1,0
0000371E  3002      6255          move.w    D2,D0
00003720  C07C 7000 6256          and.w     #28672,D0
00003724  E048      6257          lsr.w     #8,D0
00003726  E848      6258          lsr.w     #4,D0
00003728  3D40 FFFE 6259          move.w    D0,-2(A6)
                    6260   ; sprintf(TempString, "%d",Xn) ;                               // generate string for reg number 0 -7
0000372C  322E FFFE 6261          move.w    -2(A6),D1
00003730  C2BC 0000 6262          and.l     #65535,D1
00003734  FFFF      
00003736  2F01      6263          move.l    D1,-(A7)
00003738  4879 0000 6264          pea       @m68kde~2_180.L
0000373C  76A2      
0000373E  2F0B      6265          move.l    A3,-(A7)
00003740  4E94      6266          jsr       (A4)
00003742  DEFC 000C 6267          add.w     #12,A7
                    6268   ; strcatInstruction(TempString) ;
00003746  2F0B      6269          move.l    A3,-(A7)
00003748  4E92      6270          jsr       (A2)
0000374A  584F      6271          addq.w    #4,A7
                    6272   ; XnSize = (ExWord1 & (unsigned short int)(0x0800)) >> 11 ;    // get xn size into bit 0
0000374C  3002      6273          move.w    D2,D0
0000374E  C07C 0800 6274          and.w     #2048,D0
00003752  E048      6275          lsr.w     #8,D0
00003754  E648      6276          lsr.w     #3,D0
00003756  3E00      6277          move.w    D0,D7
                    6278   ; if(XnSize == 0)
00003758  4A47      6279          tst.w     D7
0000375A  660C      6280          bne.s     Decode6BitEA_43
                    6281   ; strcatInstruction(".W)") ;
0000375C  4879 0000 6282          pea       @m68kde~2_181.L
00003760  76A6      
00003762  4E92      6283          jsr       (A2)
00003764  584F      6284          addq.w    #4,A7
00003766  600A      6285          bra.s     Decode6BitEA_44
                    6286   Decode6BitEA_43:
                    6287   ; else
                    6288   ; strcatInstruction(".L)") ;
00003768  4879 0000 6289          pea       @m68kde~2_182.L
0000376C  76AA      
0000376E  4E92      6290          jsr       (A2)
00003770  584F      6291          addq.w    #4,A7
                    6292   Decode6BitEA_44:
00003772  4CDF 3CFC 6293          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003776  4E5E      6294          unlk      A6
00003778  4E75      6295          rts
                    6296   ; }
                    6297   ; }
                    6298   ; }
                    6299   ; void Decode3BitOperandMode(unsigned short int *OpCode)               // used with instructions like ADD determines source/destination
                    6300   ; {
                    6301   _Decode3BitOperandMode:
0000377A  4E56 FFFC 6302          link      A6,#-4
0000377E  2F02      6303          move.l    D2,-(A7)
00003780  242E 0008 6304          move.l    8(A6),D2
                    6305   ; unsigned short int OperandMode;
                    6306   ; OperandMode = (*OpCode & (unsigned short int)(0x0100)) >> 8 ;    // get bit 8 into position 0, defines source and destination
00003784  2042      6307          move.l    D2,A0
00003786  3010      6308          move.w    (A0),D0
00003788  C07C 0100 6309          and.w     #256,D0
0000378C  E048      6310          lsr.w     #8,D0
0000378E  3D40 FFFE 6311          move.w    D0,-2(A6)
                    6312   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
00003792  2042      6313          move.l    D2,A0
00003794  3210      6314          move.w    (A0),D1
00003796  C2BC 0000 6315          and.l     #65535,D1
0000379A  FFFF      
0000379C  2F01      6316          move.l    D1,-(A7)
0000379E  4EB8 30BE 6317          jsr       _Decode2BitOperandSize
000037A2  584F      6318          addq.w    #4,A7
                    6319   ; if(OperandMode == 0)     {                                      // Destination is a Data Register
000037A4  302E FFFE 6320          move.w    -2(A6),D0
000037A8  6600 0032 6321          bne       Decode3BitOperandMode_1
                    6322   ; Decode6BitEA(OpCode,0,0,0) ;
000037AC  42A7      6323          clr.l     -(A7)
000037AE  42A7      6324          clr.l     -(A7)
000037B0  42A7      6325          clr.l     -(A7)
000037B2  2F02      6326          move.l    D2,-(A7)
000037B4  4EB8 3352 6327          jsr       _Decode6BitEA
000037B8  DEFC 0010 6328          add.w     #16,A7
                    6329   ; strcatInstruction(",") ;
000037BC  4879 0000 6330          pea       @m68kde~2_186.L
000037C0  76C2      
000037C2  4EB8 0CCC 6331          jsr       _strcatInstruction
000037C6  584F      6332          addq.w    #4,A7
                    6333   ; Decode3BitDataRegister(*OpCode) ;
000037C8  2042      6334          move.l    D2,A0
000037CA  3210      6335          move.w    (A0),D1
000037CC  C2BC 0000 6336          and.l     #65535,D1
000037D0  FFFF      
000037D2  2F01      6337          move.l    D1,-(A7)
000037D4  4EB8 311A 6338          jsr       _Decode3BitDataRegister
000037D8  584F      6339          addq.w    #4,A7
000037DA  602E      6340          bra.s     Decode3BitOperandMode_2
                    6341   Decode3BitOperandMode_1:
                    6342   ; }
                    6343   ; else {                                                         // Destination is in EA
                    6344   ; Decode3BitDataRegister(*OpCode) ;
000037DC  2042      6345          move.l    D2,A0
000037DE  3210      6346          move.w    (A0),D1
000037E0  C2BC 0000 6347          and.l     #65535,D1
000037E4  FFFF      
000037E6  2F01      6348          move.l    D1,-(A7)
000037E8  4EB8 311A 6349          jsr       _Decode3BitDataRegister
000037EC  584F      6350          addq.w    #4,A7
                    6351   ; strcatInstruction(",") ;
000037EE  4879 0000 6352          pea       @m68kde~2_186.L
000037F2  76C2      
000037F4  4EB8 0CCC 6353          jsr       _strcatInstruction
000037F8  584F      6354          addq.w    #4,A7
                    6355   ; Decode6BitEA(OpCode,0,0,0) ;
000037FA  42A7      6356          clr.l     -(A7)
000037FC  42A7      6357          clr.l     -(A7)
000037FE  42A7      6358          clr.l     -(A7)
00003800  2F02      6359          move.l    D2,-(A7)
00003802  4EB8 3352 6360          jsr       _Decode6BitEA
00003806  DEFC 0010 6361          add.w     #16,A7
                    6362   Decode3BitOperandMode_2:
0000380A  241F      6363          move.l    (A7)+,D2
0000380C  4E5E      6364          unlk      A6
0000380E  4E75      6365          rts
                    6366   ; }
                    6367   ; }
                    6368   ; void DecodeBranchCondition(unsigned short int Condition)
                    6369   ; {
                    6370   _DecodeBranchCondition:
00003810  4E56 0000 6371          link      A6,#0
00003814  48E7 2020 6372          movem.l   D2/A2,-(A7)
00003818  45F8 0CCC 6373          lea       _strcatInstruction.L,A2
0000381C  342E 000A 6374          move.w    10(A6),D2
00003820  C4BC 0000 6375          and.l     #65535,D2
00003824  FFFF      
                    6376   ; if(Condition == (unsigned short int)(0x04))
00003826  0C42 0004 6377          cmp.w     #4,D2
0000382A  660E      6378          bne.s     DecodeBranchCondition_1
                    6379   ; strcatInstruction("CC") ;
0000382C  4879 0000 6380          pea       @m68kde~2_187.L
00003830  76C4      
00003832  4E92      6381          jsr       (A2)
00003834  584F      6382          addq.w    #4,A7
00003836  6000 011C 6383          bra       DecodeBranchCondition_30
                    6384   DecodeBranchCondition_1:
                    6385   ; else if(Condition == (unsigned short int)(0x05))
0000383A  0C42 0005 6386          cmp.w     #5,D2
0000383E  660E      6387          bne.s     DecodeBranchCondition_3
                    6388   ; strcatInstruction("CS") ;
00003840  4879 0000 6389          pea       @m68kde~2_188.L
00003844  76C8      
00003846  4E92      6390          jsr       (A2)
00003848  584F      6391          addq.w    #4,A7
0000384A  6000 0108 6392          bra       DecodeBranchCondition_30
                    6393   DecodeBranchCondition_3:
                    6394   ; else if(Condition == (unsigned short int)(0x07))
0000384E  0C42 0007 6395          cmp.w     #7,D2
00003852  660E      6396          bne.s     DecodeBranchCondition_5
                    6397   ; strcatInstruction("EQ") ;
00003854  4879 0000 6398          pea       @m68kde~2_189.L
00003858  76CC      
0000385A  4E92      6399          jsr       (A2)
0000385C  584F      6400          addq.w    #4,A7
0000385E  6000 00F4 6401          bra       DecodeBranchCondition_30
                    6402   DecodeBranchCondition_5:
                    6403   ; else if(Condition == (unsigned short int)(0x0C))
00003862  0C42 000C 6404          cmp.w     #12,D2
00003866  660E      6405          bne.s     DecodeBranchCondition_7
                    6406   ; strcatInstruction("GE") ;
00003868  4879 0000 6407          pea       @m68kde~2_190.L
0000386C  76D0      
0000386E  4E92      6408          jsr       (A2)
00003870  584F      6409          addq.w    #4,A7
00003872  6000 00E0 6410          bra       DecodeBranchCondition_30
                    6411   DecodeBranchCondition_7:
                    6412   ; else if(Condition == (unsigned short int)(0x0E))
00003876  0C42 000E 6413          cmp.w     #14,D2
0000387A  660E      6414          bne.s     DecodeBranchCondition_9
                    6415   ; strcatInstruction("GT") ;
0000387C  4879 0000 6416          pea       @m68kde~2_191.L
00003880  76D4      
00003882  4E92      6417          jsr       (A2)
00003884  584F      6418          addq.w    #4,A7
00003886  6000 00CC 6419          bra       DecodeBranchCondition_30
                    6420   DecodeBranchCondition_9:
                    6421   ; else if(Condition == (unsigned short int)(0x02))
0000388A  0C42 0002 6422          cmp.w     #2,D2
0000388E  660E      6423          bne.s     DecodeBranchCondition_11
                    6424   ; strcatInstruction("HI") ;
00003890  4879 0000 6425          pea       @m68kde~2_192.L
00003894  76D8      
00003896  4E92      6426          jsr       (A2)
00003898  584F      6427          addq.w    #4,A7
0000389A  6000 00B8 6428          bra       DecodeBranchCondition_30
                    6429   DecodeBranchCondition_11:
                    6430   ; else if(Condition == (unsigned short int)(0x0F))
0000389E  0C42 000F 6431          cmp.w     #15,D2
000038A2  660E      6432          bne.s     DecodeBranchCondition_13
                    6433   ; strcatInstruction("LE") ;
000038A4  4879 0000 6434          pea       @m68kde~2_193.L
000038A8  76DC      
000038AA  4E92      6435          jsr       (A2)
000038AC  584F      6436          addq.w    #4,A7
000038AE  6000 00A4 6437          bra       DecodeBranchCondition_30
                    6438   DecodeBranchCondition_13:
                    6439   ; else if(Condition == (unsigned short int)(0x03))
000038B2  0C42 0003 6440          cmp.w     #3,D2
000038B6  660E      6441          bne.s     DecodeBranchCondition_15
                    6442   ; strcatInstruction("LS") ;
000038B8  4879 0000 6443          pea       @m68kde~2_194.L
000038BC  76E0      
000038BE  4E92      6444          jsr       (A2)
000038C0  584F      6445          addq.w    #4,A7
000038C2  6000 0090 6446          bra       DecodeBranchCondition_30
                    6447   DecodeBranchCondition_15:
                    6448   ; else if(Condition == (unsigned short int)(0x0D))
000038C6  0C42 000D 6449          cmp.w     #13,D2
000038CA  660E      6450          bne.s     DecodeBranchCondition_17
                    6451   ; strcatInstruction("LT") ;
000038CC  4879 0000 6452          pea       @m68kde~2_195.L
000038D0  76E4      
000038D2  4E92      6453          jsr       (A2)
000038D4  584F      6454          addq.w    #4,A7
000038D6  6000 007C 6455          bra       DecodeBranchCondition_30
                    6456   DecodeBranchCondition_17:
                    6457   ; else if(Condition == (unsigned short int)(0x0B))
000038DA  0C42 000B 6458          cmp.w     #11,D2
000038DE  660E      6459          bne.s     DecodeBranchCondition_19
                    6460   ; strcatInstruction("MI") ;
000038E0  4879 0000 6461          pea       @m68kde~2_196.L
000038E4  76E8      
000038E6  4E92      6462          jsr       (A2)
000038E8  584F      6463          addq.w    #4,A7
000038EA  6000 0068 6464          bra       DecodeBranchCondition_30
                    6465   DecodeBranchCondition_19:
                    6466   ; else if(Condition == (unsigned short int)(0x06))
000038EE  0C42 0006 6467          cmp.w     #6,D2
000038F2  660E      6468          bne.s     DecodeBranchCondition_21
                    6469   ; strcatInstruction("NE") ;
000038F4  4879 0000 6470          pea       @m68kde~2_197.L
000038F8  76EC      
000038FA  4E92      6471          jsr       (A2)
000038FC  584F      6472          addq.w    #4,A7
000038FE  6000 0054 6473          bra       DecodeBranchCondition_30
                    6474   DecodeBranchCondition_21:
                    6475   ; else if(Condition == (unsigned short int)(0x0A))
00003902  0C42 000A 6476          cmp.w     #10,D2
00003906  660E      6477          bne.s     DecodeBranchCondition_23
                    6478   ; strcatInstruction("PL") ;
00003908  4879 0000 6479          pea       @m68kde~2_198.L
0000390C  76F0      
0000390E  4E92      6480          jsr       (A2)
00003910  584F      6481          addq.w    #4,A7
00003912  6000 0040 6482          bra       DecodeBranchCondition_30
                    6483   DecodeBranchCondition_23:
                    6484   ; else if(Condition == (unsigned short int)(0x09))
00003916  0C42 0009 6485          cmp.w     #9,D2
0000391A  660C      6486          bne.s     DecodeBranchCondition_25
                    6487   ; strcatInstruction("VS") ;
0000391C  4879 0000 6488          pea       @m68kde~2_199.L
00003920  76F4      
00003922  4E92      6489          jsr       (A2)
00003924  584F      6490          addq.w    #4,A7
00003926  602C      6491          bra.s     DecodeBranchCondition_30
                    6492   DecodeBranchCondition_25:
                    6493   ; else if(Condition == (unsigned short int)(0x08))
00003928  0C42 0008 6494          cmp.w     #8,D2
0000392C  660C      6495          bne.s     DecodeBranchCondition_27
                    6496   ; strcatInstruction("VC") ;
0000392E  4879 0000 6497          pea       @m68kde~2_200.L
00003932  76F8      
00003934  4E92      6498          jsr       (A2)
00003936  584F      6499          addq.w    #4,A7
00003938  601A      6500          bra.s     DecodeBranchCondition_30
                    6501   DecodeBranchCondition_27:
                    6502   ; else if(Condition == (unsigned short int)(0))
0000393A  4A42      6503          tst.w     D2
0000393C  660C      6504          bne.s     DecodeBranchCondition_29
                    6505   ; strcatInstruction("RA") ;
0000393E  4879 0000 6506          pea       @m68kde~2_201.L
00003942  76FC      
00003944  4E92      6507          jsr       (A2)
00003946  584F      6508          addq.w    #4,A7
00003948  600A      6509          bra.s     DecodeBranchCondition_30
                    6510   DecodeBranchCondition_29:
                    6511   ; else
                    6512   ; strcatInstruction("SR");
0000394A  4879 0000 6513          pea       @m68kde~2_202.L
0000394E  7700      
00003950  4E92      6514          jsr       (A2)
00003952  584F      6515          addq.w    #4,A7
                    6516   DecodeBranchCondition_30:
                    6517   ; strcatInstruction(" ") ;
00003954  4879 0000 6518          pea       @m68kde~2_32.L
00003958  66D0      
0000395A  4E92      6519          jsr       (A2)
0000395C  584F      6520          addq.w    #4,A7
0000395E  4CDF 0404 6521          movem.l   (A7)+,D2/A2
00003962  4E5E      6522          unlk      A6
00003964  4E75      6523          rts
                    6524   ; }
                    6525   ; void DisassembleInstruction( short int *OpCode)         // pointer to Opcode
                    6526   ; {
                    6527   _DisassembleInstruction:
00003966  4E56 FFD8 6528          link      A6,#-40
0000396A  48E7 3F3C 6529          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
0000396E  242E 0008 6530          move.l    8(A6),D2
00003972  45F9 0B00 6531          lea       _InstructionSize.L,A2
00003976  017E      
00003978  47F8 0CE6 6532          lea       _strcpyInstruction.L,A3
0000397C  49F9 0B00 6533          lea       _TempString.L,A4
00003980  0546      
00003982  4BF9 0000 6534          lea       _sprintf.L,A5
00003986  5A2E      
                    6535   ; unsigned short int MSBits = (*OpCode >> 12);    //mask off the lower 12 bits leaving top 4 bit to analyse
00003988  2042      6536          move.l    D2,A0
0000398A  3010      6537          move.w    (A0),D0
0000398C  E040      6538          asr.w     #8,D0
0000398E  E840      6539          asr.w     #4,D0
00003990  3D40 FFDA 6540          move.w    D0,-38(A6)
                    6541   ; unsigned short int LS12Bits = (*OpCode & (unsigned short int)(0x0FFF));
00003994  2042      6542          move.l    D2,A0
00003996  3010      6543          move.w    (A0),D0
00003998  C07C 0FFF 6544          and.w     #4095,D0
0000399C  3D40 FFDC 6545          move.w    D0,-36(A6)
                    6546   ; unsigned short int SourceBits, DestBits, Size ;
                    6547   ; unsigned char *Mode, Condition;
                    6548   ; unsigned short int Register, OpMode, EAMode, EARegister, Rx, Ry, EXGOpMode, DataSize, SourceReg;
                    6549   ; unsigned short int DataRegister, AddressRegister;
                    6550   ; signed char Displacement8Bit ;  // used for Bcc type instruction signed 8 bit displacement
                    6551   ; signed short int Displacement16Bit;
                    6552   ; short int Mask, DoneSlash;
                    6553   ; int i;
                    6554   ; strcpyInstruction("Unknown") ;
000039A0  4879 0000 6555          pea       @m68kde~2_203.L
000039A4  7704      
000039A6  4E93      6556          jsr       (A3)
000039A8  584F      6557          addq.w    #4,A7
                    6558   ; /////////////////////////////////////////////////////////////////////////////////
                    6559   ; // if instruction is ABCD
                    6560   ; /////////////////////////////////////////////////////////////////////////////////
                    6561   ; if((*OpCode & (unsigned short int)(0xF1F0 )) == (unsigned short int)(0xC100))   {
000039AA  2042      6562          move.l    D2,A0
000039AC  3010      6563          move.w    (A0),D0
000039AE  C07C F1F0 6564          and.w     #61936,D0
000039B2  0C40 C100 6565          cmp.w     #49408,D0
000039B6  6600 008C 6566          bne       DisassembleInstruction_4
                    6567   ; DestBits = (*OpCode >> 9) & (unsigned short int )(0x0007) ;
000039BA  2042      6568          move.l    D2,A0
000039BC  3010      6569          move.w    (A0),D0
000039BE  E040      6570          asr.w     #8,D0
000039C0  E240      6571          asr.w     #1,D0
000039C2  C07C 0007 6572          and.w     #7,D0
000039C6  3D40 FFE0 6573          move.w    D0,-32(A6)
                    6574   ; SourceBits = (*OpCode & (unsigned short int )(0x0007));
000039CA  2042      6575          move.l    D2,A0
000039CC  3010      6576          move.w    (A0),D0
000039CE  C07C 0007 6577          and.w     #7,D0
000039D2  3D40 FFDE 6578          move.w    D0,-34(A6)
                    6579   ; Mode = (*OpCode >> 3) & (unsigned short int )(0x0001) ;
000039D6  2042      6580          move.l    D2,A0
000039D8  3010      6581          move.w    (A0),D0
000039DA  E640      6582          asr.w     #3,D0
000039DC  48C0      6583          ext.l     D0
000039DE  C0BC 0000 6584          and.l     #1,D0
000039E2  0001      
000039E4  2D40 FFE4 6585          move.l    D0,-28(A6)
                    6586   ; if(Mode == 0)
000039E8  202E FFE4 6587          move.l    -28(A6),D0
000039EC  662C      6588          bne.s     DisassembleInstruction_3
                    6589   ; sprintf(Instruction, "ABCD D%d,D%d", SourceBits, DestBits) ;
000039EE  322E FFE0 6590          move.w    -32(A6),D1
000039F2  C2BC 0000 6591          and.l     #65535,D1
000039F6  FFFF      
000039F8  2F01      6592          move.l    D1,-(A7)
000039FA  322E FFDE 6593          move.w    -34(A6),D1
000039FE  C2BC 0000 6594          and.l     #65535,D1
00003A02  FFFF      
00003A04  2F01      6595          move.l    D1,-(A7)
00003A06  4879 0000 6596          pea       @m68kde~2_204.L
00003A0A  770C      
00003A0C  4879 0B00 6597          pea       _Instruction.L
00003A10  04E2      
00003A12  4E95      6598          jsr       (A5)
00003A14  DEFC 0010 6599          add.w     #16,A7
00003A18  602A      6600          bra.s     DisassembleInstruction_4
                    6601   DisassembleInstruction_3:
                    6602   ; else
                    6603   ; sprintf(Instruction, "ABCD -(A%d),-(A%d)", SourceBits, DestBits) ;
00003A1A  322E FFE0 6604          move.w    -32(A6),D1
00003A1E  C2BC 0000 6605          and.l     #65535,D1
00003A22  FFFF      
00003A24  2F01      6606          move.l    D1,-(A7)
00003A26  322E FFDE 6607          move.w    -34(A6),D1
00003A2A  C2BC 0000 6608          and.l     #65535,D1
00003A2E  FFFF      
00003A30  2F01      6609          move.l    D1,-(A7)
00003A32  4879 0000 6610          pea       @m68kde~2_205.L
00003A36  771A      
00003A38  4879 0B00 6611          pea       _Instruction.L
00003A3C  04E2      
00003A3E  4E95      6612          jsr       (A5)
00003A40  DEFC 0010 6613          add.w     #16,A7
                    6614   DisassembleInstruction_4:
                    6615   ; }
                    6616   ; /////////////////////////////////////////////////////////////////////////////////
                    6617   ; // if instruction is ADD or ADDA
                    6618   ; /////////////////////////////////////////////////////////////////////////////////
                    6619   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0xD000))   {
00003A44  2042      6620          move.l    D2,A0
00003A46  3010      6621          move.w    (A0),D0
00003A48  C07C F000 6622          and.w     #61440,D0
00003A4C  0C40 D000 6623          cmp.w     #53248,D0
00003A50  6600 008C 6624          bne       DisassembleInstruction_8
                    6625   ; InstructionSize = 1;
00003A54  24BC 0000 6626          move.l    #1,(A2)
00003A58  0001      
                    6627   ; OpMode = ((*OpCode >> 6) & (unsigned short int)(0x0007)) ;
00003A5A  2042      6628          move.l    D2,A0
00003A5C  3010      6629          move.w    (A0),D0
00003A5E  EC40      6630          asr.w     #6,D0
00003A60  C07C 0007 6631          and.w     #7,D0
00003A64  3600      6632          move.w    D0,D3
                    6633   ; if( (OpMode == (unsigned short int)(0x0003)) || (OpMode == (unsigned short int)(0x0007)))      // if destination is an address register then use ADDA otherwise use ADD
00003A66  0C43 0003 6634          cmp.w     #3,D3
00003A6A  6708      6635          beq.s     DisassembleInstruction_9
00003A6C  0C43 0007 6636          cmp.w     #7,D3
00003A70  6600 005A 6637          bne       DisassembleInstruction_7
                    6638   DisassembleInstruction_9:
                    6639   ; {
                    6640   ; if(OpMode == (unsigned short int)(0x0003))
00003A74  0C43 0003 6641          cmp.w     #3,D3
00003A78  660C      6642          bne.s     DisassembleInstruction_10
                    6643   ; strcpyInstruction("ADDA.W ") ;
00003A7A  4879 0000 6644          pea       @m68kde~2_206.L
00003A7E  772E      
00003A80  4E93      6645          jsr       (A3)
00003A82  584F      6646          addq.w    #4,A7
00003A84  600A      6647          bra.s     DisassembleInstruction_11
                    6648   DisassembleInstruction_10:
                    6649   ; else
                    6650   ; strcpyInstruction("ADDA.L ") ;
00003A86  4879 0000 6651          pea       @m68kde~2_207.L
00003A8A  7736      
00003A8C  4E93      6652          jsr       (A3)
00003A8E  584F      6653          addq.w    #4,A7
                    6654   DisassembleInstruction_11:
                    6655   ; Decode6BitEA(OpCode,0,0,0)  ;
00003A90  42A7      6656          clr.l     -(A7)
00003A92  42A7      6657          clr.l     -(A7)
00003A94  42A7      6658          clr.l     -(A7)
00003A96  2F02      6659          move.l    D2,-(A7)
00003A98  4EB8 3352 6660          jsr       _Decode6BitEA
00003A9C  DEFC 0010 6661          add.w     #16,A7
                    6662   ; sprintf(TempString, ",A%X", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00003AA0  2042      6663          move.l    D2,A0
00003AA2  3210      6664          move.w    (A0),D1
00003AA4  E041      6665          asr.w     #8,D1
00003AA6  E241      6666          asr.w     #1,D1
00003AA8  C27C 0007 6667          and.w     #7,D1
00003AAC  C2BC 0000 6668          and.l     #65535,D1
00003AB0  FFFF      
00003AB2  2F01      6669          move.l    D1,-(A7)
00003AB4  4879 0000 6670          pea       @m68kde~2_208.L
00003AB8  773E      
00003ABA  2F0C      6671          move.l    A4,-(A7)
00003ABC  4E95      6672          jsr       (A5)
00003ABE  DEFC 000C 6673          add.w     #12,A7
                    6674   ; strcatInstruction(TempString) ;
00003AC2  2F0C      6675          move.l    A4,-(A7)
00003AC4  4EB8 0CCC 6676          jsr       _strcatInstruction
00003AC8  584F      6677          addq.w    #4,A7
00003ACA  6012      6678          bra.s     DisassembleInstruction_8
                    6679   DisassembleInstruction_7:
                    6680   ; }
                    6681   ; else {
                    6682   ; strcpyInstruction("ADD") ;
00003ACC  4879 0000 6683          pea       @m68kde~2_209.L
00003AD0  7744      
00003AD2  4E93      6684          jsr       (A3)
00003AD4  584F      6685          addq.w    #4,A7
                    6686   ; Decode3BitOperandMode(OpCode) ;
00003AD6  2F02      6687          move.l    D2,-(A7)
00003AD8  4EB8 377A 6688          jsr       _Decode3BitOperandMode
00003ADC  584F      6689          addq.w    #4,A7
                    6690   DisassembleInstruction_8:
                    6691   ; }
                    6692   ; }
                    6693   ; /////////////////////////////////////////////////////////////////////////////////
                    6694   ; // if instruction is ADDI or ANDI or CMPI or EORI or ORI or SUBI
                    6695   ; /////////////////////////////////////////////////////////////////////////////////
                    6696   ; if( (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0600) |
00003ADE  2042      6697          move.l    D2,A0
00003AE0  3010      6698          move.w    (A0),D0
00003AE2  C07C FF00 6699          and.w     #65280,D0
00003AE6  0C40 0600 6700          cmp.w     #1536,D0
00003AEA  6604      6701          bne.s     DisassembleInstruction_14
00003AEC  7001      6702          moveq     #1,D0
00003AEE  6002      6703          bra.s     DisassembleInstruction_15
                    6704   DisassembleInstruction_14:
00003AF0  4280      6705          clr.l     D0
                    6706   DisassembleInstruction_15:
00003AF2  2042      6707          move.l    D2,A0
00003AF4  3210      6708          move.w    (A0),D1
00003AF6  C27C FF00 6709          and.w     #65280,D1
00003AFA  0C41 0200 6710          cmp.w     #512,D1
00003AFE  6604      6711          bne.s     DisassembleInstruction_16
00003B00  7201      6712          moveq     #1,D1
00003B02  6002      6713          bra.s     DisassembleInstruction_17
                    6714   DisassembleInstruction_16:
00003B04  4281      6715          clr.l     D1
                    6716   DisassembleInstruction_17:
00003B06  8041      6717          or.w      D1,D0
00003B08  2042      6718          move.l    D2,A0
00003B0A  3210      6719          move.w    (A0),D1
00003B0C  C27C FF00 6720          and.w     #65280,D1
00003B10  0C41 0C00 6721          cmp.w     #3072,D1
00003B14  6604      6722          bne.s     DisassembleInstruction_18
00003B16  7201      6723          moveq     #1,D1
00003B18  6002      6724          bra.s     DisassembleInstruction_19
                    6725   DisassembleInstruction_18:
00003B1A  4281      6726          clr.l     D1
                    6727   DisassembleInstruction_19:
00003B1C  8041      6728          or.w      D1,D0
00003B1E  2042      6729          move.l    D2,A0
00003B20  3210      6730          move.w    (A0),D1
00003B22  C27C FF00 6731          and.w     #65280,D1
00003B26  0C41 0A00 6732          cmp.w     #2560,D1
00003B2A  6604      6733          bne.s     DisassembleInstruction_20
00003B2C  7201      6734          moveq     #1,D1
00003B2E  6002      6735          bra.s     DisassembleInstruction_21
                    6736   DisassembleInstruction_20:
00003B30  4281      6737          clr.l     D1
                    6738   DisassembleInstruction_21:
00003B32  8041      6739          or.w      D1,D0
00003B34  2042      6740          move.l    D2,A0
00003B36  3210      6741          move.w    (A0),D1
00003B38  C27C FF00 6742          and.w     #65280,D1
00003B3C  6604      6743          bne.s     DisassembleInstruction_22
00003B3E  7201      6744          moveq     #1,D1
00003B40  6002      6745          bra.s     DisassembleInstruction_23
                    6746   DisassembleInstruction_22:
00003B42  4281      6747          clr.l     D1
                    6748   DisassembleInstruction_23:
00003B44  8041      6749          or.w      D1,D0
00003B46  2042      6750          move.l    D2,A0
00003B48  3210      6751          move.w    (A0),D1
00003B4A  C27C FF00 6752          and.w     #65280,D1
00003B4E  0C41 0400 6753          cmp.w     #1024,D1
00003B52  6604      6754          bne.s     DisassembleInstruction_24
00003B54  7201      6755          moveq     #1,D1
00003B56  6002      6756          bra.s     DisassembleInstruction_25
                    6757   DisassembleInstruction_24:
00003B58  4281      6758          clr.l     D1
                    6759   DisassembleInstruction_25:
00003B5A  8041      6760          or.w      D1,D0
00003B5C  6700 00E4 6761          beq       DisassembleInstruction_12
                    6762   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0200) |
                    6763   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0C00) |
                    6764   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0A00) |
                    6765   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0000) |
                    6766   ; (*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0400))
                    6767   ; {
                    6768   ; InstructionSize = 1;
00003B60  24BC 0000 6769          move.l    #1,(A2)
00003B64  0001      
                    6770   ; if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0600))
00003B66  2042      6771          move.l    D2,A0
00003B68  3010      6772          move.w    (A0),D0
00003B6A  C07C FF00 6773          and.w     #65280,D0
00003B6E  0C40 0600 6774          cmp.w     #1536,D0
00003B72  660E      6775          bne.s     DisassembleInstruction_26
                    6776   ; strcpyInstruction("ADDI") ;
00003B74  4879 0000 6777          pea       @m68kde~2_210.L
00003B78  7748      
00003B7A  4E93      6778          jsr       (A3)
00003B7C  584F      6779          addq.w    #4,A7
00003B7E  6000 0084 6780          bra       DisassembleInstruction_36
                    6781   DisassembleInstruction_26:
                    6782   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0200))
00003B82  2042      6783          move.l    D2,A0
00003B84  3010      6784          move.w    (A0),D0
00003B86  C07C FF00 6785          and.w     #65280,D0
00003B8A  0C40 0200 6786          cmp.w     #512,D0
00003B8E  660E      6787          bne.s     DisassembleInstruction_28
                    6788   ; strcpyInstruction("ANDI") ;
00003B90  4879 0000 6789          pea       @m68kde~2_211.L
00003B94  774E      
00003B96  4E93      6790          jsr       (A3)
00003B98  584F      6791          addq.w    #4,A7
00003B9A  6000 0068 6792          bra       DisassembleInstruction_36
                    6793   DisassembleInstruction_28:
                    6794   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0C00))
00003B9E  2042      6795          move.l    D2,A0
00003BA0  3010      6796          move.w    (A0),D0
00003BA2  C07C FF00 6797          and.w     #65280,D0
00003BA6  0C40 0C00 6798          cmp.w     #3072,D0
00003BAA  660E      6799          bne.s     DisassembleInstruction_30
                    6800   ; strcpyInstruction("CMPI") ;
00003BAC  4879 0000 6801          pea       @m68kde~2_212.L
00003BB0  7754      
00003BB2  4E93      6802          jsr       (A3)
00003BB4  584F      6803          addq.w    #4,A7
00003BB6  6000 004C 6804          bra       DisassembleInstruction_36
                    6805   DisassembleInstruction_30:
                    6806   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0A00))
00003BBA  2042      6807          move.l    D2,A0
00003BBC  3010      6808          move.w    (A0),D0
00003BBE  C07C FF00 6809          and.w     #65280,D0
00003BC2  0C40 0A00 6810          cmp.w     #2560,D0
00003BC6  660E      6811          bne.s     DisassembleInstruction_32
                    6812   ; strcpyInstruction("EORI") ;
00003BC8  4879 0000 6813          pea       @m68kde~2_213.L
00003BCC  775A      
00003BCE  4E93      6814          jsr       (A3)
00003BD0  584F      6815          addq.w    #4,A7
00003BD2  6000 0030 6816          bra       DisassembleInstruction_36
                    6817   DisassembleInstruction_32:
                    6818   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0000))
00003BD6  2042      6819          move.l    D2,A0
00003BD8  3010      6820          move.w    (A0),D0
00003BDA  C07C FF00 6821          and.w     #65280,D0
00003BDE  660C      6822          bne.s     DisassembleInstruction_34
                    6823   ; strcpyInstruction("ORI") ;
00003BE0  4879 0000 6824          pea       @m68kde~2_214.L
00003BE4  7760      
00003BE6  4E93      6825          jsr       (A3)
00003BE8  584F      6826          addq.w    #4,A7
00003BEA  6018      6827          bra.s     DisassembleInstruction_36
                    6828   DisassembleInstruction_34:
                    6829   ; else if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x0400))
00003BEC  2042      6830          move.l    D2,A0
00003BEE  3010      6831          move.w    (A0),D0
00003BF0  C07C FF00 6832          and.w     #65280,D0
00003BF4  0C40 0400 6833          cmp.w     #1024,D0
00003BF8  660A      6834          bne.s     DisassembleInstruction_36
                    6835   ; strcpyInstruction("SUBI") ;
00003BFA  4879 0000 6836          pea       @m68kde~2_215.L
00003BFE  7764      
00003C00  4E93      6837          jsr       (A3)
00003C02  584F      6838          addq.w    #4,A7
                    6839   DisassembleInstruction_36:
                    6840   ; DataSize = Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
00003C04  2042      6841          move.l    D2,A0
00003C06  3210      6842          move.w    (A0),D1
00003C08  C2BC 0000 6843          and.l     #65535,D1
00003C0C  FFFF      
00003C0E  2F01      6844          move.l    D1,-(A7)
00003C10  4EB8 30BE 6845          jsr       _Decode2BitOperandSize
00003C14  584F      6846          addq.w    #4,A7
00003C16  3E00      6847          move.w    D0,D7
                    6848   ; DecodeBWLDataAfterOpCode(OpCode);                                // go add the 8,16,32 bit data to instruction string
00003C18  2F02      6849          move.l    D2,-(A7)
00003C1A  4EB8 3242 6850          jsr       _DecodeBWLDataAfterOpCode
00003C1E  584F      6851          addq.w    #4,A7
                    6852   ; strcatInstruction(",") ;
00003C20  4879 0000 6853          pea       @m68kde~2_186.L
00003C24  76C2      
00003C26  4EB8 0CCC 6854          jsr       _strcatInstruction
00003C2A  584F      6855          addq.w    #4,A7
                    6856   ; Decode6BitEA(OpCode,0,DataSize,0) ;                                         // decode EA
00003C2C  42A7      6857          clr.l     -(A7)
00003C2E  CEBC 0000 6858          and.l     #65535,D7
00003C32  FFFF      
00003C34  2F07      6859          move.l    D7,-(A7)
00003C36  42A7      6860          clr.l     -(A7)
00003C38  2F02      6861          move.l    D2,-(A7)
00003C3A  4EB8 3352 6862          jsr       _Decode6BitEA
00003C3E  DEFC 0010 6863          add.w     #16,A7
                    6864   DisassembleInstruction_12:
                    6865   ; }
                    6866   ; /////////////////////////////////////////////////////////////////////////////////
                    6867   ; // if instruction is ADDI #data,SR
                    6868   ; /////////////////////////////////////////////////////////////////////////////////
                    6869   ; if(*OpCode  == (unsigned short int)(0x027c))   {
00003C42  2042      6870          move.l    D2,A0
00003C44  3010      6871          move.w    (A0),D0
00003C46  0C40 027C 6872          cmp.w     #636,D0
00003C4A  6622      6873          bne.s     DisassembleInstruction_38
                    6874   ; InstructionSize = 2;
00003C4C  24BC 0000 6875          move.l    #2,(A2)
00003C50  0002      
                    6876   ; sprintf(Instruction, "ANDI #$%X,SR", OpCode[1]);
00003C52  2042      6877          move.l    D2,A0
00003C54  3228 0002 6878          move.w    2(A0),D1
00003C58  48C1      6879          ext.l     D1
00003C5A  2F01      6880          move.l    D1,-(A7)
00003C5C  4879 0000 6881          pea       @m68kde~2_216.L
00003C60  776A      
00003C62  4879 0B00 6882          pea       _Instruction.L
00003C66  04E2      
00003C68  4E95      6883          jsr       (A5)
00003C6A  DEFC 000C 6884          add.w     #12,A7
                    6885   DisassembleInstruction_38:
                    6886   ; }
                    6887   ; /////////////////////////////////////////////////////////////////////////////////
                    6888   ; // if instruction is ADDQ
                    6889   ; /////////////////////////////////////////////////////////////////////////////////
                    6890   ; if((*OpCode & (unsigned short int)(0xF100 )) == (unsigned short int)(0x5000))   {
00003C6E  2042      6891          move.l    D2,A0
00003C70  3010      6892          move.w    (A0),D0
00003C72  C07C F100 6893          and.w     #61696,D0
00003C76  0C40 5000 6894          cmp.w     #20480,D0
00003C7A  6600 005E 6895          bne       DisassembleInstruction_40
                    6896   ; InstructionSize = 1;
00003C7E  24BC 0000 6897          move.l    #1,(A2)
00003C82  0001      
                    6898   ; strcpyInstruction("ADDQ") ;
00003C84  4879 0000 6899          pea       @m68kde~2_217.L
00003C88  7778      
00003C8A  4E93      6900          jsr       (A3)
00003C8C  584F      6901          addq.w    #4,A7
                    6902   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
00003C8E  2042      6903          move.l    D2,A0
00003C90  3210      6904          move.w    (A0),D1
00003C92  C2BC 0000 6905          and.l     #65535,D1
00003C96  FFFF      
00003C98  2F01      6906          move.l    D1,-(A7)
00003C9A  4EB8 30BE 6907          jsr       _Decode2BitOperandSize
00003C9E  584F      6908          addq.w    #4,A7
                    6909   ; sprintf(TempString, "#%1X,", ((*OpCode >> 9) & (unsigned short int)(0x0007)));    // print 3 bit #data in positions 11,10,9 in opcode
00003CA0  2042      6910          move.l    D2,A0
00003CA2  3210      6911          move.w    (A0),D1
00003CA4  E041      6912          asr.w     #8,D1
00003CA6  E241      6913          asr.w     #1,D1
00003CA8  C27C 0007 6914          and.w     #7,D1
00003CAC  C2BC 0000 6915          and.l     #65535,D1
00003CB0  FFFF      
00003CB2  2F01      6916          move.l    D1,-(A7)
00003CB4  4879 0000 6917          pea       @m68kde~2_218.L
00003CB8  777E      
00003CBA  2F0C      6918          move.l    A4,-(A7)
00003CBC  4E95      6919          jsr       (A5)
00003CBE  DEFC 000C 6920          add.w     #12,A7
                    6921   ; strcatInstruction(TempString) ;
00003CC2  2F0C      6922          move.l    A4,-(A7)
00003CC4  4EB8 0CCC 6923          jsr       _strcatInstruction
00003CC8  584F      6924          addq.w    #4,A7
                    6925   ; Decode6BitEA(OpCode,0,0,0) ;                                           // decode EA
00003CCA  42A7      6926          clr.l     -(A7)
00003CCC  42A7      6927          clr.l     -(A7)
00003CCE  42A7      6928          clr.l     -(A7)
00003CD0  2F02      6929          move.l    D2,-(A7)
00003CD2  4EB8 3352 6930          jsr       _Decode6BitEA
00003CD6  DEFC 0010 6931          add.w     #16,A7
                    6932   DisassembleInstruction_40:
                    6933   ; }
                    6934   ; /////////////////////////////////////////////////////////////////////////////////
                    6935   ; // if instruction is ADDX
                    6936   ; /////////////////////////////////////////////////////////////////////////////////
                    6937   ; if((*OpCode & (unsigned short int)(0xF130 )) == (unsigned short int)(0xD100))   {
00003CDA  2042      6938          move.l    D2,A0
00003CDC  3010      6939          move.w    (A0),D0
00003CDE  C07C F130 6940          and.w     #61744,D0
00003CE2  0C40 D100 6941          cmp.w     #53504,D0
00003CE6  6600 00A4 6942          bne       DisassembleInstruction_44
                    6943   ; InstructionSize = 1;
00003CEA  24BC 0000 6944          move.l    #1,(A2)
00003CEE  0001      
                    6945   ; OpMode = ((*OpCode >> 6) & (unsigned short int)(0x0003)) ;
00003CF0  2042      6946          move.l    D2,A0
00003CF2  3010      6947          move.w    (A0),D0
00003CF4  EC40      6948          asr.w     #6,D0
00003CF6  C07C 0003 6949          and.w     #3,D0
00003CFA  3600      6950          move.w    D0,D3
                    6951   ; if(OpMode != (unsigned short int)(0x0003)) // if size = 11 then it's ADDA not ADDX
00003CFC  0C43 0003 6952          cmp.w     #3,D3
00003D00  6700 008A 6953          beq       DisassembleInstruction_44
                    6954   ; {
                    6955   ; strcpyInstruction("ADDX") ;
00003D04  4879 0000 6956          pea       @m68kde~2_219.L
00003D08  7784      
00003D0A  4E93      6957          jsr       (A3)
00003D0C  584F      6958          addq.w    #4,A7
                    6959   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
00003D0E  2042      6960          move.l    D2,A0
00003D10  3210      6961          move.w    (A0),D1
00003D12  C2BC 0000 6962          and.l     #65535,D1
00003D16  FFFF      
00003D18  2F01      6963          move.l    D1,-(A7)
00003D1A  4EB8 30BE 6964          jsr       _Decode2BitOperandSize
00003D1E  584F      6965          addq.w    #4,A7
                    6966   ; if((*OpCode & (unsigned short int)(0x0008)) == (unsigned short int)(0))    // if bit 3 of opcode is 0 indicates data registers are used as source and destination
00003D20  2042      6967          move.l    D2,A0
00003D22  3010      6968          move.w    (A0),D0
00003D24  C07C 0008 6969          and.w     #8,D0
00003D28  6600 0030 6970          bne       DisassembleInstruction_46
                    6971   ; sprintf(TempString, "D%X,D%X", (*OpCode & 0x0007), ((*OpCode >> 9) & 0x0007)) ;
00003D2C  2042      6972          move.l    D2,A0
00003D2E  3210      6973          move.w    (A0),D1
00003D30  E041      6974          asr.w     #8,D1
00003D32  E241      6975          asr.w     #1,D1
00003D34  C27C 0007 6976          and.w     #7,D1
00003D38  48C1      6977          ext.l     D1
00003D3A  2F01      6978          move.l    D1,-(A7)
00003D3C  2042      6979          move.l    D2,A0
00003D3E  3210      6980          move.w    (A0),D1
00003D40  C27C 0007 6981          and.w     #7,D1
00003D44  48C1      6982          ext.l     D1
00003D46  2F01      6983          move.l    D1,-(A7)
00003D48  4879 0000 6984          pea       @m68kde~2_220.L
00003D4C  778A      
00003D4E  2F0C      6985          move.l    A4,-(A7)
00003D50  4E95      6986          jsr       (A5)
00003D52  DEFC 0010 6987          add.w     #16,A7
00003D56  6000 002C 6988          bra       DisassembleInstruction_47
                    6989   DisassembleInstruction_46:
                    6990   ; else        // -(ax),-(ay) mode used
                    6991   ; sprintf(TempString, "-(A%X),-(A%X)", (*OpCode & 0x0007), ((*OpCode >> 9) & 0x0007)) ;
00003D5A  2042      6992          move.l    D2,A0
00003D5C  3210      6993          move.w    (A0),D1
00003D5E  E041      6994          asr.w     #8,D1
00003D60  E241      6995          asr.w     #1,D1
00003D62  C27C 0007 6996          and.w     #7,D1
00003D66  48C1      6997          ext.l     D1
00003D68  2F01      6998          move.l    D1,-(A7)
00003D6A  2042      6999          move.l    D2,A0
00003D6C  3210      7000          move.w    (A0),D1
00003D6E  C27C 0007 7001          and.w     #7,D1
00003D72  48C1      7002          ext.l     D1
00003D74  2F01      7003          move.l    D1,-(A7)
00003D76  4879 0000 7004          pea       @m68kde~2_221.L
00003D7A  7792      
00003D7C  2F0C      7005          move.l    A4,-(A7)
00003D7E  4E95      7006          jsr       (A5)
00003D80  DEFC 0010 7007          add.w     #16,A7
                    7008   DisassembleInstruction_47:
                    7009   ; strcatInstruction(TempString) ;
00003D84  2F0C      7010          move.l    A4,-(A7)
00003D86  4EB8 0CCC 7011          jsr       _strcatInstruction
00003D8A  584F      7012          addq.w    #4,A7
                    7013   DisassembleInstruction_44:
                    7014   ; }
                    7015   ; }
                    7016   ; /////////////////////////////////////////////////////////////////////////////////
                    7017   ; // if instruction is AND
                    7018   ; /////////////////////////////////////////////////////////////////////////////////
                    7019   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0xC000))   {
00003D8C  2042      7020          move.l    D2,A0
00003D8E  3010      7021          move.w    (A0),D0
00003D90  C07C F000 7022          and.w     #61440,D0
00003D94  0C40 C000 7023          cmp.w     #49152,D0
00003D98  662A      7024          bne.s     DisassembleInstruction_50
                    7025   ; InstructionSize = 1;
00003D9A  24BC 0000 7026          move.l    #1,(A2)
00003D9E  0001      
                    7027   ; // need to differentiate between AND and ABCD using Mode bits in 5,4,3
                    7028   ; OpMode = (*OpCode >> 4) & (unsigned short int)(0x001F);
00003DA0  2042      7029          move.l    D2,A0
00003DA2  3010      7030          move.w    (A0),D0
00003DA4  E840      7031          asr.w     #4,D0
00003DA6  C07C 001F 7032          and.w     #31,D0
00003DAA  3600      7033          move.w    D0,D3
                    7034   ; if(OpMode != (unsigned short int)(0x0010))   {
00003DAC  0C43 0010 7035          cmp.w     #16,D3
00003DB0  6712      7036          beq.s     DisassembleInstruction_50
                    7037   ; strcpyInstruction("AND") ;
00003DB2  4879 0000 7038          pea       @m68kde~2_222.L
00003DB6  77A0      
00003DB8  4E93      7039          jsr       (A3)
00003DBA  584F      7040          addq.w    #4,A7
                    7041   ; Decode3BitOperandMode(OpCode) ;
00003DBC  2F02      7042          move.l    D2,-(A7)
00003DBE  4EB8 377A 7043          jsr       _Decode3BitOperandMode
00003DC2  584F      7044          addq.w    #4,A7
                    7045   DisassembleInstruction_50:
                    7046   ; }
                    7047   ; }
                    7048   ; /////////////////////////////////////////////////////////////////////////////////
                    7049   ; // if instruction is ANDI to CCR
                    7050   ; /////////////////////////////////////////////////////////////////////////////////
                    7051   ; if(*OpCode == (unsigned short int)(0x023C))   {
00003DC4  2042      7052          move.l    D2,A0
00003DC6  3010      7053          move.w    (A0),D0
00003DC8  0C40 023C 7054          cmp.w     #572,D0
00003DCC  662A      7055          bne.s     DisassembleInstruction_52
                    7056   ; sprintf(Instruction, "ANDI #$%2X,CCR", OpCode[1] & (unsigned short int)(0x00FF)) ;
00003DCE  2042      7057          move.l    D2,A0
00003DD0  3228 0002 7058          move.w    2(A0),D1
00003DD4  C27C 00FF 7059          and.w     #255,D1
00003DD8  C2BC 0000 7060          and.l     #65535,D1
00003DDC  FFFF      
00003DDE  2F01      7061          move.l    D1,-(A7)
00003DE0  4879 0000 7062          pea       @m68kde~2_223.L
00003DE4  77A4      
00003DE6  4879 0B00 7063          pea       _Instruction.L
00003DEA  04E2      
00003DEC  4E95      7064          jsr       (A5)
00003DEE  DEFC 000C 7065          add.w     #12,A7
                    7066   ; InstructionSize = 2;
00003DF2  24BC 0000 7067          move.l    #2,(A2)
00003DF6  0002      
                    7068   DisassembleInstruction_52:
                    7069   ; }
                    7070   ; /////////////////////////////////////////////////////////////////////////////////
                    7071   ; // if instruction is ASL/ASR/LSL/LSR/ROL/ROR NOTE two versions of this with different OPCodes
                    7072   ; /////////////////////////////////////////////////////////////////////////////////
                    7073   ; if( ((*OpCode & (unsigned short int)(0xF018 )) == (unsigned short int)(0xE000)) |   // ASL/ASR
00003DF8  2042      7074          move.l    D2,A0
00003DFA  3010      7075          move.w    (A0),D0
00003DFC  C07C F018 7076          and.w     #61464,D0
00003E00  0C40 E000 7077          cmp.w     #57344,D0
00003E04  6604      7078          bne.s     DisassembleInstruction_56
00003E06  7001      7079          moveq     #1,D0
00003E08  6002      7080          bra.s     DisassembleInstruction_57
                    7081   DisassembleInstruction_56:
00003E0A  4280      7082          clr.l     D0
                    7083   DisassembleInstruction_57:
00003E0C  2042      7084          move.l    D2,A0
00003E0E  3210      7085          move.w    (A0),D1
00003E10  C27C FEC0 7086          and.w     #65216,D1
00003E14  0C41 E0C0 7087          cmp.w     #57536,D1
00003E18  6604      7088          bne.s     DisassembleInstruction_58
00003E1A  7201      7089          moveq     #1,D1
00003E1C  6002      7090          bra.s     DisassembleInstruction_59
                    7091   DisassembleInstruction_58:
00003E1E  4281      7092          clr.l     D1
                    7093   DisassembleInstruction_59:
00003E20  8041      7094          or.w      D1,D0
00003E22  2042      7095          move.l    D2,A0
00003E24  3210      7096          move.w    (A0),D1
00003E26  C27C F018 7097          and.w     #61464,D1
00003E2A  0C41 E008 7098          cmp.w     #57352,D1
00003E2E  6604      7099          bne.s     DisassembleInstruction_60
00003E30  7201      7100          moveq     #1,D1
00003E32  6002      7101          bra.s     DisassembleInstruction_61
                    7102   DisassembleInstruction_60:
00003E34  4281      7103          clr.l     D1
                    7104   DisassembleInstruction_61:
00003E36  8041      7105          or.w      D1,D0
00003E38  2042      7106          move.l    D2,A0
00003E3A  3210      7107          move.w    (A0),D1
00003E3C  C27C FEC0 7108          and.w     #65216,D1
00003E40  0C41 E2C0 7109          cmp.w     #58048,D1
00003E44  6604      7110          bne.s     DisassembleInstruction_62
00003E46  7201      7111          moveq     #1,D1
00003E48  6002      7112          bra.s     DisassembleInstruction_63
                    7113   DisassembleInstruction_62:
00003E4A  4281      7114          clr.l     D1
                    7115   DisassembleInstruction_63:
00003E4C  8041      7116          or.w      D1,D0
00003E4E  2042      7117          move.l    D2,A0
00003E50  3210      7118          move.w    (A0),D1
00003E52  C27C F018 7119          and.w     #61464,D1
00003E56  0C41 E018 7120          cmp.w     #57368,D1
00003E5A  6604      7121          bne.s     DisassembleInstruction_64
00003E5C  7201      7122          moveq     #1,D1
00003E5E  6002      7123          bra.s     DisassembleInstruction_65
                    7124   DisassembleInstruction_64:
00003E60  4281      7125          clr.l     D1
                    7126   DisassembleInstruction_65:
00003E62  8041      7127          or.w      D1,D0
00003E64  2042      7128          move.l    D2,A0
00003E66  3210      7129          move.w    (A0),D1
00003E68  C27C FEC0 7130          and.w     #65216,D1
00003E6C  0C41 E6C0 7131          cmp.w     #59072,D1
00003E70  6604      7132          bne.s     DisassembleInstruction_66
00003E72  7201      7133          moveq     #1,D1
00003E74  6002      7134          bra.s     DisassembleInstruction_67
                    7135   DisassembleInstruction_66:
00003E76  4281      7136          clr.l     D1
                    7137   DisassembleInstruction_67:
00003E78  8041      7138          or.w      D1,D0
00003E7A  2042      7139          move.l    D2,A0
00003E7C  3210      7140          move.w    (A0),D1
00003E7E  C27C F018 7141          and.w     #61464,D1
00003E82  0C41 E010 7142          cmp.w     #57360,D1
00003E86  6604      7143          bne.s     DisassembleInstruction_68
00003E88  7201      7144          moveq     #1,D1
00003E8A  6002      7145          bra.s     DisassembleInstruction_69
                    7146   DisassembleInstruction_68:
00003E8C  4281      7147          clr.l     D1
                    7148   DisassembleInstruction_69:
00003E8E  8041      7149          or.w      D1,D0
00003E90  2042      7150          move.l    D2,A0
00003E92  3210      7151          move.w    (A0),D1
00003E94  C27C FEC0 7152          and.w     #65216,D1
00003E98  0C41 E4C0 7153          cmp.w     #58560,D1
00003E9C  6604      7154          bne.s     DisassembleInstruction_70
00003E9E  7201      7155          moveq     #1,D1
00003EA0  6002      7156          bra.s     DisassembleInstruction_71
                    7157   DisassembleInstruction_70:
00003EA2  4281      7158          clr.l     D1
                    7159   DisassembleInstruction_71:
00003EA4  8041      7160          or.w      D1,D0
00003EA6  6700 0252 7161          beq       DisassembleInstruction_73
                    7162   ; ((*OpCode & (unsigned short int)(0xFEC0 )) == (unsigned short int)(0xE0C0)) |
                    7163   ; ((*OpCode & (unsigned short int)(0xF018 )) == (unsigned short int)(0xE008)) |   // LSL/LSR
                    7164   ; ((*OpCode & (unsigned short int)(0xFEC0 )) == (unsigned short int)(0xE2C0)) |
                    7165   ; ((*OpCode & (unsigned short int)(0xF018 )) == (unsigned short int)(0xE018)) |   // ROR/ROL
                    7166   ; ((*OpCode & (unsigned short int)(0xFEC0 )) == (unsigned short int)(0xE6C0)) |
                    7167   ; ((*OpCode & (unsigned short int)(0xF018 )) == (unsigned short int)(0xE010)) |   // ROXR/ROXL
                    7168   ; ((*OpCode & (unsigned short int)(0xFEC0 )) == (unsigned short int)(0xE4C0)))
                    7169   ; {
                    7170   ; InstructionSize = 1;
00003EAA  24BC 0000 7171          move.l    #1,(A2)
00003EAE  0001      
                    7172   ; // 2nd version e.g. ASR/ASL/LSR/LSL/ROR/ROL/ROXL/ROXR <EA> shift a word 1 bit
                    7173   ; if((*OpCode & (unsigned short int)(0x00C0)) == (unsigned short int)(0x00C0)) // if bits 7,6 == 1,1
00003EB0  2042      7174          move.l    D2,A0
00003EB2  3010      7175          move.w    (A0),D0
00003EB4  C07C 00C0 7176          and.w     #192,D0
00003EB8  0C40 00C0 7177          cmp.w     #192,D0
00003EBC  6600 00EA 7178          bne       DisassembleInstruction_72
                    7179   ; {
                    7180   ; // test direction by testing bit 8
                    7181   ; if((*OpCode & (unsigned short int)(0xFEC0)) == (unsigned short int)(0xE0C0))    //asr/asl
00003EC0  2042      7182          move.l    D2,A0
00003EC2  3010      7183          move.w    (A0),D0
00003EC4  C07C FEC0 7184          and.w     #65216,D0
00003EC8  0C40 E0C0 7185          cmp.w     #57536,D0
00003ECC  6624      7186          bne.s     DisassembleInstruction_77
                    7187   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003ECE  2042      7188          move.l    D2,A0
00003ED0  3010      7189          move.w    (A0),D0
00003ED2  C07C 0100 7190          and.w     #256,D0
00003ED6  0C40 0100 7191          cmp.w     #256,D0
00003EDA  660C      7192          bne.s     DisassembleInstruction_76
                    7193   ; strcpyInstruction("ASL") ;
00003EDC  4879 0000 7194          pea       @m68kde~2_224.L
00003EE0  77B4      
00003EE2  4E93      7195          jsr       (A3)
00003EE4  584F      7196          addq.w    #4,A7
00003EE6  600A      7197          bra.s     DisassembleInstruction_77
                    7198   DisassembleInstruction_76:
                    7199   ; else
                    7200   ; strcpyInstruction("ASR") ;
00003EE8  4879 0000 7201          pea       @m68kde~2_225.L
00003EEC  77B8      
00003EEE  4E93      7202          jsr       (A3)
00003EF0  584F      7203          addq.w    #4,A7
                    7204   DisassembleInstruction_77:
                    7205   ; // test direction by testing bit 8
                    7206   ; if((*OpCode & (unsigned short int)(0xFEC0)) == (unsigned short int)(0xE2C0))    //lsr/lsl
00003EF2  2042      7207          move.l    D2,A0
00003EF4  3010      7208          move.w    (A0),D0
00003EF6  C07C FEC0 7209          and.w     #65216,D0
00003EFA  0C40 E2C0 7210          cmp.w     #58048,D0
00003EFE  6624      7211          bne.s     DisassembleInstruction_81
                    7212   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003F00  2042      7213          move.l    D2,A0
00003F02  3010      7214          move.w    (A0),D0
00003F04  C07C 0100 7215          and.w     #256,D0
00003F08  0C40 0100 7216          cmp.w     #256,D0
00003F0C  660C      7217          bne.s     DisassembleInstruction_80
                    7218   ; strcpyInstruction("LSL") ;
00003F0E  4879 0000 7219          pea       @m68kde~2_226.L
00003F12  77BC      
00003F14  4E93      7220          jsr       (A3)
00003F16  584F      7221          addq.w    #4,A7
00003F18  600A      7222          bra.s     DisassembleInstruction_81
                    7223   DisassembleInstruction_80:
                    7224   ; else
                    7225   ; strcpyInstruction("LSR") ;
00003F1A  4879 0000 7226          pea       @m68kde~2_227.L
00003F1E  77C0      
00003F20  4E93      7227          jsr       (A3)
00003F22  584F      7228          addq.w    #4,A7
                    7229   DisassembleInstruction_81:
                    7230   ; // test direction by testing bit 8
                    7231   ; if((*OpCode & (unsigned short int)(0xFEC0)) == (unsigned short int)(0xE6C0))    //ror/rol
00003F24  2042      7232          move.l    D2,A0
00003F26  3010      7233          move.w    (A0),D0
00003F28  C07C FEC0 7234          and.w     #65216,D0
00003F2C  0C40 E6C0 7235          cmp.w     #59072,D0
00003F30  6624      7236          bne.s     DisassembleInstruction_85
                    7237   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003F32  2042      7238          move.l    D2,A0
00003F34  3010      7239          move.w    (A0),D0
00003F36  C07C 0100 7240          and.w     #256,D0
00003F3A  0C40 0100 7241          cmp.w     #256,D0
00003F3E  660C      7242          bne.s     DisassembleInstruction_84
                    7243   ; strcpyInstruction("ROL") ;
00003F40  4879 0000 7244          pea       @m68kde~2_228.L
00003F44  77C4      
00003F46  4E93      7245          jsr       (A3)
00003F48  584F      7246          addq.w    #4,A7
00003F4A  600A      7247          bra.s     DisassembleInstruction_85
                    7248   DisassembleInstruction_84:
                    7249   ; else
                    7250   ; strcpyInstruction("ROR") ;
00003F4C  4879 0000 7251          pea       @m68kde~2_229.L
00003F50  77C8      
00003F52  4E93      7252          jsr       (A3)
00003F54  584F      7253          addq.w    #4,A7
                    7254   DisassembleInstruction_85:
                    7255   ; // test direction by testing bit 8
                    7256   ; if((*OpCode & (unsigned short int)(0xFEC0)) == (unsigned short int)(0xE4C0))    //roxr/roxl
00003F56  2042      7257          move.l    D2,A0
00003F58  3010      7258          move.w    (A0),D0
00003F5A  C07C FEC0 7259          and.w     #65216,D0
00003F5E  0C40 E4C0 7260          cmp.w     #58560,D0
00003F62  6624      7261          bne.s     DisassembleInstruction_89
                    7262   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003F64  2042      7263          move.l    D2,A0
00003F66  3010      7264          move.w    (A0),D0
00003F68  C07C 0100 7265          and.w     #256,D0
00003F6C  0C40 0100 7266          cmp.w     #256,D0
00003F70  660C      7267          bne.s     DisassembleInstruction_88
                    7268   ; strcpyInstruction("ROXL") ;
00003F72  4879 0000 7269          pea       @m68kde~2_230.L
00003F76  77CC      
00003F78  4E93      7270          jsr       (A3)
00003F7A  584F      7271          addq.w    #4,A7
00003F7C  600A      7272          bra.s     DisassembleInstruction_89
                    7273   DisassembleInstruction_88:
                    7274   ; else
                    7275   ; strcpyInstruction("ROXR") ;
00003F7E  4879 0000 7276          pea       @m68kde~2_231.L
00003F82  77D2      
00003F84  4E93      7277          jsr       (A3)
00003F86  584F      7278          addq.w    #4,A7
                    7279   DisassembleInstruction_89:
                    7280   ; strcatInstruction("  ") ;
00003F88  4879 0000 7281          pea       @m68kde~2_15.L
00003F8C  64BE      
00003F8E  4EB8 0CCC 7282          jsr       _strcatInstruction
00003F92  584F      7283          addq.w    #4,A7
                    7284   ; Decode6BitEA(OpCode,0, 0,0) ;
00003F94  42A7      7285          clr.l     -(A7)
00003F96  42A7      7286          clr.l     -(A7)
00003F98  42A7      7287          clr.l     -(A7)
00003F9A  2F02      7288          move.l    D2,-(A7)
00003F9C  4EB8 3352 7289          jsr       _Decode6BitEA
00003FA0  DEFC 0010 7290          add.w     #16,A7
00003FA4  6000 0154 7291          bra       DisassembleInstruction_73
                    7292   DisassembleInstruction_72:
                    7293   ; }
                    7294   ; // first version of above instructions, bit 5 is 0
                    7295   ; else
                    7296   ; {
                    7297   ; // test instruction and direction by testing bits 4,3
                    7298   ; if((*OpCode & (unsigned short int)(0x0018)) == (unsigned short int)(0x0))    //asr/asl
00003FA8  2042      7299          move.l    D2,A0
00003FAA  3010      7300          move.w    (A0),D0
00003FAC  C07C 0018 7301          and.w     #24,D0
00003FB0  6624      7302          bne.s     DisassembleInstruction_93
                    7303   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003FB2  2042      7304          move.l    D2,A0
00003FB4  3010      7305          move.w    (A0),D0
00003FB6  C07C 0100 7306          and.w     #256,D0
00003FBA  0C40 0100 7307          cmp.w     #256,D0
00003FBE  660C      7308          bne.s     DisassembleInstruction_92
                    7309   ; strcpyInstruction("ASL") ;
00003FC0  4879 0000 7310          pea       @m68kde~2_224.L
00003FC4  77B4      
00003FC6  4E93      7311          jsr       (A3)
00003FC8  584F      7312          addq.w    #4,A7
00003FCA  600A      7313          bra.s     DisassembleInstruction_93
                    7314   DisassembleInstruction_92:
                    7315   ; else
                    7316   ; strcpyInstruction("ASR") ;
00003FCC  4879 0000 7317          pea       @m68kde~2_225.L
00003FD0  77B8      
00003FD2  4E93      7318          jsr       (A3)
00003FD4  584F      7319          addq.w    #4,A7
                    7320   DisassembleInstruction_93:
                    7321   ; // test instruction and direction by testing bits 4,3
                    7322   ; if((*OpCode & (unsigned short int)(0x0018)) == (unsigned short int)(0x0008))    //lsr/lsl
00003FD6  2042      7323          move.l    D2,A0
00003FD8  3010      7324          move.w    (A0),D0
00003FDA  C07C 0018 7325          and.w     #24,D0
00003FDE  0C40 0008 7326          cmp.w     #8,D0
00003FE2  6624      7327          bne.s     DisassembleInstruction_97
                    7328   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00003FE4  2042      7329          move.l    D2,A0
00003FE6  3010      7330          move.w    (A0),D0
00003FE8  C07C 0100 7331          and.w     #256,D0
00003FEC  0C40 0100 7332          cmp.w     #256,D0
00003FF0  660C      7333          bne.s     DisassembleInstruction_96
                    7334   ; strcpyInstruction("LSL") ;
00003FF2  4879 0000 7335          pea       @m68kde~2_226.L
00003FF6  77BC      
00003FF8  4E93      7336          jsr       (A3)
00003FFA  584F      7337          addq.w    #4,A7
00003FFC  600A      7338          bra.s     DisassembleInstruction_97
                    7339   DisassembleInstruction_96:
                    7340   ; else
                    7341   ; strcpyInstruction("LSR") ;
00003FFE  4879 0000 7342          pea       @m68kde~2_227.L
00004002  77C0      
00004004  4E93      7343          jsr       (A3)
00004006  584F      7344          addq.w    #4,A7
                    7345   DisassembleInstruction_97:
                    7346   ; // test instruction and direction by testing bits 4,3
                    7347   ; if((*OpCode & (unsigned short int)(0x0018)) == (unsigned short int)(0x0018))    //ror/rol
00004008  2042      7348          move.l    D2,A0
0000400A  3010      7349          move.w    (A0),D0
0000400C  C07C 0018 7350          and.w     #24,D0
00004010  0C40 0018 7351          cmp.w     #24,D0
00004014  6624      7352          bne.s     DisassembleInstruction_101
                    7353   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00004016  2042      7354          move.l    D2,A0
00004018  3010      7355          move.w    (A0),D0
0000401A  C07C 0100 7356          and.w     #256,D0
0000401E  0C40 0100 7357          cmp.w     #256,D0
00004022  660C      7358          bne.s     DisassembleInstruction_100
                    7359   ; strcpyInstruction("ROL") ;
00004024  4879 0000 7360          pea       @m68kde~2_228.L
00004028  77C4      
0000402A  4E93      7361          jsr       (A3)
0000402C  584F      7362          addq.w    #4,A7
0000402E  600A      7363          bra.s     DisassembleInstruction_101
                    7364   DisassembleInstruction_100:
                    7365   ; else
                    7366   ; strcpyInstruction("ROR") ;
00004030  4879 0000 7367          pea       @m68kde~2_229.L
00004034  77C8      
00004036  4E93      7368          jsr       (A3)
00004038  584F      7369          addq.w    #4,A7
                    7370   DisassembleInstruction_101:
                    7371   ; // test instruction and direction by testing bits 4,3
                    7372   ; if((*OpCode & (unsigned short int)(0x0018)) == (unsigned short int)(0x0010))    //roxr/roxl
0000403A  2042      7373          move.l    D2,A0
0000403C  3010      7374          move.w    (A0),D0
0000403E  C07C 0018 7375          and.w     #24,D0
00004042  0C40 0010 7376          cmp.w     #16,D0
00004046  6624      7377          bne.s     DisassembleInstruction_105
                    7378   ; if((*OpCode & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100))
00004048  2042      7379          move.l    D2,A0
0000404A  3010      7380          move.w    (A0),D0
0000404C  C07C 0100 7381          and.w     #256,D0
00004050  0C40 0100 7382          cmp.w     #256,D0
00004054  660C      7383          bne.s     DisassembleInstruction_104
                    7384   ; strcpyInstruction("ROXL") ;
00004056  4879 0000 7385          pea       @m68kde~2_230.L
0000405A  77CC      
0000405C  4E93      7386          jsr       (A3)
0000405E  584F      7387          addq.w    #4,A7
00004060  600A      7388          bra.s     DisassembleInstruction_105
                    7389   DisassembleInstruction_104:
                    7390   ; else
                    7391   ; strcpyInstruction("ROXR") ;
00004062  4879 0000 7392          pea       @m68kde~2_231.L
00004066  77D2      
00004068  4E93      7393          jsr       (A3)
0000406A  584F      7394          addq.w    #4,A7
                    7395   DisassembleInstruction_105:
                    7396   ; Decode2BitOperandSize(*OpCode) ;
0000406C  2042      7397          move.l    D2,A0
0000406E  3210      7398          move.w    (A0),D1
00004070  C2BC 0000 7399          and.l     #65535,D1
00004074  FFFF      
00004076  2F01      7400          move.l    D1,-(A7)
00004078  4EB8 30BE 7401          jsr       _Decode2BitOperandSize
0000407C  584F      7402          addq.w    #4,A7
                    7403   ; if((*OpCode & (unsigned short int)(0x0020)) == (unsigned short int)(0)) {   // if shift count defined by #value (bit 5 = 0), e.g. asl #3,d0
0000407E  2042      7404          move.l    D2,A0
00004080  3010      7405          move.w    (A0),D0
00004082  C07C 0020 7406          and.w     #32,D0
00004086  6600 0038 7407          bne       DisassembleInstruction_106
                    7408   ; sprintf(TempString,"#$%X,D%X",
0000408A  2042      7409          move.l    D2,A0
0000408C  3210      7410          move.w    (A0),D1
0000408E  C27C 0007 7411          and.w     #7,D1
00004092  C2BC 0000 7412          and.l     #65535,D1
00004096  FFFF      
00004098  2F01      7413          move.l    D1,-(A7)
0000409A  2042      7414          move.l    D2,A0
0000409C  3210      7415          move.w    (A0),D1
0000409E  E041      7416          asr.w     #8,D1
000040A0  E241      7417          asr.w     #1,D1
000040A2  C27C 0007 7418          and.w     #7,D1
000040A6  C2BC 0000 7419          and.l     #65535,D1
000040AA  FFFF      
000040AC  2F01      7420          move.l    D1,-(A7)
000040AE  4879 0000 7421          pea       @m68kde~2_232.L
000040B2  77D8      
000040B4  2F0C      7422          move.l    A4,-(A7)
000040B6  4E95      7423          jsr       (A5)
000040B8  DEFC 0010 7424          add.w     #16,A7
000040BC  6000 0034 7425          bra       DisassembleInstruction_107
                    7426   DisassembleInstruction_106:
                    7427   ; ((*OpCode >> 9) & (unsigned short int)(0x0007)),
                    7428   ; (*OpCode & (unsigned short int)(0x0007))) ;
                    7429   ; }
                    7430   ; else {                                                                      // if shift is for example ASR D1,D2
                    7431   ; sprintf(TempString,"D%X,D%X",
000040C0  2042      7432          move.l    D2,A0
000040C2  3210      7433          move.w    (A0),D1
000040C4  C27C 0007 7434          and.w     #7,D1
000040C8  C2BC 0000 7435          and.l     #65535,D1
000040CC  FFFF      
000040CE  2F01      7436          move.l    D1,-(A7)
000040D0  2042      7437          move.l    D2,A0
000040D2  3210      7438          move.w    (A0),D1
000040D4  E041      7439          asr.w     #8,D1
000040D6  E241      7440          asr.w     #1,D1
000040D8  C27C 0007 7441          and.w     #7,D1
000040DC  C2BC 0000 7442          and.l     #65535,D1
000040E0  FFFF      
000040E2  2F01      7443          move.l    D1,-(A7)
000040E4  4879 0000 7444          pea       @m68kde~2_220.L
000040E8  778A      
000040EA  2F0C      7445          move.l    A4,-(A7)
000040EC  4E95      7446          jsr       (A5)
000040EE  DEFC 0010 7447          add.w     #16,A7
                    7448   DisassembleInstruction_107:
                    7449   ; ((*OpCode >> 9) & (unsigned short int)(0x0007)),
                    7450   ; (*OpCode & (unsigned short int)(0x0007))) ;
                    7451   ; }
                    7452   ; strcatInstruction(TempString) ;
000040F2  2F0C      7453          move.l    A4,-(A7)
000040F4  4EB8 0CCC 7454          jsr       _strcatInstruction
000040F8  584F      7455          addq.w    #4,A7
                    7456   DisassembleInstruction_73:
                    7457   ; }
                    7458   ; }
                    7459   ; /////////////////////////////////////////////////////////////////////////////////
                    7460   ; // if instruction is BCC and BSR and BRA
                    7461   ; /////////////////////////////////////////////////////////////////////////////////
                    7462   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0x6000))
000040FA  2042      7463          move.l    D2,A0
000040FC  3010      7464          move.w    (A0),D0
000040FE  C07C F000 7465          and.w     #61440,D0
00004102  0C40 6000 7466          cmp.w     #24576,D0
00004106  6600 00A0 7467          bne       DisassembleInstruction_108
                    7468   ; {
                    7469   ; InstructionSize = 1;
0000410A  24BC 0000 7470          move.l    #1,(A2)
0000410E  0001      
                    7471   ; Condition = ((*OpCode >> 8) & (unsigned short int)(0xF)) ;
00004110  2042      7472          move.l    D2,A0
00004112  3010      7473          move.w    (A0),D0
00004114  E040      7474          asr.w     #8,D0
00004116  C07C 000F 7475          and.w     #15,D0
0000411A  1D40 FFE9 7476          move.b    D0,-23(A6)
                    7477   ; strcpyInstruction("B") ;
0000411E  4879 0000 7478          pea       @m68kde~2_233.L
00004122  77E2      
00004124  4E93      7479          jsr       (A3)
00004126  584F      7480          addq.w    #4,A7
                    7481   ; DecodeBranchCondition(Condition) ;
00004128  122E FFE9 7482          move.b    -23(A6),D1
0000412C  C27C 00FF 7483          and.w     #255,D1
00004130  C2BC 0000 7484          and.l     #65535,D1
00004134  FFFF      
00004136  2F01      7485          move.l    D1,-(A7)
00004138  4EB8 3810 7486          jsr       _DecodeBranchCondition
0000413C  584F      7487          addq.w    #4,A7
                    7488   ; Displacement8Bit = (*OpCode & (unsigned short int)(0xFF)) ;
0000413E  2042      7489          move.l    D2,A0
00004140  3010      7490          move.w    (A0),D0
00004142  C07C 00FF 7491          and.w     #255,D0
00004146  1D40 FFFB 7492          move.b    D0,-5(A6)
                    7493   ; if(Displacement8Bit == (unsigned short int)(0))  {           // if 16 bit displacement
0000414A  102E FFFB 7494          move.b    -5(A6),D0
0000414E  4880      7495          ext.w     D0
00004150  4A40      7496          tst.w     D0
00004152  662A      7497          bne.s     DisassembleInstruction_110
                    7498   ; sprintf(TempString, "$%X", (int)(OpCode) + (int)(OpCode[1]) +  2) ;
00004154  2202      7499          move.l    D2,D1
00004156  2042      7500          move.l    D2,A0
00004158  2F00      7501          move.l    D0,-(A7)
0000415A  3028 0002 7502          move.w    2(A0),D0
0000415E  48C0      7503          ext.l     D0
00004160  D280      7504          add.l     D0,D1
00004162  201F      7505          move.l    (A7)+,D0
00004164  5481      7506          addq.l    #2,D1
00004166  2F01      7507          move.l    D1,-(A7)
00004168  4879 0000 7508          pea       @m68kde~2_183.L
0000416C  76AE      
0000416E  2F0C      7509          move.l    A4,-(A7)
00004170  4E95      7510          jsr       (A5)
00004172  DEFC 000C 7511          add.w     #12,A7
                    7512   ; InstructionSize = 2 ;
00004176  24BC 0000 7513          move.l    #2,(A2)
0000417A  0002      
0000417C  6022      7514          bra.s     DisassembleInstruction_111
                    7515   DisassembleInstruction_110:
                    7516   ; }
                    7517   ; else
                    7518   ; sprintf(TempString, "$%X", (int)(OpCode) + Displacement8Bit + 2) ;           // 8 bit displacement
0000417E  2202      7519          move.l    D2,D1
00004180  2F00      7520          move.l    D0,-(A7)
00004182  102E FFFB 7521          move.b    -5(A6),D0
00004186  4880      7522          ext.w     D0
00004188  48C0      7523          ext.l     D0
0000418A  D280      7524          add.l     D0,D1
0000418C  201F      7525          move.l    (A7)+,D0
0000418E  5481      7526          addq.l    #2,D1
00004190  2F01      7527          move.l    D1,-(A7)
00004192  4879 0000 7528          pea       @m68kde~2_183.L
00004196  76AE      
00004198  2F0C      7529          move.l    A4,-(A7)
0000419A  4E95      7530          jsr       (A5)
0000419C  DEFC 000C 7531          add.w     #12,A7
                    7532   DisassembleInstruction_111:
                    7533   ; strcatInstruction(TempString) ;
000041A0  2F0C      7534          move.l    A4,-(A7)
000041A2  4EB8 0CCC 7535          jsr       _strcatInstruction
000041A6  584F      7536          addq.w    #4,A7
                    7537   DisassembleInstruction_108:
                    7538   ; }
                    7539   ; /////////////////////////////////////////////////////////////////////////////////
                    7540   ; // if instruction is BCHG dn,<EA>
                    7541   ; /////////////////////////////////////////////////////////////////////////////////
                    7542   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x0140))   {
000041A8  2042      7543          move.l    D2,A0
000041AA  3010      7544          move.w    (A0),D0
000041AC  C07C F1C0 7545          and.w     #61888,D0
000041B0  0C40 0140 7546          cmp.w     #320,D0
000041B4  6600 004C 7547          bne       DisassembleInstruction_112
                    7548   ; InstructionSize = 1;
000041B8  24BC 0000 7549          move.l    #1,(A2)
000041BC  0001      
                    7550   ; strcpyInstruction("BCHG ") ;
000041BE  4879 0000 7551          pea       @m68kde~2_234.L
000041C2  77E4      
000041C4  4E93      7552          jsr       (A3)
000041C6  584F      7553          addq.w    #4,A7
                    7554   ; sprintf(TempString, "D%d,", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
000041C8  2042      7555          move.l    D2,A0
000041CA  3210      7556          move.w    (A0),D1
000041CC  E041      7557          asr.w     #8,D1
000041CE  E241      7558          asr.w     #1,D1
000041D0  C27C 0007 7559          and.w     #7,D1
000041D4  C2BC 0000 7560          and.l     #65535,D1
000041D8  FFFF      
000041DA  2F01      7561          move.l    D1,-(A7)
000041DC  4879 0000 7562          pea       @m68kde~2_235.L
000041E0  77EA      
000041E2  2F0C      7563          move.l    A4,-(A7)
000041E4  4E95      7564          jsr       (A5)
000041E6  DEFC 000C 7565          add.w     #12,A7
                    7566   ; strcatInstruction(TempString) ;
000041EA  2F0C      7567          move.l    A4,-(A7)
000041EC  4EB8 0CCC 7568          jsr       _strcatInstruction
000041F0  584F      7569          addq.w    #4,A7
                    7570   ; Decode6BitEA(OpCode,0,0,0) ;
000041F2  42A7      7571          clr.l     -(A7)
000041F4  42A7      7572          clr.l     -(A7)
000041F6  42A7      7573          clr.l     -(A7)
000041F8  2F02      7574          move.l    D2,-(A7)
000041FA  4EB8 3352 7575          jsr       _Decode6BitEA
000041FE  DEFC 0010 7576          add.w     #16,A7
                    7577   DisassembleInstruction_112:
                    7578   ; }
                    7579   ; /////////////////////////////////////////////////////////////////////////////////
                    7580   ; // if instruction is BCHG #data,<EA>
                    7581   ; /////////////////////////////////////////////////////////////////////////////////
                    7582   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x0840))   {
00004202  2042      7583          move.l    D2,A0
00004204  3010      7584          move.w    (A0),D0
00004206  C07C FFC0 7585          and.w     #65472,D0
0000420A  0C40 0840 7586          cmp.w     #2112,D0
0000420E  6600 0044 7587          bne       DisassembleInstruction_114
                    7588   ; strcpyInstruction("BCHG ") ;
00004212  4879 0000 7589          pea       @m68kde~2_234.L
00004216  77E4      
00004218  4E93      7590          jsr       (A3)
0000421A  584F      7591          addq.w    #4,A7
                    7592   ; sprintf(TempString, "#$%X,", OpCode[1]) ;
0000421C  2042      7593          move.l    D2,A0
0000421E  3228 0002 7594          move.w    2(A0),D1
00004222  48C1      7595          ext.l     D1
00004224  2F01      7596          move.l    D1,-(A7)
00004226  4879 0000 7597          pea       @m68kde~2_236.L
0000422A  77F0      
0000422C  2F0C      7598          move.l    A4,-(A7)
0000422E  4E95      7599          jsr       (A5)
00004230  DEFC 000C 7600          add.w     #12,A7
                    7601   ; InstructionSize = 2 ;
00004234  24BC 0000 7602          move.l    #2,(A2)
00004238  0002      
                    7603   ; strcatInstruction(TempString) ;
0000423A  2F0C      7604          move.l    A4,-(A7)
0000423C  4EB8 0CCC 7605          jsr       _strcatInstruction
00004240  584F      7606          addq.w    #4,A7
                    7607   ; Decode6BitEA(OpCode,0,1,0) ;
00004242  42A7      7608          clr.l     -(A7)
00004244  4878 0001 7609          pea       1
00004248  42A7      7610          clr.l     -(A7)
0000424A  2F02      7611          move.l    D2,-(A7)
0000424C  4EB8 3352 7612          jsr       _Decode6BitEA
00004250  DEFC 0010 7613          add.w     #16,A7
                    7614   DisassembleInstruction_114:
                    7615   ; }
                    7616   ; /////////////////////////////////////////////////////////////////////////////////
                    7617   ; // if instruction is BCLR  dn,<EA>
                    7618   ; /////////////////////////////////////////////////////////////////////////////////
                    7619   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x0180))   {
00004254  2042      7620          move.l    D2,A0
00004256  3010      7621          move.w    (A0),D0
00004258  C07C F1C0 7622          and.w     #61888,D0
0000425C  0C40 0180 7623          cmp.w     #384,D0
00004260  6600 004C 7624          bne       DisassembleInstruction_116
                    7625   ; InstructionSize = 1;
00004264  24BC 0000 7626          move.l    #1,(A2)
00004268  0001      
                    7627   ; strcpyInstruction("BCLR ") ;
0000426A  4879 0000 7628          pea       @m68kde~2_237.L
0000426E  77F6      
00004270  4E93      7629          jsr       (A3)
00004272  584F      7630          addq.w    #4,A7
                    7631   ; sprintf(TempString, "D%d,", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00004274  2042      7632          move.l    D2,A0
00004276  3210      7633          move.w    (A0),D1
00004278  E041      7634          asr.w     #8,D1
0000427A  E241      7635          asr.w     #1,D1
0000427C  C27C 0007 7636          and.w     #7,D1
00004280  C2BC 0000 7637          and.l     #65535,D1
00004284  FFFF      
00004286  2F01      7638          move.l    D1,-(A7)
00004288  4879 0000 7639          pea       @m68kde~2_235.L
0000428C  77EA      
0000428E  2F0C      7640          move.l    A4,-(A7)
00004290  4E95      7641          jsr       (A5)
00004292  DEFC 000C 7642          add.w     #12,A7
                    7643   ; strcatInstruction(TempString) ;
00004296  2F0C      7644          move.l    A4,-(A7)
00004298  4EB8 0CCC 7645          jsr       _strcatInstruction
0000429C  584F      7646          addq.w    #4,A7
                    7647   ; Decode6BitEA(OpCode,0,0,0) ;
0000429E  42A7      7648          clr.l     -(A7)
000042A0  42A7      7649          clr.l     -(A7)
000042A2  42A7      7650          clr.l     -(A7)
000042A4  2F02      7651          move.l    D2,-(A7)
000042A6  4EB8 3352 7652          jsr       _Decode6BitEA
000042AA  DEFC 0010 7653          add.w     #16,A7
                    7654   DisassembleInstruction_116:
                    7655   ; }
                    7656   ; /////////////////////////////////////////////////////////////////////////////////
                    7657   ; // if instruction is BCLR #data,<EA>
                    7658   ; /////////////////////////////////////////////////////////////////////////////////
                    7659   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x0880))   {
000042AE  2042      7660          move.l    D2,A0
000042B0  3010      7661          move.w    (A0),D0
000042B2  C07C FFC0 7662          and.w     #65472,D0
000042B6  0C40 0880 7663          cmp.w     #2176,D0
000042BA  6600 0044 7664          bne       DisassembleInstruction_118
                    7665   ; strcpyInstruction("BCLR ") ;
000042BE  4879 0000 7666          pea       @m68kde~2_237.L
000042C2  77F6      
000042C4  4E93      7667          jsr       (A3)
000042C6  584F      7668          addq.w    #4,A7
                    7669   ; sprintf(TempString, "#$%X,", OpCode[1]) ;
000042C8  2042      7670          move.l    D2,A0
000042CA  3228 0002 7671          move.w    2(A0),D1
000042CE  48C1      7672          ext.l     D1
000042D0  2F01      7673          move.l    D1,-(A7)
000042D2  4879 0000 7674          pea       @m68kde~2_236.L
000042D6  77F0      
000042D8  2F0C      7675          move.l    A4,-(A7)
000042DA  4E95      7676          jsr       (A5)
000042DC  DEFC 000C 7677          add.w     #12,A7
                    7678   ; InstructionSize = 2 ;
000042E0  24BC 0000 7679          move.l    #2,(A2)
000042E4  0002      
                    7680   ; strcatInstruction(TempString) ;
000042E6  2F0C      7681          move.l    A4,-(A7)
000042E8  4EB8 0CCC 7682          jsr       _strcatInstruction
000042EC  584F      7683          addq.w    #4,A7
                    7684   ; Decode6BitEA(OpCode,0,1,0) ;
000042EE  42A7      7685          clr.l     -(A7)
000042F0  4878 0001 7686          pea       1
000042F4  42A7      7687          clr.l     -(A7)
000042F6  2F02      7688          move.l    D2,-(A7)
000042F8  4EB8 3352 7689          jsr       _Decode6BitEA
000042FC  DEFC 0010 7690          add.w     #16,A7
                    7691   DisassembleInstruction_118:
                    7692   ; }
                    7693   ; /////////////////////////////////////////////////////////////////////////////////
                    7694   ; // if instruction is BSET dn,<EA>
                    7695   ; /////////////////////////////////////////////////////////////////////////////////
                    7696   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x01C0))   {
00004300  2042      7697          move.l    D2,A0
00004302  3010      7698          move.w    (A0),D0
00004304  C07C F1C0 7699          and.w     #61888,D0
00004308  0C40 01C0 7700          cmp.w     #448,D0
0000430C  6600 004C 7701          bne       DisassembleInstruction_120
                    7702   ; InstructionSize = 1;
00004310  24BC 0000 7703          move.l    #1,(A2)
00004314  0001      
                    7704   ; strcpyInstruction("BSET ") ;
00004316  4879 0000 7705          pea       @m68kde~2_238.L
0000431A  77FC      
0000431C  4E93      7706          jsr       (A3)
0000431E  584F      7707          addq.w    #4,A7
                    7708   ; sprintf(TempString, "D%d,", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00004320  2042      7709          move.l    D2,A0
00004322  3210      7710          move.w    (A0),D1
00004324  E041      7711          asr.w     #8,D1
00004326  E241      7712          asr.w     #1,D1
00004328  C27C 0007 7713          and.w     #7,D1
0000432C  C2BC 0000 7714          and.l     #65535,D1
00004330  FFFF      
00004332  2F01      7715          move.l    D1,-(A7)
00004334  4879 0000 7716          pea       @m68kde~2_235.L
00004338  77EA      
0000433A  2F0C      7717          move.l    A4,-(A7)
0000433C  4E95      7718          jsr       (A5)
0000433E  DEFC 000C 7719          add.w     #12,A7
                    7720   ; strcatInstruction(TempString) ;
00004342  2F0C      7721          move.l    A4,-(A7)
00004344  4EB8 0CCC 7722          jsr       _strcatInstruction
00004348  584F      7723          addq.w    #4,A7
                    7724   ; Decode6BitEA(OpCode,0,0,0) ;
0000434A  42A7      7725          clr.l     -(A7)
0000434C  42A7      7726          clr.l     -(A7)
0000434E  42A7      7727          clr.l     -(A7)
00004350  2F02      7728          move.l    D2,-(A7)
00004352  4EB8 3352 7729          jsr       _Decode6BitEA
00004356  DEFC 0010 7730          add.w     #16,A7
                    7731   DisassembleInstruction_120:
                    7732   ; }
                    7733   ; /////////////////////////////////////////////////////////////////////////////////
                    7734   ; // if instruction is BSET #data,<EA>
                    7735   ; /////////////////////////////////////////////////////////////////////////////////
                    7736   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x08C0))   {
0000435A  2042      7737          move.l    D2,A0
0000435C  3010      7738          move.w    (A0),D0
0000435E  C07C FFC0 7739          and.w     #65472,D0
00004362  0C40 08C0 7740          cmp.w     #2240,D0
00004366  6600 0044 7741          bne       DisassembleInstruction_122
                    7742   ; strcpyInstruction("BSET ") ;
0000436A  4879 0000 7743          pea       @m68kde~2_238.L
0000436E  77FC      
00004370  4E93      7744          jsr       (A3)
00004372  584F      7745          addq.w    #4,A7
                    7746   ; sprintf(TempString, "#$%X,", OpCode[1]) ;
00004374  2042      7747          move.l    D2,A0
00004376  3228 0002 7748          move.w    2(A0),D1
0000437A  48C1      7749          ext.l     D1
0000437C  2F01      7750          move.l    D1,-(A7)
0000437E  4879 0000 7751          pea       @m68kde~2_236.L
00004382  77F0      
00004384  2F0C      7752          move.l    A4,-(A7)
00004386  4E95      7753          jsr       (A5)
00004388  DEFC 000C 7754          add.w     #12,A7
                    7755   ; InstructionSize = 2 ;
0000438C  24BC 0000 7756          move.l    #2,(A2)
00004390  0002      
                    7757   ; strcatInstruction(TempString) ;
00004392  2F0C      7758          move.l    A4,-(A7)
00004394  4EB8 0CCC 7759          jsr       _strcatInstruction
00004398  584F      7760          addq.w    #4,A7
                    7761   ; Decode6BitEA(OpCode,0,1,0) ;
0000439A  42A7      7762          clr.l     -(A7)
0000439C  4878 0001 7763          pea       1
000043A0  42A7      7764          clr.l     -(A7)
000043A2  2F02      7765          move.l    D2,-(A7)
000043A4  4EB8 3352 7766          jsr       _Decode6BitEA
000043A8  DEFC 0010 7767          add.w     #16,A7
                    7768   DisassembleInstruction_122:
                    7769   ; }
                    7770   ; /////////////////////////////////////////////////////////////////////////////////
                    7771   ; // if instruction is BTST dn,<EA>
                    7772   ; /////////////////////////////////////////////////////////////////////////////////
                    7773   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x0100))   {
000043AC  2042      7774          move.l    D2,A0
000043AE  3010      7775          move.w    (A0),D0
000043B0  C07C F1C0 7776          and.w     #61888,D0
000043B4  0C40 0100 7777          cmp.w     #256,D0
000043B8  6600 004C 7778          bne       DisassembleInstruction_124
                    7779   ; InstructionSize = 1;
000043BC  24BC 0000 7780          move.l    #1,(A2)
000043C0  0001      
                    7781   ; strcpyInstruction("BTST ") ;
000043C2  4879 0000 7782          pea       @m68kde~2_239.L
000043C6  7802      
000043C8  4E93      7783          jsr       (A3)
000043CA  584F      7784          addq.w    #4,A7
                    7785   ; sprintf(TempString, "D%d,", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
000043CC  2042      7786          move.l    D2,A0
000043CE  3210      7787          move.w    (A0),D1
000043D0  E041      7788          asr.w     #8,D1
000043D2  E241      7789          asr.w     #1,D1
000043D4  C27C 0007 7790          and.w     #7,D1
000043D8  C2BC 0000 7791          and.l     #65535,D1
000043DC  FFFF      
000043DE  2F01      7792          move.l    D1,-(A7)
000043E0  4879 0000 7793          pea       @m68kde~2_235.L
000043E4  77EA      
000043E6  2F0C      7794          move.l    A4,-(A7)
000043E8  4E95      7795          jsr       (A5)
000043EA  DEFC 000C 7796          add.w     #12,A7
                    7797   ; strcatInstruction(TempString) ;
000043EE  2F0C      7798          move.l    A4,-(A7)
000043F0  4EB8 0CCC 7799          jsr       _strcatInstruction
000043F4  584F      7800          addq.w    #4,A7
                    7801   ; Decode6BitEA(OpCode,0,0,0) ;
000043F6  42A7      7802          clr.l     -(A7)
000043F8  42A7      7803          clr.l     -(A7)
000043FA  42A7      7804          clr.l     -(A7)
000043FC  2F02      7805          move.l    D2,-(A7)
000043FE  4EB8 3352 7806          jsr       _Decode6BitEA
00004402  DEFC 0010 7807          add.w     #16,A7
                    7808   DisassembleInstruction_124:
                    7809   ; }
                    7810   ; /////////////////////////////////////////////////////////////////////////////////
                    7811   ; // if instruction is BTST #data,<EA>
                    7812   ; /////////////////////////////////////////////////////////////////////////////////
                    7813   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x0800))   {
00004406  2042      7814          move.l    D2,A0
00004408  3010      7815          move.w    (A0),D0
0000440A  C07C FFC0 7816          and.w     #65472,D0
0000440E  0C40 0800 7817          cmp.w     #2048,D0
00004412  6600 0044 7818          bne       DisassembleInstruction_126
                    7819   ; strcpyInstruction("BTST ") ;
00004416  4879 0000 7820          pea       @m68kde~2_239.L
0000441A  7802      
0000441C  4E93      7821          jsr       (A3)
0000441E  584F      7822          addq.w    #4,A7
                    7823   ; sprintf(TempString, "#$%X,", OpCode[1]) ;
00004420  2042      7824          move.l    D2,A0
00004422  3228 0002 7825          move.w    2(A0),D1
00004426  48C1      7826          ext.l     D1
00004428  2F01      7827          move.l    D1,-(A7)
0000442A  4879 0000 7828          pea       @m68kde~2_236.L
0000442E  77F0      
00004430  2F0C      7829          move.l    A4,-(A7)
00004432  4E95      7830          jsr       (A5)
00004434  DEFC 000C 7831          add.w     #12,A7
                    7832   ; InstructionSize = 2 ;
00004438  24BC 0000 7833          move.l    #2,(A2)
0000443C  0002      
                    7834   ; strcatInstruction(TempString) ;
0000443E  2F0C      7835          move.l    A4,-(A7)
00004440  4EB8 0CCC 7836          jsr       _strcatInstruction
00004444  584F      7837          addq.w    #4,A7
                    7838   ; Decode6BitEA(OpCode,0,1,0) ;
00004446  42A7      7839          clr.l     -(A7)
00004448  4878 0001 7840          pea       1
0000444C  42A7      7841          clr.l     -(A7)
0000444E  2F02      7842          move.l    D2,-(A7)
00004450  4EB8 3352 7843          jsr       _Decode6BitEA
00004454  DEFC 0010 7844          add.w     #16,A7
                    7845   DisassembleInstruction_126:
                    7846   ; }
                    7847   ; /////////////////////////////////////////////////////////////////////////////////
                    7848   ; // if instruction is CHK.W <EA>,DN
                    7849   ; /////////////////////////////////////////////////////////////////////////////////
                    7850   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x4180))   {
00004458  2042      7851          move.l    D2,A0
0000445A  3010      7852          move.w    (A0),D0
0000445C  C07C F1C0 7853          and.w     #61888,D0
00004460  0C40 4180 7854          cmp.w     #16768,D0
00004464  6600 004C 7855          bne       DisassembleInstruction_128
                    7856   ; InstructionSize = 1;
00004468  24BC 0000 7857          move.l    #1,(A2)
0000446C  0001      
                    7858   ; strcpyInstruction("CHK ") ;
0000446E  4879 0000 7859          pea       @m68kde~2_240.L
00004472  7808      
00004474  4E93      7860          jsr       (A3)
00004476  584F      7861          addq.w    #4,A7
                    7862   ; Decode6BitEA(OpCode,0,0,0) ;
00004478  42A7      7863          clr.l     -(A7)
0000447A  42A7      7864          clr.l     -(A7)
0000447C  42A7      7865          clr.l     -(A7)
0000447E  2F02      7866          move.l    D2,-(A7)
00004480  4EB8 3352 7867          jsr       _Decode6BitEA
00004484  DEFC 0010 7868          add.w     #16,A7
                    7869   ; sprintf(TempString, ",D%d", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00004488  2042      7870          move.l    D2,A0
0000448A  3210      7871          move.w    (A0),D1
0000448C  E041      7872          asr.w     #8,D1
0000448E  E241      7873          asr.w     #1,D1
00004490  C27C 0007 7874          and.w     #7,D1
00004494  C2BC 0000 7875          and.l     #65535,D1
00004498  FFFF      
0000449A  2F01      7876          move.l    D1,-(A7)
0000449C  4879 0000 7877          pea       @m68kde~2_241.L
000044A0  780E      
000044A2  2F0C      7878          move.l    A4,-(A7)
000044A4  4E95      7879          jsr       (A5)
000044A6  DEFC 000C 7880          add.w     #12,A7
                    7881   ; strcatInstruction(TempString) ;
000044AA  2F0C      7882          move.l    A4,-(A7)
000044AC  4EB8 0CCC 7883          jsr       _strcatInstruction
000044B0  584F      7884          addq.w    #4,A7
                    7885   DisassembleInstruction_128:
                    7886   ; }
                    7887   ; /////////////////////////////////////////////////////////////////////////////////
                    7888   ; // if instruction is CLR <EA>
                    7889   ; /////////////////////////////////////////////////////////////////////////////////
                    7890   ; if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x4200))   {
000044B2  2042      7891          move.l    D2,A0
000044B4  3010      7892          move.w    (A0),D0
000044B6  C07C FF00 7893          and.w     #65280,D0
000044BA  0C40 4200 7894          cmp.w     #16896,D0
000044BE  6600 0034 7895          bne       DisassembleInstruction_130
                    7896   ; InstructionSize = 1;
000044C2  24BC 0000 7897          move.l    #1,(A2)
000044C6  0001      
                    7898   ; strcpyInstruction("CLR") ;
000044C8  4879 0000 7899          pea       @m68kde~2_242.L
000044CC  7814      
000044CE  4E93      7900          jsr       (A3)
000044D0  584F      7901          addq.w    #4,A7
                    7902   ; Decode2BitOperandSize(*OpCode) ;
000044D2  2042      7903          move.l    D2,A0
000044D4  3210      7904          move.w    (A0),D1
000044D6  C2BC 0000 7905          and.l     #65535,D1
000044DA  FFFF      
000044DC  2F01      7906          move.l    D1,-(A7)
000044DE  4EB8 30BE 7907          jsr       _Decode2BitOperandSize
000044E2  584F      7908          addq.w    #4,A7
                    7909   ; Decode6BitEA(OpCode,0,0,0) ;
000044E4  42A7      7910          clr.l     -(A7)
000044E6  42A7      7911          clr.l     -(A7)
000044E8  42A7      7912          clr.l     -(A7)
000044EA  2F02      7913          move.l    D2,-(A7)
000044EC  4EB8 3352 7914          jsr       _Decode6BitEA
000044F0  DEFC 0010 7915          add.w     #16,A7
                    7916   DisassembleInstruction_130:
                    7917   ; }
                    7918   ; /////////////////////////////////////////////////////////////////////////////////
                    7919   ; // if instruction is CMP, CMPA
                    7920   ; /////////////////////////////////////////////////////////////////////////////////
                    7921   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0xB000))
000044F4  2042      7922          move.l    D2,A0
000044F6  3010      7923          move.w    (A0),D0
000044F8  C07C F000 7924          and.w     #61440,D0
000044FC  0C40 B000 7925          cmp.w     #45056,D0
00004500  6600 008C 7926          bne       DisassembleInstruction_135
                    7927   ; {
                    7928   ; InstructionSize = 1;
00004504  24BC 0000 7929          move.l    #1,(A2)
00004508  0001      
                    7930   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0007) ;
0000450A  2042      7931          move.l    D2,A0
0000450C  3010      7932          move.w    (A0),D0
0000450E  EC40      7933          asr.w     #6,D0
00004510  C07C 0007 7934          and.w     #7,D0
00004514  3600      7935          move.w    D0,D3
                    7936   ; if((OpMode == (unsigned short int)(0x0003)) || (OpMode == (unsigned short int)(0x0007)))    {
00004516  0C43 0003 7937          cmp.w     #3,D3
0000451A  6708      7938          beq.s     DisassembleInstruction_136
0000451C  0C43 0007 7939          cmp.w     #7,D3
00004520  6600 005A 7940          bne       DisassembleInstruction_134
                    7941   DisassembleInstruction_136:
                    7942   ; if(OpMode == (unsigned short int)(0x0003))
00004524  0C43 0003 7943          cmp.w     #3,D3
00004528  660C      7944          bne.s     DisassembleInstruction_137
                    7945   ; strcpyInstruction("CMPA.W ") ;
0000452A  4879 0000 7946          pea       @m68kde~2_243.L
0000452E  7818      
00004530  4E93      7947          jsr       (A3)
00004532  584F      7948          addq.w    #4,A7
00004534  600A      7949          bra.s     DisassembleInstruction_138
                    7950   DisassembleInstruction_137:
                    7951   ; else
                    7952   ; strcpyInstruction("CMPA.L ") ;
00004536  4879 0000 7953          pea       @m68kde~2_244.L
0000453A  7820      
0000453C  4E93      7954          jsr       (A3)
0000453E  584F      7955          addq.w    #4,A7
                    7956   DisassembleInstruction_138:
                    7957   ; Decode6BitEA(OpCode,0,0,0) ;
00004540  42A7      7958          clr.l     -(A7)
00004542  42A7      7959          clr.l     -(A7)
00004544  42A7      7960          clr.l     -(A7)
00004546  2F02      7961          move.l    D2,-(A7)
00004548  4EB8 3352 7962          jsr       _Decode6BitEA
0000454C  DEFC 0010 7963          add.w     #16,A7
                    7964   ; sprintf(TempString, ",A%d", ((*OpCode >> 9) & (unsigned short int)(0x0007))) ;
00004550  2042      7965          move.l    D2,A0
00004552  3210      7966          move.w    (A0),D1
00004554  E041      7967          asr.w     #8,D1
00004556  E241      7968          asr.w     #1,D1
00004558  C27C 0007 7969          and.w     #7,D1
0000455C  C2BC 0000 7970          and.l     #65535,D1
00004560  FFFF      
00004562  2F01      7971          move.l    D1,-(A7)
00004564  4879 0000 7972          pea       @m68kde~2_245.L
00004568  7828      
0000456A  2F0C      7973          move.l    A4,-(A7)
0000456C  4E95      7974          jsr       (A5)
0000456E  DEFC 000C 7975          add.w     #12,A7
                    7976   ; strcatInstruction(TempString) ;
00004572  2F0C      7977          move.l    A4,-(A7)
00004574  4EB8 0CCC 7978          jsr       _strcatInstruction
00004578  584F      7979          addq.w    #4,A7
0000457A  6012      7980          bra.s     DisassembleInstruction_135
                    7981   DisassembleInstruction_134:
                    7982   ; }
                    7983   ; else {
                    7984   ; strcpyInstruction("CMP") ;
0000457C  4879 0000 7985          pea       @m68kde~2_246.L
00004580  782E      
00004582  4E93      7986          jsr       (A3)
00004584  584F      7987          addq.w    #4,A7
                    7988   ; Decode3BitOperandMode(OpCode) ;
00004586  2F02      7989          move.l    D2,-(A7)
00004588  4EB8 377A 7990          jsr       _Decode3BitOperandMode
0000458C  584F      7991          addq.w    #4,A7
                    7992   DisassembleInstruction_135:
                    7993   ; }
                    7994   ; }
                    7995   ; /////////////////////////////////////////////////////////////////////////////////
                    7996   ; // if instruction is CMPM
                    7997   ; /////////////////////////////////////////////////////////////////////////////////
                    7998   ; if((*OpCode & (unsigned short int)(0xF138 )) == (unsigned short int)(0xB108))
0000458E  2042      7999          move.l    D2,A0
00004590  3010      8000          move.w    (A0),D0
00004592  C07C F138 8001          and.w     #61752,D0
00004596  0C40 B108 8002          cmp.w     #45320,D0
0000459A  6600 007A 8003          bne       DisassembleInstruction_141
                    8004   ; {
                    8005   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0003) ;
0000459E  2042      8006          move.l    D2,A0
000045A0  3010      8007          move.w    (A0),D0
000045A2  EC40      8008          asr.w     #6,D0
000045A4  C07C 0003 8009          and.w     #3,D0
000045A8  3600      8010          move.w    D0,D3
                    8011   ; if((OpMode >= (unsigned short int)(0x0000)) && (OpMode <= (unsigned short int)(0x0002)))
000045AA  0C43 0000 8012          cmp.w     #0,D3
000045AE  6500 0066 8013          blo       DisassembleInstruction_141
000045B2  0C43 0002 8014          cmp.w     #2,D3
000045B6  6200 005E 8015          bhi       DisassembleInstruction_141
                    8016   ; {
                    8017   ; InstructionSize = 1;
000045BA  24BC 0000 8018          move.l    #1,(A2)
000045BE  0001      
                    8019   ; strcpyInstruction("CMPM") ;
000045C0  4879 0000 8020          pea       @m68kde~2_247.L
000045C4  7832      
000045C6  4E93      8021          jsr       (A3)
000045C8  584F      8022          addq.w    #4,A7
                    8023   ; Decode2BitOperandSize(*OpCode) ;
000045CA  2042      8024          move.l    D2,A0
000045CC  3210      8025          move.w    (A0),D1
000045CE  C2BC 0000 8026          and.l     #65535,D1
000045D2  FFFF      
000045D4  2F01      8027          move.l    D1,-(A7)
000045D6  4EB8 30BE 8028          jsr       _Decode2BitOperandSize
000045DA  584F      8029          addq.w    #4,A7
                    8030   ; sprintf(TempString, "(A%d)+,(A%d)+", (*OpCode & (unsigned short int)(0x7)) , ((*OpCode >> 9) & (unsigned short int)(0x7)));
000045DC  2042      8031          move.l    D2,A0
000045DE  3210      8032          move.w    (A0),D1
000045E0  E041      8033          asr.w     #8,D1
000045E2  E241      8034          asr.w     #1,D1
000045E4  C27C 0007 8035          and.w     #7,D1
000045E8  C2BC 0000 8036          and.l     #65535,D1
000045EC  FFFF      
000045EE  2F01      8037          move.l    D1,-(A7)
000045F0  2042      8038          move.l    D2,A0
000045F2  3210      8039          move.w    (A0),D1
000045F4  C27C 0007 8040          and.w     #7,D1
000045F8  C2BC 0000 8041          and.l     #65535,D1
000045FC  FFFF      
000045FE  2F01      8042          move.l    D1,-(A7)
00004600  4879 0000 8043          pea       @m68kde~2_248.L
00004604  7838      
00004606  2F0C      8044          move.l    A4,-(A7)
00004608  4E95      8045          jsr       (A5)
0000460A  DEFC 0010 8046          add.w     #16,A7
                    8047   ; strcatInstruction(TempString) ;
0000460E  2F0C      8048          move.l    A4,-(A7)
00004610  4EB8 0CCC 8049          jsr       _strcatInstruction
00004614  584F      8050          addq.w    #4,A7
                    8051   DisassembleInstruction_141:
                    8052   ; }
                    8053   ; }
                    8054   ; /////////////////////////////////////////////////////////////////////////////////
                    8055   ; // if instruction is DBCC
                    8056   ; /////////////////////////////////////////////////////////////////////////////////
                    8057   ; if((*OpCode & (unsigned short int)(0xF0F8 )) == (unsigned short int)(0x50C8))
00004616  2042      8058          move.l    D2,A0
00004618  3010      8059          move.w    (A0),D0
0000461A  C07C F0F8 8060          and.w     #61688,D0
0000461E  0C40 50C8 8061          cmp.w     #20680,D0
00004622  6600 0084 8062          bne       DisassembleInstruction_143
                    8063   ; {
                    8064   ; InstructionSize = 2;
00004626  24BC 0000 8065          move.l    #2,(A2)
0000462A  0002      
                    8066   ; strcpy(Instruction,"DB") ;
0000462C  4879 0000 8067          pea       @m68kde~2_249.L
00004630  7846      
00004632  4879 0B00 8068          pea       _Instruction.L
00004636  04E2      
00004638  4EB9 0000 8069          jsr       _strcpy
0000463C  5808      
0000463E  504F      8070          addq.w    #8,A7
                    8071   ; Condition = ((*OpCode >> 8) & (unsigned short int)(0x000F)) ;
00004640  2042      8072          move.l    D2,A0
00004642  3010      8073          move.w    (A0),D0
00004644  E040      8074          asr.w     #8,D0
00004646  C07C 000F 8075          and.w     #15,D0
0000464A  1D40 FFE9 8076          move.b    D0,-23(A6)
                    8077   ; DecodeBranchCondition(Condition) ;
0000464E  122E FFE9 8078          move.b    -23(A6),D1
00004652  C27C 00FF 8079          and.w     #255,D1
00004656  C2BC 0000 8080          and.l     #65535,D1
0000465A  FFFF      
0000465C  2F01      8081          move.l    D1,-(A7)
0000465E  4EB8 3810 8082          jsr       _DecodeBranchCondition
00004662  584F      8083          addq.w    #4,A7
                    8084   ; sprintf(TempString, "D%d,%+d(PC) to Addr:$%X",(*OpCode & (unsigned short int)(0x7)), (int)(OpCode[1]), (int)(OpCode) + (int)(OpCode[1]) +  2) ;
00004664  2202      8085          move.l    D2,D1
00004666  2042      8086          move.l    D2,A0
00004668  2F00      8087          move.l    D0,-(A7)
0000466A  3028 0002 8088          move.w    2(A0),D0
0000466E  48C0      8089          ext.l     D0
00004670  D280      8090          add.l     D0,D1
00004672  201F      8091          move.l    (A7)+,D0
00004674  5481      8092          addq.l    #2,D1
00004676  2F01      8093          move.l    D1,-(A7)
00004678  2042      8094          move.l    D2,A0
0000467A  3228 0002 8095          move.w    2(A0),D1
0000467E  48C1      8096          ext.l     D1
00004680  2F01      8097          move.l    D1,-(A7)
00004682  2042      8098          move.l    D2,A0
00004684  3210      8099          move.w    (A0),D1
00004686  C27C 0007 8100          and.w     #7,D1
0000468A  C2BC 0000 8101          and.l     #65535,D1
0000468E  FFFF      
00004690  2F01      8102          move.l    D1,-(A7)
00004692  4879 0000 8103          pea       @m68kde~2_250.L
00004696  784A      
00004698  2F0C      8104          move.l    A4,-(A7)
0000469A  4E95      8105          jsr       (A5)
0000469C  DEFC 0014 8106          add.w     #20,A7
                    8107   ; strcatInstruction(TempString) ;
000046A0  2F0C      8108          move.l    A4,-(A7)
000046A2  4EB8 0CCC 8109          jsr       _strcatInstruction
000046A6  584F      8110          addq.w    #4,A7
                    8111   DisassembleInstruction_143:
                    8112   ; }
                    8113   ; /////////////////////////////////////////////////////////////////////////////////
                    8114   ; // if instruction is DIVS
                    8115   ; /////////////////////////////////////////////////////////////////////////////////
                    8116   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x81C0))
000046A8  2042      8117          move.l    D2,A0
000046AA  3010      8118          move.w    (A0),D0
000046AC  C07C F1C0 8119          and.w     #61888,D0
000046B0  0C40 81C0 8120          cmp.w     #33216,D0
000046B4  6600 004A 8121          bne       DisassembleInstruction_145
                    8122   ; {
                    8123   ; InstructionSize = 1;
000046B8  24BC 0000 8124          move.l    #1,(A2)
000046BC  0001      
                    8125   ; strcpy(Instruction,"DIVS ") ;
000046BE  4879 0000 8126          pea       @m68kde~2_251.L
000046C2  7862      
000046C4  4879 0B00 8127          pea       _Instruction.L
000046C8  04E2      
000046CA  4EB9 0000 8128          jsr       _strcpy
000046CE  5808      
000046D0  504F      8129          addq.w    #8,A7
                    8130   ; Decode6BitEA(OpCode,0,0,0) ;
000046D2  42A7      8131          clr.l     -(A7)
000046D4  42A7      8132          clr.l     -(A7)
000046D6  42A7      8133          clr.l     -(A7)
000046D8  2F02      8134          move.l    D2,-(A7)
000046DA  4EB8 3352 8135          jsr       _Decode6BitEA
000046DE  DEFC 0010 8136          add.w     #16,A7
                    8137   ; strcatInstruction(",") ;
000046E2  4879 0000 8138          pea       @m68kde~2_186.L
000046E6  76C2      
000046E8  4EB8 0CCC 8139          jsr       _strcatInstruction
000046EC  584F      8140          addq.w    #4,A7
                    8141   ; Decode3BitDataRegister(*OpCode) ;
000046EE  2042      8142          move.l    D2,A0
000046F0  3210      8143          move.w    (A0),D1
000046F2  C2BC 0000 8144          and.l     #65535,D1
000046F6  FFFF      
000046F8  2F01      8145          move.l    D1,-(A7)
000046FA  4EB8 311A 8146          jsr       _Decode3BitDataRegister
000046FE  584F      8147          addq.w    #4,A7
                    8148   DisassembleInstruction_145:
                    8149   ; }
                    8150   ; /////////////////////////////////////////////////////////////////////////////////
                    8151   ; // if instruction is DIVU
                    8152   ; /////////////////////////////////////////////////////////////////////////////////
                    8153   ; if((*OpCode & (unsigned short int)(0xF1C0 )) == (unsigned short int)(0x80C0))
00004700  2042      8154          move.l    D2,A0
00004702  3010      8155          move.w    (A0),D0
00004704  C07C F1C0 8156          and.w     #61888,D0
00004708  0C40 80C0 8157          cmp.w     #32960,D0
0000470C  6600 004A 8158          bne       DisassembleInstruction_147
                    8159   ; {
                    8160   ; InstructionSize = 1;
00004710  24BC 0000 8161          move.l    #1,(A2)
00004714  0001      
                    8162   ; strcpy(Instruction,"DIVU ") ;
00004716  4879 0000 8163          pea       @m68kde~2_252.L
0000471A  7868      
0000471C  4879 0B00 8164          pea       _Instruction.L
00004720  04E2      
00004722  4EB9 0000 8165          jsr       _strcpy
00004726  5808      
00004728  504F      8166          addq.w    #8,A7
                    8167   ; Decode6BitEA(OpCode,0,0,0) ;
0000472A  42A7      8168          clr.l     -(A7)
0000472C  42A7      8169          clr.l     -(A7)
0000472E  42A7      8170          clr.l     -(A7)
00004730  2F02      8171          move.l    D2,-(A7)
00004732  4EB8 3352 8172          jsr       _Decode6BitEA
00004736  DEFC 0010 8173          add.w     #16,A7
                    8174   ; strcatInstruction(",") ;
0000473A  4879 0000 8175          pea       @m68kde~2_186.L
0000473E  76C2      
00004740  4EB8 0CCC 8176          jsr       _strcatInstruction
00004744  584F      8177          addq.w    #4,A7
                    8178   ; Decode3BitDataRegister(*OpCode) ;
00004746  2042      8179          move.l    D2,A0
00004748  3210      8180          move.w    (A0),D1
0000474A  C2BC 0000 8181          and.l     #65535,D1
0000474E  FFFF      
00004750  2F01      8182          move.l    D1,-(A7)
00004752  4EB8 311A 8183          jsr       _Decode3BitDataRegister
00004756  584F      8184          addq.w    #4,A7
                    8185   DisassembleInstruction_147:
                    8186   ; }
                    8187   ; /////////////////////////////////////////////////////////////////////////////////
                    8188   ; // if instruction is EOR
                    8189   ; /////////////////////////////////////////////////////////////////////////////////
                    8190   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0xB000))   {
00004758  2042      8191          move.l    D2,A0
0000475A  3010      8192          move.w    (A0),D0
0000475C  C07C F000 8193          and.w     #61440,D0
00004760  0C40 B000 8194          cmp.w     #45056,D0
00004764  6600 004A 8195          bne       DisassembleInstruction_151
                    8196   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0007) ;
00004768  2042      8197          move.l    D2,A0
0000476A  3010      8198          move.w    (A0),D0
0000476C  EC40      8199          asr.w     #6,D0
0000476E  C07C 0007 8200          and.w     #7,D0
00004772  3600      8201          move.w    D0,D3
                    8202   ; EAMode = (*OpCode >> 3) & (unsigned short int)(0x0007) ;    // mode cannot be 1 for EOR as it it used by CMPM instruction as a differentiator
00004774  2042      8203          move.l    D2,A0
00004776  3010      8204          move.w    (A0),D0
00004778  E640      8205          asr.w     #3,D0
0000477A  C07C 0007 8206          and.w     #7,D0
0000477E  3D40 FFEC 8207          move.w    D0,-20(A6)
                    8208   ; if( (OpMode >= (unsigned short int)(0x0004)) &&
00004782  0C43 0004 8209          cmp.w     #4,D3
00004786  6528      8210          blo.s     DisassembleInstruction_151
00004788  0C43 0006 8211          cmp.w     #6,D3
0000478C  6222      8212          bhi.s     DisassembleInstruction_151
0000478E  302E FFEC 8213          move.w    -20(A6),D0
00004792  0C40 0001 8214          cmp.w     #1,D0
00004796  6718      8215          beq.s     DisassembleInstruction_151
                    8216   ; (OpMode <= (unsigned short int)(0x0006)) &&
                    8217   ; (EAMode != (unsigned short int)(0x0001)))
                    8218   ; {
                    8219   ; InstructionSize = 1;
00004798  24BC 0000 8220          move.l    #1,(A2)
0000479C  0001      
                    8221   ; strcpyInstruction("EOR") ;
0000479E  4879 0000 8222          pea       @m68kde~2_253.L
000047A2  786E      
000047A4  4E93      8223          jsr       (A3)
000047A6  584F      8224          addq.w    #4,A7
                    8225   ; Decode3BitOperandMode(OpCode);
000047A8  2F02      8226          move.l    D2,-(A7)
000047AA  4EB8 377A 8227          jsr       _Decode3BitOperandMode
000047AE  584F      8228          addq.w    #4,A7
                    8229   DisassembleInstruction_151:
                    8230   ; }
                    8231   ; }
                    8232   ; /////////////////////////////////////////////////////////////////////////////////
                    8233   ; // if instruction is EOR to CCR
                    8234   ; /////////////////////////////////////////////////////////////////////////////////
                    8235   ; if(*OpCode == (unsigned short int)(0x0A3C))   {
000047B0  2042      8236          move.l    D2,A0
000047B2  3010      8237          move.w    (A0),D0
000047B4  0C40 0A3C 8238          cmp.w     #2620,D0
000047B8  662C      8239          bne.s     DisassembleInstruction_153
                    8240   ; InstructionSize = 1;
000047BA  24BC 0000 8241          move.l    #1,(A2)
000047BE  0001      
                    8242   ; sprintf(Instruction, "EORI #$%2X,CCR", OpCode[1] & (unsigned short int)(0x00FF)) ;
000047C0  2042      8243          move.l    D2,A0
000047C2  3228 0002 8244          move.w    2(A0),D1
000047C6  C27C 00FF 8245          and.w     #255,D1
000047CA  C2BC 0000 8246          and.l     #65535,D1
000047CE  FFFF      
000047D0  2F01      8247          move.l    D1,-(A7)
000047D2  4879 0000 8248          pea       @m68kde~2_254.L
000047D6  7872      
000047D8  4879 0B00 8249          pea       _Instruction.L
000047DC  04E2      
000047DE  4E95      8250          jsr       (A5)
000047E0  DEFC 000C 8251          add.w     #12,A7
                    8252   ; InstructionSize += 1;
000047E4  5292      8253          addq.l    #1,(A2)
                    8254   DisassembleInstruction_153:
                    8255   ; }
                    8256   ; /////////////////////////////////////////////////////////////////////////////////
                    8257   ; // if instruction is EORI #data,SR
                    8258   ; /////////////////////////////////////////////////////////////////////////////////
                    8259   ; if(*OpCode  == (unsigned short int)(0x0A7C))   {
000047E6  2042      8260          move.l    D2,A0
000047E8  3010      8261          move.w    (A0),D0
000047EA  0C40 0A7C 8262          cmp.w     #2684,D0
000047EE  6622      8263          bne.s     DisassembleInstruction_155
                    8264   ; InstructionSize = 2;
000047F0  24BC 0000 8265          move.l    #2,(A2)
000047F4  0002      
                    8266   ; sprintf(Instruction, "EORI #$%X,SR", OpCode[1]);
000047F6  2042      8267          move.l    D2,A0
000047F8  3228 0002 8268          move.w    2(A0),D1
000047FC  48C1      8269          ext.l     D1
000047FE  2F01      8270          move.l    D1,-(A7)
00004800  4879 0000 8271          pea       @m68kde~2_255.L
00004804  7882      
00004806  4879 0B00 8272          pea       _Instruction.L
0000480A  04E2      
0000480C  4E95      8273          jsr       (A5)
0000480E  DEFC 000C 8274          add.w     #12,A7
                    8275   DisassembleInstruction_155:
                    8276   ; }
                    8277   ; /////////////////////////////////////////////////////////////////////////////////
                    8278   ; // if instruction is EXG
                    8279   ; /////////////////////////////////////////////////////////////////////////////////
                    8280   ; if((*OpCode & (unsigned short int)(0xF100 )) == (unsigned short int)(0xC100))   {
00004812  2042      8281          move.l    D2,A0
00004814  3010      8282          move.w    (A0),D0
00004816  C07C F100 8283          and.w     #61696,D0
0000481A  0C40 C100 8284          cmp.w     #49408,D0
0000481E  6600 00E0 8285          bne       DisassembleInstruction_163
                    8286   ; Rx = ((*OpCode >> 9) & (unsigned short int)(0x7)) ;
00004822  2042      8287          move.l    D2,A0
00004824  3010      8288          move.w    (A0),D0
00004826  E040      8289          asr.w     #8,D0
00004828  E240      8290          asr.w     #1,D0
0000482A  C07C 0007 8291          and.w     #7,D0
0000482E  3D40 FFF0 8292          move.w    D0,-16(A6)
                    8293   ; Ry = (*OpCode & (unsigned short int)(0x7)) ;
00004832  2042      8294          move.l    D2,A0
00004834  3010      8295          move.w    (A0),D0
00004836  C07C 0007 8296          and.w     #7,D0
0000483A  3D40 FFF2 8297          move.w    D0,-14(A6)
                    8298   ; EXGOpMode = ((*OpCode >> 3) & (unsigned short int)(0x1F)) ;
0000483E  2042      8299          move.l    D2,A0
00004840  3010      8300          move.w    (A0),D0
00004842  E640      8301          asr.w     #3,D0
00004844  C07C 001F 8302          and.w     #31,D0
00004848  3D40 FFF4 8303          move.w    D0,-12(A6)
                    8304   ; if(EXGOpMode == (unsigned short int)(0x0008))   {
0000484C  302E FFF4 8305          move.w    -12(A6),D0
00004850  0C40 0008 8306          cmp.w     #8,D0
00004854  6634      8307          bne.s     DisassembleInstruction_159
                    8308   ; InstructionSize = 1;
00004856  24BC 0000 8309          move.l    #1,(A2)
0000485A  0001      
                    8310   ; sprintf(Instruction, "EXG D%d,D%d", Rx, Ry) ;
0000485C  322E FFF2 8311          move.w    -14(A6),D1
00004860  C2BC 0000 8312          and.l     #65535,D1
00004864  FFFF      
00004866  2F01      8313          move.l    D1,-(A7)
00004868  322E FFF0 8314          move.w    -16(A6),D1
0000486C  C2BC 0000 8315          and.l     #65535,D1
00004870  FFFF      
00004872  2F01      8316          move.l    D1,-(A7)
00004874  4879 0000 8317          pea       @m68kde~2_256.L
00004878  7890      
0000487A  4879 0B00 8318          pea       _Instruction.L
0000487E  04E2      
00004880  4E95      8319          jsr       (A5)
00004882  DEFC 0010 8320          add.w     #16,A7
00004886  6000 0078 8321          bra       DisassembleInstruction_163
                    8322   DisassembleInstruction_159:
                    8323   ; }
                    8324   ; else if(EXGOpMode == (unsigned short int)(0x0009))  {
0000488A  302E FFF4 8325          move.w    -12(A6),D0
0000488E  0C40 0009 8326          cmp.w     #9,D0
00004892  6632      8327          bne.s     DisassembleInstruction_161
                    8328   ; InstructionSize = 1;
00004894  24BC 0000 8329          move.l    #1,(A2)
00004898  0001      
                    8330   ; sprintf(Instruction, "EXG A%d,A%d", Rx, Ry) ;
0000489A  322E FFF2 8331          move.w    -14(A6),D1
0000489E  C2BC 0000 8332          and.l     #65535,D1
000048A2  FFFF      
000048A4  2F01      8333          move.l    D1,-(A7)
000048A6  322E FFF0 8334          move.w    -16(A6),D1
000048AA  C2BC 0000 8335          and.l     #65535,D1
000048AE  FFFF      
000048B0  2F01      8336          move.l    D1,-(A7)
000048B2  4879 0000 8337          pea       @m68kde~2_257.L
000048B6  789C      
000048B8  4879 0B00 8338          pea       _Instruction.L
000048BC  04E2      
000048BE  4E95      8339          jsr       (A5)
000048C0  DEFC 0010 8340          add.w     #16,A7
000048C4  603A      8341          bra.s     DisassembleInstruction_163
                    8342   DisassembleInstruction_161:
                    8343   ; }
                    8344   ; else if(EXGOpMode == (unsigned short int)(0x0011))  {
000048C6  302E FFF4 8345          move.w    -12(A6),D0
000048CA  0C40 0011 8346          cmp.w     #17,D0
000048CE  6630      8347          bne.s     DisassembleInstruction_163
                    8348   ; InstructionSize = 1;
000048D0  24BC 0000 8349          move.l    #1,(A2)
000048D4  0001      
                    8350   ; sprintf(Instruction, "EXG D%d,A%d", Rx, Ry) ;
000048D6  322E FFF2 8351          move.w    -14(A6),D1
000048DA  C2BC 0000 8352          and.l     #65535,D1
000048DE  FFFF      
000048E0  2F01      8353          move.l    D1,-(A7)
000048E2  322E FFF0 8354          move.w    -16(A6),D1
000048E6  C2BC 0000 8355          and.l     #65535,D1
000048EA  FFFF      
000048EC  2F01      8356          move.l    D1,-(A7)
000048EE  4879 0000 8357          pea       @m68kde~2_258.L
000048F2  78A8      
000048F4  4879 0B00 8358          pea       _Instruction.L
000048F8  04E2      
000048FA  4E95      8359          jsr       (A5)
000048FC  DEFC 0010 8360          add.w     #16,A7
                    8361   DisassembleInstruction_163:
                    8362   ; }
                    8363   ; }
                    8364   ; /////////////////////////////////////////////////////////////////////////////////
                    8365   ; // if instruction is EXT
                    8366   ; /////////////////////////////////////////////////////////////////////////////////
                    8367   ; if((*OpCode & (unsigned short int)(0xFE38)) == (unsigned short int)(0x4800))
00004900  2042      8368          move.l    D2,A0
00004902  3010      8369          move.w    (A0),D0
00004904  C07C FE38 8370          and.w     #65080,D0
00004908  0C40 4800 8371          cmp.w     #18432,D0
0000490C  6600 0054 8372          bne       DisassembleInstruction_165
                    8373   ; {
                    8374   ; InstructionSize = 1;
00004910  24BC 0000 8375          move.l    #1,(A2)
00004914  0001      
                    8376   ; strcpy(Instruction,"EXT") ;
00004916  4879 0000 8377          pea       @m68kde~2_259.L
0000491A  78B4      
0000491C  4879 0B00 8378          pea       _Instruction.L
00004920  04E2      
00004922  4EB9 0000 8379          jsr       _strcpy
00004926  5808      
00004928  504F      8380          addq.w    #8,A7
                    8381   ; if((*OpCode & (unsigned short int)(0x00C0)) == (unsigned short int)(0x00C0))
0000492A  2042      8382          move.l    D2,A0
0000492C  3010      8383          move.w    (A0),D0
0000492E  C07C 00C0 8384          and.w     #192,D0
00004932  0C40 00C0 8385          cmp.w     #192,D0
00004936  660E      8386          bne.s     DisassembleInstruction_167
                    8387   ; strcatInstruction(".L ") ;
00004938  4879 0000 8388          pea       @m68kde~2_170.L
0000493C  7678      
0000493E  4EB8 0CCC 8389          jsr       _strcatInstruction
00004942  584F      8390          addq.w    #4,A7
00004944  600C      8391          bra.s     DisassembleInstruction_168
                    8392   DisassembleInstruction_167:
                    8393   ; else
                    8394   ; strcatInstruction(".W ") ;
00004946  4879 0000 8395          pea       @m68kde~2_169.L
0000494A  7674      
0000494C  4EB8 0CCC 8396          jsr       _strcatInstruction
00004950  584F      8397          addq.w    #4,A7
                    8398   DisassembleInstruction_168:
                    8399   ; Decode6BitEA(OpCode,0,0,0) ;
00004952  42A7      8400          clr.l     -(A7)
00004954  42A7      8401          clr.l     -(A7)
00004956  42A7      8402          clr.l     -(A7)
00004958  2F02      8403          move.l    D2,-(A7)
0000495A  4EB8 3352 8404          jsr       _Decode6BitEA
0000495E  DEFC 0010 8405          add.w     #16,A7
                    8406   DisassembleInstruction_165:
                    8407   ; }
                    8408   ; /////////////////////////////////////////////////////////////////////////////////
                    8409   ; // if instruction is ILLEGAL $4afc
                    8410   ; /////////////////////////////////////////////////////////////////////////////////
                    8411   ; if(*OpCode == (unsigned short int)(0x4AFC)) {
00004962  2042      8412          move.l    D2,A0
00004964  3010      8413          move.w    (A0),D0
00004966  0C40 4AFC 8414          cmp.w     #19196,D0
0000496A  661A      8415          bne.s     DisassembleInstruction_169
                    8416   ; InstructionSize = 1;
0000496C  24BC 0000 8417          move.l    #1,(A2)
00004970  0001      
                    8418   ; strcpy(Instruction,"ILLEGAL ($4AFC)") ;
00004972  4879 0000 8419          pea       @m68kde~2_260.L
00004976  78B8      
00004978  4879 0B00 8420          pea       _Instruction.L
0000497C  04E2      
0000497E  4EB9 0000 8421          jsr       _strcpy
00004982  5808      
00004984  504F      8422          addq.w    #8,A7
                    8423   DisassembleInstruction_169:
                    8424   ; }
                    8425   ; /////////////////////////////////////////////////////////////////////////////////
                    8426   ; // if instruction is JMP
                    8427   ; /////////////////////////////////////////////////////////////////////////////////
                    8428   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x4EC0))
00004986  2042      8429          move.l    D2,A0
00004988  3010      8430          move.w    (A0),D0
0000498A  C07C FFC0 8431          and.w     #65472,D0
0000498E  0C40 4EC0 8432          cmp.w     #20160,D0
00004992  662A      8433          bne.s     DisassembleInstruction_171
                    8434   ; {
                    8435   ; InstructionSize = 1;
00004994  24BC 0000 8436          move.l    #1,(A2)
00004998  0001      
                    8437   ; strcpy(Instruction,"JMP ") ;
0000499A  4879 0000 8438          pea       @m68kde~2_261.L
0000499E  78C8      
000049A0  4879 0B00 8439          pea       _Instruction.L
000049A4  04E2      
000049A6  4EB9 0000 8440          jsr       _strcpy
000049AA  5808      
000049AC  504F      8441          addq.w    #8,A7
                    8442   ; Decode6BitEA(OpCode,0,0,0) ;
000049AE  42A7      8443          clr.l     -(A7)
000049B0  42A7      8444          clr.l     -(A7)
000049B2  42A7      8445          clr.l     -(A7)
000049B4  2F02      8446          move.l    D2,-(A7)
000049B6  4EB8 3352 8447          jsr       _Decode6BitEA
000049BA  DEFC 0010 8448          add.w     #16,A7
                    8449   DisassembleInstruction_171:
                    8450   ; }
                    8451   ; /////////////////////////////////////////////////////////////////////////////////
                    8452   ; // if instruction is JSR
                    8453   ; /////////////////////////////////////////////////////////////////////////////////
                    8454   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x4E80))
000049BE  2042      8455          move.l    D2,A0
000049C0  3010      8456          move.w    (A0),D0
000049C2  C07C FFC0 8457          and.w     #65472,D0
000049C6  0C40 4E80 8458          cmp.w     #20096,D0
000049CA  662A      8459          bne.s     DisassembleInstruction_173
                    8460   ; {
                    8461   ; InstructionSize = 1;
000049CC  24BC 0000 8462          move.l    #1,(A2)
000049D0  0001      
                    8463   ; strcpy(Instruction,"JSR ") ;
000049D2  4879 0000 8464          pea       @m68kde~2_262.L
000049D6  78CE      
000049D8  4879 0B00 8465          pea       _Instruction.L
000049DC  04E2      
000049DE  4EB9 0000 8466          jsr       _strcpy
000049E2  5808      
000049E4  504F      8467          addq.w    #8,A7
                    8468   ; Decode6BitEA(OpCode,0,0,0) ;
000049E6  42A7      8469          clr.l     -(A7)
000049E8  42A7      8470          clr.l     -(A7)
000049EA  42A7      8471          clr.l     -(A7)
000049EC  2F02      8472          move.l    D2,-(A7)
000049EE  4EB8 3352 8473          jsr       _Decode6BitEA
000049F2  DEFC 0010 8474          add.w     #16,A7
                    8475   DisassembleInstruction_173:
                    8476   ; }
                    8477   ; /////////////////////////////////////////////////////////////////////////////////
                    8478   ; // if instruction is LEA
                    8479   ; /////////////////////////////////////////////////////////////////////////////////
                    8480   ; if((*OpCode & (unsigned short int)(0xF1C0)) == (unsigned short int)(0x41C0))
000049F6  2042      8481          move.l    D2,A0
000049F8  3010      8482          move.w    (A0),D0
000049FA  C07C F1C0 8483          and.w     #61888,D0
000049FE  0C40 41C0 8484          cmp.w     #16832,D0
00004A02  6600 0056 8485          bne       DisassembleInstruction_175
                    8486   ; {
                    8487   ; InstructionSize = 1;
00004A06  24BC 0000 8488          move.l    #1,(A2)
00004A0A  0001      
                    8489   ; strcpy(Instruction,"LEA ") ;
00004A0C  4879 0000 8490          pea       @m68kde~2_263.L
00004A10  78D4      
00004A12  4879 0B00 8491          pea       _Instruction.L
00004A16  04E2      
00004A18  4EB9 0000 8492          jsr       _strcpy
00004A1C  5808      
00004A1E  504F      8493          addq.w    #8,A7
                    8494   ; Decode6BitEA(OpCode,0,0,0) ;
00004A20  42A7      8495          clr.l     -(A7)
00004A22  42A7      8496          clr.l     -(A7)
00004A24  42A7      8497          clr.l     -(A7)
00004A26  2F02      8498          move.l    D2,-(A7)
00004A28  4EB8 3352 8499          jsr       _Decode6BitEA
00004A2C  DEFC 0010 8500          add.w     #16,A7
                    8501   ; sprintf(TempString, ",A%d", ((*OpCode >> 9) & (unsigned short int)(0x7)));
00004A30  2042      8502          move.l    D2,A0
00004A32  3210      8503          move.w    (A0),D1
00004A34  E041      8504          asr.w     #8,D1
00004A36  E241      8505          asr.w     #1,D1
00004A38  C27C 0007 8506          and.w     #7,D1
00004A3C  C2BC 0000 8507          and.l     #65535,D1
00004A40  FFFF      
00004A42  2F01      8508          move.l    D1,-(A7)
00004A44  4879 0000 8509          pea       @m68kde~2_245.L
00004A48  7828      
00004A4A  2F0C      8510          move.l    A4,-(A7)
00004A4C  4E95      8511          jsr       (A5)
00004A4E  DEFC 000C 8512          add.w     #12,A7
                    8513   ; strcatInstruction(TempString);
00004A52  2F0C      8514          move.l    A4,-(A7)
00004A54  4EB8 0CCC 8515          jsr       _strcatInstruction
00004A58  584F      8516          addq.w    #4,A7
                    8517   DisassembleInstruction_175:
                    8518   ; }
                    8519   ; /////////////////////////////////////////////////////////////////////////////////
                    8520   ; // if instruction is LINK.W
                    8521   ; /////////////////////////////////////////////////////////////////////////////////
                    8522   ; if((*OpCode & (unsigned short int)(0xFFF8)) == (unsigned short int)(0x4E50))
00004A5A  2042      8523          move.l    D2,A0
00004A5C  3010      8524          move.w    (A0),D0
00004A5E  C07C FFF8 8525          and.w     #65528,D0
00004A62  0C40 4E50 8526          cmp.w     #20048,D0
00004A66  6600 0052 8527          bne       DisassembleInstruction_177
                    8528   ; {
                    8529   ; InstructionSize = 1;
00004A6A  24BC 0000 8530          move.l    #1,(A2)
00004A6E  0001      
                    8531   ; strcpy(Instruction,"LINK ") ;
00004A70  4879 0000 8532          pea       @m68kde~2_264.L
00004A74  78DA      
00004A76  4879 0B00 8533          pea       _Instruction.L
00004A7A  04E2      
00004A7C  4EB9 0000 8534          jsr       _strcpy
00004A80  5808      
00004A82  504F      8535          addq.w    #8,A7
                    8536   ; sprintf(TempString, "A%d,#%d", ((*OpCode) & (unsigned short int)(0x7)),OpCode[1]);
00004A84  2042      8537          move.l    D2,A0
00004A86  3228 0002 8538          move.w    2(A0),D1
00004A8A  48C1      8539          ext.l     D1
00004A8C  2F01      8540          move.l    D1,-(A7)
00004A8E  2042      8541          move.l    D2,A0
00004A90  3210      8542          move.w    (A0),D1
00004A92  C27C 0007 8543          and.w     #7,D1
00004A96  C2BC 0000 8544          and.l     #65535,D1
00004A9A  FFFF      
00004A9C  2F01      8545          move.l    D1,-(A7)
00004A9E  4879 0000 8546          pea       @m68kde~2_265.L
00004AA2  78E0      
00004AA4  2F0C      8547          move.l    A4,-(A7)
00004AA6  4E95      8548          jsr       (A5)
00004AA8  DEFC 0010 8549          add.w     #16,A7
                    8550   ; InstructionSize = 2 ;
00004AAC  24BC 0000 8551          move.l    #2,(A2)
00004AB0  0002      
                    8552   ; strcatInstruction(TempString);
00004AB2  2F0C      8553          move.l    A4,-(A7)
00004AB4  4EB8 0CCC 8554          jsr       _strcatInstruction
00004AB8  584F      8555          addq.w    #4,A7
                    8556   DisassembleInstruction_177:
                    8557   ; }
                    8558   ; /////////////////////////////////////////////////////////////////////////////////
                    8559   ; // if instruction is MOVE, MOVEA
                    8560   ; /////////////////////////////////////////////////////////////////////////////////
                    8561   ; if((*OpCode & (unsigned short int)(0xC000)) == (unsigned short int)(0x0000))
00004ABA  2042      8562          move.l    D2,A0
00004ABC  3010      8563          move.w    (A0),D0
00004ABE  C07C C000 8564          and.w     #49152,D0
00004AC2  6600 00F0 8565          bne       DisassembleInstruction_193
                    8566   ; {
                    8567   ; Size = (*OpCode & (unsigned short int)(0x3000)) >> 12 ;   // get 2 bit size in bits 13/12 into 1,0
00004AC6  2042      8568          move.l    D2,A0
00004AC8  3010      8569          move.w    (A0),D0
00004ACA  C07C 3000 8570          and.w     #12288,D0
00004ACE  E048      8571          lsr.w     #8,D0
00004AD0  E848      8572          lsr.w     #4,D0
00004AD2  3D40 FFE2 8573          move.w    D0,-30(A6)
                    8574   ; OpMode = (*OpCode >> 3) & (unsigned short int)(0x0007);   // get 3 bit source mode operand
00004AD6  2042      8575          move.l    D2,A0
00004AD8  3010      8576          move.w    (A0),D0
00004ADA  E640      8577          asr.w     #3,D0
00004ADC  C07C 0007 8578          and.w     #7,D0
00004AE0  3600      8579          move.w    D0,D3
                    8580   ; SourceReg = (*OpCode) & (unsigned short int)(0x0007);     // get 3 bit source register number
00004AE2  2042      8581          move.l    D2,A0
00004AE4  3010      8582          move.w    (A0),D0
00004AE6  C07C 0007 8583          and.w     #7,D0
00004AEA  3D40 FFF6 8584          move.w    D0,-10(A6)
                    8585   ; DataSize = 0 ;
00004AEE  7E00      8586          moveq     #0,D7
                    8587   ; // if source addressing mode is d16(a0) or d8(a0,d0)
                    8588   ; if((OpMode == (unsigned short int)(0x0005)) || (OpMode == (unsigned short int)(0x0006)))
00004AF0  0C43 0005 8589          cmp.w     #5,D3
00004AF4  6706      8590          beq.s     DisassembleInstruction_183
00004AF6  0C43 0006 8591          cmp.w     #6,D3
00004AFA  6602      8592          bne.s     DisassembleInstruction_181
                    8593   DisassembleInstruction_183:
                    8594   ; DataSize = 1;  // source operands has 1 word after EA
00004AFC  7E01      8595          moveq     #1,D7
                    8596   DisassembleInstruction_181:
                    8597   ; // if source addressing mode is a 16 or 32 bit address
                    8598   ; if((OpMode == (unsigned short int)(0x0007))) {
00004AFE  0C43 0007 8599          cmp.w     #7,D3
00004B02  660C      8600          bne.s     DisassembleInstruction_187
                    8601   ; if(SourceReg == (unsigned short int)(0x0000))         // short address
00004B04  302E FFF6 8602          move.w    -10(A6),D0
00004B08  6604      8603          bne.s     DisassembleInstruction_186
                    8604   ; DataSize = 1 ;
00004B0A  7E01      8605          moveq     #1,D7
00004B0C  6002      8606          bra.s     DisassembleInstruction_187
                    8607   DisassembleInstruction_186:
                    8608   ; else
                    8609   ; DataSize = 2 ;
00004B0E  7E02      8610          moveq     #2,D7
                    8611   DisassembleInstruction_187:
                    8612   ; }
                    8613   ; // if source addressing mode is # then figure out size
                    8614   ; if((OpMode == (unsigned short int)(0x0007)) && (SourceReg == (unsigned short int)(0x0004)))    {
00004B10  0C43 0007 8615          cmp.w     #7,D3
00004B14  6624      8616          bne.s     DisassembleInstruction_191
00004B16  302E FFF6 8617          move.w    -10(A6),D0
00004B1A  0C40 0004 8618          cmp.w     #4,D0
00004B1E  661A      8619          bne.s     DisassembleInstruction_191
                    8620   ; if((Size == (unsigned short int)(1)) || (Size == (unsigned short int)(3)))
00004B20  302E FFE2 8621          move.w    -30(A6),D0
00004B24  0C40 0001 8622          cmp.w     #1,D0
00004B28  670A      8623          beq.s     DisassembleInstruction_192
00004B2A  302E FFE2 8624          move.w    -30(A6),D0
00004B2E  0C40 0003 8625          cmp.w     #3,D0
00004B32  6604      8626          bne.s     DisassembleInstruction_190
                    8627   DisassembleInstruction_192:
                    8628   ; DataSize = 1;
00004B34  7E01      8629          moveq     #1,D7
00004B36  6002      8630          bra.s     DisassembleInstruction_191
                    8631   DisassembleInstruction_190:
                    8632   ; else
                    8633   ; DataSize = 2 ;
00004B38  7E02      8634          moveq     #2,D7
                    8635   DisassembleInstruction_191:
                    8636   ; //printf("DataSize = %d",DataSize) ;
                    8637   ; }
                    8638   ; if(Size != 0)
00004B3A  302E FFE2 8639          move.w    -30(A6),D0
00004B3E  6700 0074 8640          beq       DisassembleInstruction_193
                    8641   ; {
                    8642   ; InstructionSize = 1;
00004B42  24BC 0000 8643          move.l    #1,(A2)
00004B46  0001      
                    8644   ; if(Size == 1)
00004B48  302E FFE2 8645          move.w    -30(A6),D0
00004B4C  0C40 0001 8646          cmp.w     #1,D0
00004B50  660C      8647          bne.s     DisassembleInstruction_195
                    8648   ; strcpyInstruction("MOVE.B ") ;
00004B52  4879 0000 8649          pea       @m68kde~2_266.L
00004B56  78E8      
00004B58  4E93      8650          jsr       (A3)
00004B5A  584F      8651          addq.w    #4,A7
00004B5C  6020      8652          bra.s     DisassembleInstruction_198
                    8653   DisassembleInstruction_195:
                    8654   ; else if(Size == 2)
00004B5E  302E FFE2 8655          move.w    -30(A6),D0
00004B62  0C40 0002 8656          cmp.w     #2,D0
00004B66  660C      8657          bne.s     DisassembleInstruction_197
                    8658   ; strcpyInstruction("MOVE.L ") ;
00004B68  4879 0000 8659          pea       @m68kde~2_267.L
00004B6C  78F0      
00004B6E  4E93      8660          jsr       (A3)
00004B70  584F      8661          addq.w    #4,A7
00004B72  600A      8662          bra.s     DisassembleInstruction_198
                    8663   DisassembleInstruction_197:
                    8664   ; else
                    8665   ; strcpyInstruction("MOVE.W ") ;
00004B74  4879 0000 8666          pea       @m68kde~2_268.L
00004B78  78F8      
00004B7A  4E93      8667          jsr       (A3)
00004B7C  584F      8668          addq.w    #4,A7
                    8669   DisassembleInstruction_198:
                    8670   ; Decode6BitEA(OpCode,0,0,1) ;
00004B7E  4878 0001 8671          pea       1
00004B82  42A7      8672          clr.l     -(A7)
00004B84  42A7      8673          clr.l     -(A7)
00004B86  2F02      8674          move.l    D2,-(A7)
00004B88  4EB8 3352 8675          jsr       _Decode6BitEA
00004B8C  DEFC 0010 8676          add.w     #16,A7
                    8677   ; strcatInstruction(",") ;
00004B90  4879 0000 8678          pea       @m68kde~2_186.L
00004B94  76C2      
00004B96  4EB8 0CCC 8679          jsr       _strcatInstruction
00004B9A  584F      8680          addq.w    #4,A7
                    8681   ; // tell next function how many words lie between opcode and destination, could be 1 or 2 e.g. with # addressing move.bwl #$data,<EA>
                    8682   ; // but subtract 1 to make the maths correct in the called function
                    8683   ; Decode6BitEA(OpCode,2,(DataSize),0) ;
00004B9C  42A7      8684          clr.l     -(A7)
00004B9E  CEBC 0000 8685          and.l     #65535,D7
00004BA2  FFFF      
00004BA4  2F07      8686          move.l    D7,-(A7)
00004BA6  4878 0002 8687          pea       2
00004BAA  2F02      8688          move.l    D2,-(A7)
00004BAC  4EB8 3352 8689          jsr       _Decode6BitEA
00004BB0  DEFC 0010 8690          add.w     #16,A7
                    8691   DisassembleInstruction_193:
                    8692   ; }
                    8693   ; }
                    8694   ; /////////////////////////////////////////////////////////////////////////////////
                    8695   ; // if instruction is MOVE <EA>,CCR
                    8696   ; /////////////////////////////////////////////////////////////////////////////////
                    8697   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x44C0))
00004BB4  2042      8698          move.l    D2,A0
00004BB6  3010      8699          move.w    (A0),D0
00004BB8  C07C FFC0 8700          and.w     #65472,D0
00004BBC  0C40 44C0 8701          cmp.w     #17600,D0
00004BC0  6636      8702          bne.s     DisassembleInstruction_199
                    8703   ; {
                    8704   ; InstructionSize = 1;
00004BC2  24BC 0000 8705          move.l    #1,(A2)
00004BC6  0001      
                    8706   ; strcpy(Instruction,"MOVE ") ;
00004BC8  4879 0000 8707          pea       @m68kde~2_269.L
00004BCC  7900      
00004BCE  4879 0B00 8708          pea       _Instruction.L
00004BD2  04E2      
00004BD4  4EB9 0000 8709          jsr       _strcpy
00004BD8  5808      
00004BDA  504F      8710          addq.w    #8,A7
                    8711   ; Decode6BitEA(OpCode,0,0,0) ;
00004BDC  42A7      8712          clr.l     -(A7)
00004BDE  42A7      8713          clr.l     -(A7)
00004BE0  42A7      8714          clr.l     -(A7)
00004BE2  2F02      8715          move.l    D2,-(A7)
00004BE4  4EB8 3352 8716          jsr       _Decode6BitEA
00004BE8  DEFC 0010 8717          add.w     #16,A7
                    8718   ; strcatInstruction(",CCR") ;
00004BEC  4879 0000 8719          pea       @m68kde~2_270.L
00004BF0  7906      
00004BF2  4EB8 0CCC 8720          jsr       _strcatInstruction
00004BF6  584F      8721          addq.w    #4,A7
                    8722   DisassembleInstruction_199:
                    8723   ; }
                    8724   ; /////////////////////////////////////////////////////////////////////////////////
                    8725   ; // if instruction is MOVE SR,<EA>
                    8726   ; /////////////////////////////////////////////////////////////////////////////////
                    8727   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x40C0))
00004BF8  2042      8728          move.l    D2,A0
00004BFA  3010      8729          move.w    (A0),D0
00004BFC  C07C FFC0 8730          and.w     #65472,D0
00004C00  0C40 40C0 8731          cmp.w     #16576,D0
00004C04  662A      8732          bne.s     DisassembleInstruction_201
                    8733   ; {
                    8734   ; InstructionSize = 1;
00004C06  24BC 0000 8735          move.l    #1,(A2)
00004C0A  0001      
                    8736   ; strcpy(Instruction,"MOVE SR,") ;
00004C0C  4879 0000 8737          pea       @m68kde~2_271.L
00004C10  790C      
00004C12  4879 0B00 8738          pea       _Instruction.L
00004C16  04E2      
00004C18  4EB9 0000 8739          jsr       _strcpy
00004C1C  5808      
00004C1E  504F      8740          addq.w    #8,A7
                    8741   ; Decode6BitEA(OpCode,0,0,0) ;
00004C20  42A7      8742          clr.l     -(A7)
00004C22  42A7      8743          clr.l     -(A7)
00004C24  42A7      8744          clr.l     -(A7)
00004C26  2F02      8745          move.l    D2,-(A7)
00004C28  4EB8 3352 8746          jsr       _Decode6BitEA
00004C2C  DEFC 0010 8747          add.w     #16,A7
                    8748   DisassembleInstruction_201:
                    8749   ; }
                    8750   ; /////////////////////////////////////////////////////////////////////////////////
                    8751   ; // if instruction is MOVE <EA>,SR
                    8752   ; /////////////////////////////////////////////////////////////////////////////////
                    8753   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x46C0))
00004C30  2042      8754          move.l    D2,A0
00004C32  3010      8755          move.w    (A0),D0
00004C34  C07C FFC0 8756          and.w     #65472,D0
00004C38  0C40 46C0 8757          cmp.w     #18112,D0
00004C3C  6636      8758          bne.s     DisassembleInstruction_203
                    8759   ; {
                    8760   ; InstructionSize = 1;
00004C3E  24BC 0000 8761          move.l    #1,(A2)
00004C42  0001      
                    8762   ; strcpy(Instruction,"MOVE ") ;
00004C44  4879 0000 8763          pea       @m68kde~2_269.L
00004C48  7900      
00004C4A  4879 0B00 8764          pea       _Instruction.L
00004C4E  04E2      
00004C50  4EB9 0000 8765          jsr       _strcpy
00004C54  5808      
00004C56  504F      8766          addq.w    #8,A7
                    8767   ; Decode6BitEA(OpCode,0,0,0) ;
00004C58  42A7      8768          clr.l     -(A7)
00004C5A  42A7      8769          clr.l     -(A7)
00004C5C  42A7      8770          clr.l     -(A7)
00004C5E  2F02      8771          move.l    D2,-(A7)
00004C60  4EB8 3352 8772          jsr       _Decode6BitEA
00004C64  DEFC 0010 8773          add.w     #16,A7
                    8774   ; strcatInstruction(",SR") ;
00004C68  4879 0000 8775          pea       @m68kde~2_272.L
00004C6C  7916      
00004C6E  4EB8 0CCC 8776          jsr       _strcatInstruction
00004C72  584F      8777          addq.w    #4,A7
                    8778   DisassembleInstruction_203:
                    8779   ; }
                    8780   ; /////////////////////////////////////////////////////////////////////////////////
                    8781   ; // if instruction is MOVE USP,An
                    8782   ; /////////////////////////////////////////////////////////////////////////////////
                    8783   ; if((*OpCode & (unsigned short int)(0xFFF0)) == (unsigned short int)(0x4E60))
00004C74  2042      8784          move.l    D2,A0
00004C76  3010      8785          move.w    (A0),D0
00004C78  C07C FFF0 8786          and.w     #65520,D0
00004C7C  0C40 4E60 8787          cmp.w     #20064,D0
00004C80  6600 0060 8788          bne       DisassembleInstruction_208
                    8789   ; {
                    8790   ; InstructionSize = 1;
00004C84  24BC 0000 8791          move.l    #1,(A2)
00004C88  0001      
                    8792   ; Register = (*OpCode & (unsigned short int)(0x0007)) ;
00004C8A  2042      8793          move.l    D2,A0
00004C8C  3010      8794          move.w    (A0),D0
00004C8E  C07C 0007 8795          and.w     #7,D0
00004C92  3D40 FFEA 8796          move.w    D0,-22(A6)
                    8797   ; if((*OpCode & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008))        // transfer sp to address regier
00004C96  2042      8798          move.l    D2,A0
00004C98  3010      8799          move.w    (A0),D0
00004C9A  C07C 0008 8800          and.w     #8,D0
00004C9E  0C40 0008 8801          cmp.w     #8,D0
00004CA2  6620      8802          bne.s     DisassembleInstruction_207
                    8803   ; sprintf(Instruction, "MOVE USP,A%d", Register);
00004CA4  322E FFEA 8804          move.w    -22(A6),D1
00004CA8  C2BC 0000 8805          and.l     #65535,D1
00004CAC  FFFF      
00004CAE  2F01      8806          move.l    D1,-(A7)
00004CB0  4879 0000 8807          pea       @m68kde~2_273.L
00004CB4  791A      
00004CB6  4879 0B00 8808          pea       _Instruction.L
00004CBA  04E2      
00004CBC  4E95      8809          jsr       (A5)
00004CBE  DEFC 000C 8810          add.w     #12,A7
00004CC2  601E      8811          bra.s     DisassembleInstruction_208
                    8812   DisassembleInstruction_207:
                    8813   ; else
                    8814   ; sprintf(Instruction, "MOVE A%d,USP", Register);
00004CC4  322E FFEA 8815          move.w    -22(A6),D1
00004CC8  C2BC 0000 8816          and.l     #65535,D1
00004CCC  FFFF      
00004CCE  2F01      8817          move.l    D1,-(A7)
00004CD0  4879 0000 8818          pea       @m68kde~2_274.L
00004CD4  7928      
00004CD6  4879 0B00 8819          pea       _Instruction.L
00004CDA  04E2      
00004CDC  4E95      8820          jsr       (A5)
00004CDE  DEFC 000C 8821          add.w     #12,A7
                    8822   DisassembleInstruction_208:
                    8823   ; }
                    8824   ; /////////////////////////////////////////////////////////////////////////////////
                    8825   ; // if instruction is MOVEM
                    8826   ; /////////////////////////////////////////////////////////////////////////////////
                    8827   ; if((*OpCode & (unsigned short int)(0xFB80)) == (unsigned short int)(0x4880))
00004CE2  2042      8828          move.l    D2,A0
00004CE4  3010      8829          move.w    (A0),D0
00004CE6  C07C FB80 8830          and.w     #64384,D0
00004CEA  0C40 4880 8831          cmp.w     #18560,D0
00004CEE  6600 01FC 8832          bne       DisassembleInstruction_230
                    8833   ; {
                    8834   ; OpMode = (*OpCode >> 3) & (unsigned short int)(0x0007) ;
00004CF2  2042      8835          move.l    D2,A0
00004CF4  3010      8836          move.w    (A0),D0
00004CF6  E640      8837          asr.w     #3,D0
00004CF8  C07C 0007 8838          and.w     #7,D0
00004CFC  3600      8839          move.w    D0,D3
                    8840   ; if( (OpMode != (unsigned short int)(0x0)) &&
00004CFE  4A43      8841          tst.w     D3
00004D00  6700 01EA 8842          beq       DisassembleInstruction_230
00004D04  0C43 0001 8843          cmp.w     #1,D3
00004D08  6700 01E2 8844          beq       DisassembleInstruction_230
00004D0C  4A43      8845          tst.w     D3
00004D0E  6700 01DC 8846          beq       DisassembleInstruction_230
                    8847   ; (OpMode != (unsigned short int)(0x1)) &&
                    8848   ; (OpMode != (unsigned short int)(0x0)))
                    8849   ; {
                    8850   ; InstructionSize = 1;
00004D12  24BC 0000 8851          move.l    #1,(A2)
00004D16  0001      
                    8852   ; strcpy(Instruction,"MOVEM") ;
00004D18  4879 0000 8853          pea       @m68kde~2_275.L
00004D1C  7936      
00004D1E  4879 0B00 8854          pea       _Instruction.L
00004D22  04E2      
00004D24  4EB9 0000 8855          jsr       _strcpy
00004D28  5808      
00004D2A  504F      8856          addq.w    #8,A7
                    8857   ; InstructionSize ++ ;
00004D2C  5292      8858          addq.l    #1,(A2)
                    8859   ; if((*OpCode & (unsigned short int)(0x0040)) == (unsigned short int)(0x0))
00004D2E  2042      8860          move.l    D2,A0
00004D30  3010      8861          move.w    (A0),D0
00004D32  C07C 0040 8862          and.w     #64,D0
00004D36  660E      8863          bne.s     DisassembleInstruction_213
                    8864   ; strcatInstruction(".W ") ;
00004D38  4879 0000 8865          pea       @m68kde~2_169.L
00004D3C  7674      
00004D3E  4EB8 0CCC 8866          jsr       _strcatInstruction
00004D42  584F      8867          addq.w    #4,A7
00004D44  600C      8868          bra.s     DisassembleInstruction_214
                    8869   DisassembleInstruction_213:
                    8870   ; else
                    8871   ; strcatInstruction(".L ") ;
00004D46  4879 0000 8872          pea       @m68kde~2_170.L
00004D4A  7678      
00004D4C  4EB8 0CCC 8873          jsr       _strcatInstruction
00004D50  584F      8874          addq.w    #4,A7
                    8875   DisassembleInstruction_214:
                    8876   ; // movem  reg,-(An) if bit 10 = 0
                    8877   ; if((*OpCode & (unsigned short int)(0x0400))  == (unsigned short int)(0x0000))
00004D52  2042      8878          move.l    D2,A0
00004D54  3010      8879          move.w    (A0),D0
00004D56  C07C 0400 8880          and.w     #1024,D0
00004D5A  6600 00D2 8881          bne       DisassembleInstruction_215
                    8882   ; {
                    8883   ; Mask = 0x8000 ;                     // bit 15 = 1
00004D5E  3D7C 8000 8884          move.w    #32768,-2(A6)
00004D62  FFFE      
                    8885   ; DoneSlash = 0 ;
00004D64  4246      8886          clr.w     D6
                    8887   ; for(i = 0; i < 16; i ++)    {
00004D66  4284      8888          clr.l     D4
                    8889   DisassembleInstruction_217:
00004D68  0C84 0000 8890          cmp.l     #16,D4
00004D6C  0010      
00004D6E  6C00 009E 8891          bge       DisassembleInstruction_219
                    8892   ; printf("") ;    // fixes bug otherwise the address registers doen't get printed (don't know why), something to do with sprintf I guess
00004D72  4879 0000 8893          pea       @m68kde~2_35.L
00004D76  66D8      
00004D78  4EB9 0000 8894          jsr       _printf
00004D7C  5AA4      
00004D7E  584F      8895          addq.w    #4,A7
                    8896   ; if((OpCode[1] & Mask) == Mask)    {
00004D80  2042      8897          move.l    D2,A0
00004D82  3028 0002 8898          move.w    2(A0),D0
00004D86  C06E FFFE 8899          and.w     -2(A6),D0
00004D8A  B06E FFFE 8900          cmp.w     -2(A6),D0
00004D8E  6600 006E 8901          bne       DisassembleInstruction_220
                    8902   ; if(i < 8 )  {
00004D92  0C84 0000 8903          cmp.l     #8,D4
00004D96  0008      
00004D98  6C2C      8904          bge.s     DisassembleInstruction_222
                    8905   ; if(DoneSlash == 0)  {
00004D9A  4A46      8906          tst.w     D6
00004D9C  6614      8907          bne.s     DisassembleInstruction_224
                    8908   ; sprintf(TempString, "D%d", i) ;
00004D9E  2F04      8909          move.l    D4,-(A7)
00004DA0  4879 0000 8910          pea       @m68kde~2_276.L
00004DA4  793C      
00004DA6  2F0C      8911          move.l    A4,-(A7)
00004DA8  4E95      8912          jsr       (A5)
00004DAA  DEFC 000C 8913          add.w     #12,A7
                    8914   ; DoneSlash = 1;
00004DAE  7C01      8915          moveq     #1,D6
00004DB0  6010      8916          bra.s     DisassembleInstruction_225
                    8917   DisassembleInstruction_224:
                    8918   ; }
                    8919   ; else
                    8920   ; sprintf(TempString, "/D%d", i) ;
00004DB2  2F04      8921          move.l    D4,-(A7)
00004DB4  4879 0000 8922          pea       @m68kde~2_277.L
00004DB8  7940      
00004DBA  2F0C      8923          move.l    A4,-(A7)
00004DBC  4E95      8924          jsr       (A5)
00004DBE  DEFC 000C 8925          add.w     #12,A7
                    8926   DisassembleInstruction_225:
00004DC2  6000 0032 8927          bra       DisassembleInstruction_227
                    8928   DisassembleInstruction_222:
                    8929   ; }
                    8930   ; else   {
                    8931   ; if(DoneSlash == 0)  {
00004DC6  4A46      8932          tst.w     D6
00004DC8  6618      8933          bne.s     DisassembleInstruction_226
                    8934   ; sprintf(TempString, "A%d", i-8) ;
00004DCA  2204      8935          move.l    D4,D1
00004DCC  5181      8936          subq.l    #8,D1
00004DCE  2F01      8937          move.l    D1,-(A7)
00004DD0  4879 0000 8938          pea       @m68kde~2_278.L
00004DD4  7946      
00004DD6  2F0C      8939          move.l    A4,-(A7)
00004DD8  4E95      8940          jsr       (A5)
00004DDA  DEFC 000C 8941          add.w     #12,A7
                    8942   ; DoneSlash = 1;
00004DDE  7C01      8943          moveq     #1,D6
00004DE0  6014      8944          bra.s     DisassembleInstruction_227
                    8945   DisassembleInstruction_226:
                    8946   ; }
                    8947   ; else
                    8948   ; sprintf(TempString, "/A%d", i-8) ;
00004DE2  2204      8949          move.l    D4,D1
00004DE4  5181      8950          subq.l    #8,D1
00004DE6  2F01      8951          move.l    D1,-(A7)
00004DE8  4879 0000 8952          pea       @m68kde~2_279.L
00004DEC  794A      
00004DEE  2F0C      8953          move.l    A4,-(A7)
00004DF0  4E95      8954          jsr       (A5)
00004DF2  DEFC 000C 8955          add.w     #12,A7
                    8956   DisassembleInstruction_227:
                    8957   ; }
                    8958   ; strcatInstruction(TempString) ;
00004DF6  2F0C      8959          move.l    A4,-(A7)
00004DF8  4EB8 0CCC 8960          jsr       _strcatInstruction
00004DFC  584F      8961          addq.w    #4,A7
                    8962   DisassembleInstruction_220:
                    8963   ; }
                    8964   ; Mask = Mask >> 1 ;
00004DFE  302E FFFE 8965          move.w    -2(A6),D0
00004E02  E240      8966          asr.w     #1,D0
00004E04  3D40 FFFE 8967          move.w    D0,-2(A6)
00004E08  5284      8968          addq.l    #1,D4
00004E0A  6000 FF5C 8969          bra       DisassembleInstruction_217
                    8970   DisassembleInstruction_219:
                    8971   ; }
                    8972   ; strcatInstruction(",") ;
00004E0E  4879 0000 8973          pea       @m68kde~2_186.L
00004E12  76C2      
00004E14  4EB8 0CCC 8974          jsr       _strcatInstruction
00004E18  584F      8975          addq.w    #4,A7
                    8976   ; Decode6BitEA(OpCode,0,0,0) ;
00004E1A  42A7      8977          clr.l     -(A7)
00004E1C  42A7      8978          clr.l     -(A7)
00004E1E  42A7      8979          clr.l     -(A7)
00004E20  2F02      8980          move.l    D2,-(A7)
00004E22  4EB8 3352 8981          jsr       _Decode6BitEA
00004E26  DEFC 0010 8982          add.w     #16,A7
00004E2A  6000 00C0 8983          bra       DisassembleInstruction_230
                    8984   DisassembleInstruction_215:
                    8985   ; }
                    8986   ; //movem  (An)+,reg
                    8987   ; else    {
                    8988   ; Decode6BitEA(OpCode,0,0,0) ;
00004E2E  42A7      8989          clr.l     -(A7)
00004E30  42A7      8990          clr.l     -(A7)
00004E32  42A7      8991          clr.l     -(A7)
00004E34  2F02      8992          move.l    D2,-(A7)
00004E36  4EB8 3352 8993          jsr       _Decode6BitEA
00004E3A  DEFC 0010 8994          add.w     #16,A7
                    8995   ; strcatInstruction(",") ;
00004E3E  4879 0000 8996          pea       @m68kde~2_186.L
00004E42  76C2      
00004E44  4EB8 0CCC 8997          jsr       _strcatInstruction
00004E48  584F      8998          addq.w    #4,A7
                    8999   ; Mask = 0x0001 ;                     // bit 0 = 1
00004E4A  3D7C 0001 9000          move.w    #1,-2(A6)
00004E4E  FFFE      
                    9001   ; DoneSlash = 0 ;
00004E50  4246      9002          clr.w     D6
                    9003   ; for(i = 0; i < 16 ; i ++)    {
00004E52  4284      9004          clr.l     D4
                    9005   DisassembleInstruction_228:
00004E54  0C84 0000 9006          cmp.l     #16,D4
00004E58  0010      
00004E5A  6C00 0090 9007          bge       DisassembleInstruction_230
                    9008   ; if((OpCode[1] & Mask) == Mask)    {
00004E5E  2042      9009          move.l    D2,A0
00004E60  3028 0002 9010          move.w    2(A0),D0
00004E64  C06E FFFE 9011          and.w     -2(A6),D0
00004E68  B06E FFFE 9012          cmp.w     -2(A6),D0
00004E6C  6600 006E 9013          bne       DisassembleInstruction_231
                    9014   ; if(i < 8)   {       // data registers in bits 7-0
00004E70  0C84 0000 9015          cmp.l     #8,D4
00004E74  0008      
00004E76  6C2C      9016          bge.s     DisassembleInstruction_233
                    9017   ; if(DoneSlash == 0)  {
00004E78  4A46      9018          tst.w     D6
00004E7A  6614      9019          bne.s     DisassembleInstruction_235
                    9020   ; sprintf(TempString, "D%d", i) ;
00004E7C  2F04      9021          move.l    D4,-(A7)
00004E7E  4879 0000 9022          pea       @m68kde~2_276.L
00004E82  793C      
00004E84  2F0C      9023          move.l    A4,-(A7)
00004E86  4E95      9024          jsr       (A5)
00004E88  DEFC 000C 9025          add.w     #12,A7
                    9026   ; DoneSlash = 1;
00004E8C  7C01      9027          moveq     #1,D6
00004E8E  6010      9028          bra.s     DisassembleInstruction_236
                    9029   DisassembleInstruction_235:
                    9030   ; }
                    9031   ; else
                    9032   ; sprintf(TempString, "/D%d", i) ;
00004E90  2F04      9033          move.l    D4,-(A7)
00004E92  4879 0000 9034          pea       @m68kde~2_277.L
00004E96  7940      
00004E98  2F0C      9035          move.l    A4,-(A7)
00004E9A  4E95      9036          jsr       (A5)
00004E9C  DEFC 000C 9037          add.w     #12,A7
                    9038   DisassembleInstruction_236:
00004EA0  6000 0032 9039          bra       DisassembleInstruction_238
                    9040   DisassembleInstruction_233:
                    9041   ; }
                    9042   ; else    {
                    9043   ; if(DoneSlash == 0)  {
00004EA4  4A46      9044          tst.w     D6
00004EA6  6618      9045          bne.s     DisassembleInstruction_237
                    9046   ; sprintf(TempString, "A%d", i-8) ;
00004EA8  2204      9047          move.l    D4,D1
00004EAA  5181      9048          subq.l    #8,D1
00004EAC  2F01      9049          move.l    D1,-(A7)
00004EAE  4879 0000 9050          pea       @m68kde~2_278.L
00004EB2  7946      
00004EB4  2F0C      9051          move.l    A4,-(A7)
00004EB6  4E95      9052          jsr       (A5)
00004EB8  DEFC 000C 9053          add.w     #12,A7
                    9054   ; DoneSlash = 1;
00004EBC  7C01      9055          moveq     #1,D6
00004EBE  6014      9056          bra.s     DisassembleInstruction_238
                    9057   DisassembleInstruction_237:
                    9058   ; }
                    9059   ; else
                    9060   ; sprintf(TempString, "/A%d", i-8) ;
00004EC0  2204      9061          move.l    D4,D1
00004EC2  5181      9062          subq.l    #8,D1
00004EC4  2F01      9063          move.l    D1,-(A7)
00004EC6  4879 0000 9064          pea       @m68kde~2_279.L
00004ECA  794A      
00004ECC  2F0C      9065          move.l    A4,-(A7)
00004ECE  4E95      9066          jsr       (A5)
00004ED0  DEFC 000C 9067          add.w     #12,A7
                    9068   DisassembleInstruction_238:
                    9069   ; }
                    9070   ; strcatInstruction(TempString) ;
00004ED4  2F0C      9071          move.l    A4,-(A7)
00004ED6  4EB8 0CCC 9072          jsr       _strcatInstruction
00004EDA  584F      9073          addq.w    #4,A7
                    9074   DisassembleInstruction_231:
                    9075   ; }
                    9076   ; Mask = Mask << 1 ;
00004EDC  302E FFFE 9077          move.w    -2(A6),D0
00004EE0  E340      9078          asl.w     #1,D0
00004EE2  3D40 FFFE 9079          move.w    D0,-2(A6)
00004EE6  5284      9080          addq.l    #1,D4
00004EE8  6000 FF6A 9081          bra       DisassembleInstruction_228
                    9082   DisassembleInstruction_230:
                    9083   ; }
                    9084   ; }
                    9085   ; }
                    9086   ; }
                    9087   ; /////////////////////////////////////////////////////////////////////////////////
                    9088   ; // if instruction is MOVEP
                    9089   ; /////////////////////////////////////////////////////////////////////////////////
                    9090   ; if((*OpCode & (unsigned short int)(0xF038)) == (unsigned short int)(0x0008))
00004EEC  2042      9091          move.l    D2,A0
00004EEE  3010      9092          move.w    (A0),D0
00004EF0  C07C F038 9093          and.w     #61496,D0
00004EF4  0C40 0008 9094          cmp.w     #8,D0
00004EF8  6600 0112 9095          bne       DisassembleInstruction_247
                    9096   ; {
                    9097   ; InstructionSize = 1;
00004EFC  24BC 0000 9098          move.l    #1,(A2)
00004F00  0001      
                    9099   ; DataRegister = (*OpCode >> 9) & (unsigned short int)(0x0007);
00004F02  2042      9100          move.l    D2,A0
00004F04  3010      9101          move.w    (A0),D0
00004F06  E040      9102          asr.w     #8,D0
00004F08  E240      9103          asr.w     #1,D0
00004F0A  C07C 0007 9104          and.w     #7,D0
00004F0E  3A00      9105          move.w    D0,D5
                    9106   ; AddressRegister = (*OpCode & (unsigned short int)(0x0007)) ;
00004F10  2042      9107          move.l    D2,A0
00004F12  3010      9108          move.w    (A0),D0
00004F14  C07C 0007 9109          and.w     #7,D0
00004F18  3D40 FFF8 9110          move.w    D0,-8(A6)
                    9111   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0007)  ;
00004F1C  2042      9112          move.l    D2,A0
00004F1E  3010      9113          move.w    (A0),D0
00004F20  EC40      9114          asr.w     #6,D0
00004F22  C07C 0007 9115          and.w     #7,D0
00004F26  3600      9116          move.w    D0,D3
                    9117   ; InstructionSize++ ;
00004F28  5292      9118          addq.l    #1,(A2)
                    9119   ; if(OpMode == (unsigned short int)(0x4)) // transfer word from memory to register
00004F2A  0C43 0004 9120          cmp.w     #4,D3
00004F2E  6634      9121          bne.s     DisassembleInstruction_241
                    9122   ; sprintf(Instruction, "MOVEP.W $%X(A%d),D%d", OpCode[1], AddressRegister, DataRegister) ;
00004F30  CABC 0000 9123          and.l     #65535,D5
00004F34  FFFF      
00004F36  2F05      9124          move.l    D5,-(A7)
00004F38  322E FFF8 9125          move.w    -8(A6),D1
00004F3C  C2BC 0000 9126          and.l     #65535,D1
00004F40  FFFF      
00004F42  2F01      9127          move.l    D1,-(A7)
00004F44  2042      9128          move.l    D2,A0
00004F46  3228 0002 9129          move.w    2(A0),D1
00004F4A  48C1      9130          ext.l     D1
00004F4C  2F01      9131          move.l    D1,-(A7)
00004F4E  4879 0000 9132          pea       @m68kde~2_280.L
00004F52  7950      
00004F54  4879 0B00 9133          pea       _Instruction.L
00004F58  04E2      
00004F5A  4E95      9134          jsr       (A5)
00004F5C  DEFC 0014 9135          add.w     #20,A7
00004F60  6000 00AA 9136          bra       DisassembleInstruction_247
                    9137   DisassembleInstruction_241:
                    9138   ; else if(OpMode == (unsigned short int)(0x5)) // transfer long from memory to register
00004F64  0C43 0005 9139          cmp.w     #5,D3
00004F68  6634      9140          bne.s     DisassembleInstruction_243
                    9141   ; sprintf(Instruction, "MOVEP.L $%X(A%d),D%d", OpCode[1], AddressRegister, DataRegister) ;
00004F6A  CABC 0000 9142          and.l     #65535,D5
00004F6E  FFFF      
00004F70  2F05      9143          move.l    D5,-(A7)
00004F72  322E FFF8 9144          move.w    -8(A6),D1
00004F76  C2BC 0000 9145          and.l     #65535,D1
00004F7A  FFFF      
00004F7C  2F01      9146          move.l    D1,-(A7)
00004F7E  2042      9147          move.l    D2,A0
00004F80  3228 0002 9148          move.w    2(A0),D1
00004F84  48C1      9149          ext.l     D1
00004F86  2F01      9150          move.l    D1,-(A7)
00004F88  4879 0000 9151          pea       @m68kde~2_281.L
00004F8C  7966      
00004F8E  4879 0B00 9152          pea       _Instruction.L
00004F92  04E2      
00004F94  4E95      9153          jsr       (A5)
00004F96  DEFC 0014 9154          add.w     #20,A7
00004F9A  6000 0070 9155          bra       DisassembleInstruction_247
                    9156   DisassembleInstruction_243:
                    9157   ; else if(OpMode == (unsigned short int)(0x6)) // transfer long from register to memory
00004F9E  0C43 0006 9158          cmp.w     #6,D3
00004FA2  6632      9159          bne.s     DisassembleInstruction_245
                    9160   ; sprintf(Instruction, "MOVEP.W D%d,$%X(A%d)", DataRegister, OpCode[1], AddressRegister ) ;
00004FA4  322E FFF8 9161          move.w    -8(A6),D1
00004FA8  C2BC 0000 9162          and.l     #65535,D1
00004FAC  FFFF      
00004FAE  2F01      9163          move.l    D1,-(A7)
00004FB0  2042      9164          move.l    D2,A0
00004FB2  3228 0002 9165          move.w    2(A0),D1
00004FB6  48C1      9166          ext.l     D1
00004FB8  2F01      9167          move.l    D1,-(A7)
00004FBA  CABC 0000 9168          and.l     #65535,D5
00004FBE  FFFF      
00004FC0  2F05      9169          move.l    D5,-(A7)
00004FC2  4879 0000 9170          pea       @m68kde~2_282.L
00004FC6  797C      
00004FC8  4879 0B00 9171          pea       _Instruction.L
00004FCC  04E2      
00004FCE  4E95      9172          jsr       (A5)
00004FD0  DEFC 0014 9173          add.w     #20,A7
00004FD4  6036      9174          bra.s     DisassembleInstruction_247
                    9175   DisassembleInstruction_245:
                    9176   ; else if(OpMode == (unsigned short int)(0x7)) // transfer long from register to memory
00004FD6  0C43 0007 9177          cmp.w     #7,D3
00004FDA  6630      9178          bne.s     DisassembleInstruction_247
                    9179   ; sprintf(Instruction, "MOVEP.L D%d,$%X(A%d)", DataRegister, OpCode[1], AddressRegister ) ;
00004FDC  322E FFF8 9180          move.w    -8(A6),D1
00004FE0  C2BC 0000 9181          and.l     #65535,D1
00004FE4  FFFF      
00004FE6  2F01      9182          move.l    D1,-(A7)
00004FE8  2042      9183          move.l    D2,A0
00004FEA  3228 0002 9184          move.w    2(A0),D1
00004FEE  48C1      9185          ext.l     D1
00004FF0  2F01      9186          move.l    D1,-(A7)
00004FF2  CABC 0000 9187          and.l     #65535,D5
00004FF6  FFFF      
00004FF8  2F05      9188          move.l    D5,-(A7)
00004FFA  4879 0000 9189          pea       @m68kde~2_283.L
00004FFE  7992      
00005000  4879 0B00 9190          pea       _Instruction.L
00005004  04E2      
00005006  4E95      9191          jsr       (A5)
00005008  DEFC 0014 9192          add.w     #20,A7
                    9193   DisassembleInstruction_247:
                    9194   ; }
                    9195   ; /////////////////////////////////////////////////////////////////////////////////
                    9196   ; // if instruction is MOVEQ
                    9197   ; /////////////////////////////////////////////////////////////////////////////////
                    9198   ; if((*OpCode & (unsigned short int)(0xF100)) == (unsigned short int)(0x7000))
0000500C  2042      9199          move.l    D2,A0
0000500E  3010      9200          move.w    (A0),D0
00005010  C07C F100 9201          and.w     #61696,D0
00005014  0C40 7000 9202          cmp.w     #28672,D0
00005018  6600 0040 9203          bne       DisassembleInstruction_249
                    9204   ; {
                    9205   ; InstructionSize = 1;
0000501C  24BC 0000 9206          move.l    #1,(A2)
00005020  0001      
                    9207   ; DataRegister = (*OpCode >> 9) & (unsigned short int)(0x0007) ;
00005022  2042      9208          move.l    D2,A0
00005024  3010      9209          move.w    (A0),D0
00005026  E040      9210          asr.w     #8,D0
00005028  E240      9211          asr.w     #1,D0
0000502A  C07C 0007 9212          and.w     #7,D0
0000502E  3A00      9213          move.w    D0,D5
                    9214   ; sprintf(Instruction, "MOVEQ #$%X,D%d", (*OpCode & (unsigned short int)(0x00FF)), DataRegister) ;
00005030  CABC 0000 9215          and.l     #65535,D5
00005034  FFFF      
00005036  2F05      9216          move.l    D5,-(A7)
00005038  2042      9217          move.l    D2,A0
0000503A  3210      9218          move.w    (A0),D1
0000503C  C27C 00FF 9219          and.w     #255,D1
00005040  C2BC 0000 9220          and.l     #65535,D1
00005044  FFFF      
00005046  2F01      9221          move.l    D1,-(A7)
00005048  4879 0000 9222          pea       @m68kde~2_284.L
0000504C  79A8      
0000504E  4879 0B00 9223          pea       _Instruction.L
00005052  04E2      
00005054  4E95      9224          jsr       (A5)
00005056  DEFC 0010 9225          add.w     #16,A7
                    9226   DisassembleInstruction_249:
                    9227   ; }
                    9228   ; /////////////////////////////////////////////////////////////////////////////////
                    9229   ; // if instruction is MULS.W
                    9230   ; /////////////////////////////////////////////////////////////////////////////////
                    9231   ; if((*OpCode & (unsigned short int)(0xF1C0)) == (unsigned short int)(0xC1C0))
0000505A  2042      9232          move.l    D2,A0
0000505C  3010      9233          move.w    (A0),D0
0000505E  C07C F1C0 9234          and.w     #61888,D0
00005062  0C40 C1C0 9235          cmp.w     #49600,D0
00005066  6600 004E 9236          bne       DisassembleInstruction_251
                    9237   ; {
                    9238   ; InstructionSize = 1;
0000506A  24BC 0000 9239          move.l    #1,(A2)
0000506E  0001      
                    9240   ; DataRegister = (*OpCode >> 9) & (unsigned short int)(0x0007);
00005070  2042      9241          move.l    D2,A0
00005072  3010      9242          move.w    (A0),D0
00005074  E040      9243          asr.w     #8,D0
00005076  E240      9244          asr.w     #1,D0
00005078  C07C 0007 9245          and.w     #7,D0
0000507C  3A00      9246          move.w    D0,D5
                    9247   ; strcpyInstruction("MULS ");
0000507E  4879 0000 9248          pea       @m68kde~2_285.L
00005082  79B8      
00005084  4E93      9249          jsr       (A3)
00005086  584F      9250          addq.w    #4,A7
                    9251   ; Decode6BitEA(OpCode,0,0,0) ;
00005088  42A7      9252          clr.l     -(A7)
0000508A  42A7      9253          clr.l     -(A7)
0000508C  42A7      9254          clr.l     -(A7)
0000508E  2F02      9255          move.l    D2,-(A7)
00005090  4EB8 3352 9256          jsr       _Decode6BitEA
00005094  DEFC 0010 9257          add.w     #16,A7
                    9258   ; sprintf(TempString, ",D%d", DataRegister) ;
00005098  CABC 0000 9259          and.l     #65535,D5
0000509C  FFFF      
0000509E  2F05      9260          move.l    D5,-(A7)
000050A0  4879 0000 9261          pea       @m68kde~2_241.L
000050A4  780E      
000050A6  2F0C      9262          move.l    A4,-(A7)
000050A8  4E95      9263          jsr       (A5)
000050AA  DEFC 000C 9264          add.w     #12,A7
                    9265   ; strcatInstruction(TempString);
000050AE  2F0C      9266          move.l    A4,-(A7)
000050B0  4EB8 0CCC 9267          jsr       _strcatInstruction
000050B4  584F      9268          addq.w    #4,A7
                    9269   DisassembleInstruction_251:
                    9270   ; }
                    9271   ; /////////////////////////////////////////////////////////////////////////////////
                    9272   ; // if instruction is MULU.W
                    9273   ; /////////////////////////////////////////////////////////////////////////////////
                    9274   ; if((*OpCode & (unsigned short int)(0xF1C0)) == (unsigned short int)(0xC0C0))
000050B6  2042      9275          move.l    D2,A0
000050B8  3010      9276          move.w    (A0),D0
000050BA  C07C F1C0 9277          and.w     #61888,D0
000050BE  0C40 C0C0 9278          cmp.w     #49344,D0
000050C2  6600 004E 9279          bne       DisassembleInstruction_253
                    9280   ; {
                    9281   ; InstructionSize = 1;
000050C6  24BC 0000 9282          move.l    #1,(A2)
000050CA  0001      
                    9283   ; DataRegister = (*OpCode >> 9) & (unsigned short int)(0x0007);
000050CC  2042      9284          move.l    D2,A0
000050CE  3010      9285          move.w    (A0),D0
000050D0  E040      9286          asr.w     #8,D0
000050D2  E240      9287          asr.w     #1,D0
000050D4  C07C 0007 9288          and.w     #7,D0
000050D8  3A00      9289          move.w    D0,D5
                    9290   ; strcpyInstruction("MULU ");
000050DA  4879 0000 9291          pea       @m68kde~2_286.L
000050DE  79BE      
000050E0  4E93      9292          jsr       (A3)
000050E2  584F      9293          addq.w    #4,A7
                    9294   ; Decode6BitEA(OpCode,0,0,0) ;
000050E4  42A7      9295          clr.l     -(A7)
000050E6  42A7      9296          clr.l     -(A7)
000050E8  42A7      9297          clr.l     -(A7)
000050EA  2F02      9298          move.l    D2,-(A7)
000050EC  4EB8 3352 9299          jsr       _Decode6BitEA
000050F0  DEFC 0010 9300          add.w     #16,A7
                    9301   ; sprintf(TempString, ",D%d", DataRegister) ;
000050F4  CABC 0000 9302          and.l     #65535,D5
000050F8  FFFF      
000050FA  2F05      9303          move.l    D5,-(A7)
000050FC  4879 0000 9304          pea       @m68kde~2_241.L
00005100  780E      
00005102  2F0C      9305          move.l    A4,-(A7)
00005104  4E95      9306          jsr       (A5)
00005106  DEFC 000C 9307          add.w     #12,A7
                    9308   ; strcatInstruction(TempString);
0000510A  2F0C      9309          move.l    A4,-(A7)
0000510C  4EB8 0CCC 9310          jsr       _strcatInstruction
00005110  584F      9311          addq.w    #4,A7
                    9312   DisassembleInstruction_253:
                    9313   ; }
                    9314   ; /////////////////////////////////////////////////////////////////////////////////
                    9315   ; // if instruction is NBCD <EA>
                    9316   ; /////////////////////////////////////////////////////////////////////////////////
                    9317   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x4800))
00005112  2042      9318          move.l    D2,A0
00005114  3010      9319          move.w    (A0),D0
00005116  C07C FFC0 9320          and.w     #65472,D0
0000511A  0C40 4800 9321          cmp.w     #18432,D0
0000511E  6620      9322          bne.s     DisassembleInstruction_255
                    9323   ; {
                    9324   ; InstructionSize = 1;
00005120  24BC 0000 9325          move.l    #1,(A2)
00005124  0001      
                    9326   ; strcpyInstruction("NBCD ");
00005126  4879 0000 9327          pea       @m68kde~2_287.L
0000512A  79C4      
0000512C  4E93      9328          jsr       (A3)
0000512E  584F      9329          addq.w    #4,A7
                    9330   ; Decode6BitEA(OpCode,0,0,0);
00005130  42A7      9331          clr.l     -(A7)
00005132  42A7      9332          clr.l     -(A7)
00005134  42A7      9333          clr.l     -(A7)
00005136  2F02      9334          move.l    D2,-(A7)
00005138  4EB8 3352 9335          jsr       _Decode6BitEA
0000513C  DEFC 0010 9336          add.w     #16,A7
                    9337   DisassembleInstruction_255:
                    9338   ; }
                    9339   ; /////////////////////////////////////////////////////////////////////////////////
                    9340   ; // if instruction is NEG <EA>
                    9341   ; /////////////////////////////////////////////////////////////////////////////////
                    9342   ; if((*OpCode & (unsigned short int)(0xFF00)) == (unsigned short int)(0x4400))
00005140  2042      9343          move.l    D2,A0
00005142  3010      9344          move.w    (A0),D0
00005144  C07C FF00 9345          and.w     #65280,D0
00005148  0C40 4400 9346          cmp.w     #17408,D0
0000514C  6600 0046 9347          bne       DisassembleInstruction_259
                    9348   ; {
                    9349   ; if(((*OpCode >> 6) & (unsigned short int)(0x0003)) != (unsigned short int)(0x0003))
00005150  2042      9350          move.l    D2,A0
00005152  3010      9351          move.w    (A0),D0
00005154  EC40      9352          asr.w     #6,D0
00005156  C07C 0003 9353          and.w     #3,D0
0000515A  0C40 0003 9354          cmp.w     #3,D0
0000515E  6700 0034 9355          beq       DisassembleInstruction_259
                    9356   ; {
                    9357   ; InstructionSize = 1;
00005162  24BC 0000 9358          move.l    #1,(A2)
00005166  0001      
                    9359   ; strcpyInstruction("NEG");
00005168  4879 0000 9360          pea       @m68kde~2_288.L
0000516C  79CA      
0000516E  4E93      9361          jsr       (A3)
00005170  584F      9362          addq.w    #4,A7
                    9363   ; Decode2BitOperandSize(*OpCode) ;
00005172  2042      9364          move.l    D2,A0
00005174  3210      9365          move.w    (A0),D1
00005176  C2BC 0000 9366          and.l     #65535,D1
0000517A  FFFF      
0000517C  2F01      9367          move.l    D1,-(A7)
0000517E  4EB8 30BE 9368          jsr       _Decode2BitOperandSize
00005182  584F      9369          addq.w    #4,A7
                    9370   ; Decode6BitEA(OpCode,0,0,0);
00005184  42A7      9371          clr.l     -(A7)
00005186  42A7      9372          clr.l     -(A7)
00005188  42A7      9373          clr.l     -(A7)
0000518A  2F02      9374          move.l    D2,-(A7)
0000518C  4EB8 3352 9375          jsr       _Decode6BitEA
00005190  DEFC 0010 9376          add.w     #16,A7
                    9377   DisassembleInstruction_259:
                    9378   ; }
                    9379   ; }
                    9380   ; /////////////////////////////////////////////////////////////////////////////////
                    9381   ; // if instruction is NEGX <EA>
                    9382   ; /////////////////////////////////////////////////////////////////////////////////
                    9383   ; if((*OpCode & (unsigned short int)(0xFF00)) == (unsigned short int)(0x4000))
00005194  2042      9384          move.l    D2,A0
00005196  3010      9385          move.w    (A0),D0
00005198  C07C FF00 9386          and.w     #65280,D0
0000519C  0C40 4000 9387          cmp.w     #16384,D0
000051A0  6600 0046 9388          bne       DisassembleInstruction_263
                    9389   ; {
                    9390   ; if(((*OpCode >> 6) & (unsigned short int)(0x0003)) != (unsigned short int)(0x0003))
000051A4  2042      9391          move.l    D2,A0
000051A6  3010      9392          move.w    (A0),D0
000051A8  EC40      9393          asr.w     #6,D0
000051AA  C07C 0003 9394          and.w     #3,D0
000051AE  0C40 0003 9395          cmp.w     #3,D0
000051B2  6700 0034 9396          beq       DisassembleInstruction_263
                    9397   ; {
                    9398   ; InstructionSize = 1;
000051B6  24BC 0000 9399          move.l    #1,(A2)
000051BA  0001      
                    9400   ; strcpyInstruction("NEGX");
000051BC  4879 0000 9401          pea       @m68kde~2_289.L
000051C0  79CE      
000051C2  4E93      9402          jsr       (A3)
000051C4  584F      9403          addq.w    #4,A7
                    9404   ; Decode2BitOperandSize(*OpCode) ;
000051C6  2042      9405          move.l    D2,A0
000051C8  3210      9406          move.w    (A0),D1
000051CA  C2BC 0000 9407          and.l     #65535,D1
000051CE  FFFF      
000051D0  2F01      9408          move.l    D1,-(A7)
000051D2  4EB8 30BE 9409          jsr       _Decode2BitOperandSize
000051D6  584F      9410          addq.w    #4,A7
                    9411   ; Decode6BitEA(OpCode,0,0,0);
000051D8  42A7      9412          clr.l     -(A7)
000051DA  42A7      9413          clr.l     -(A7)
000051DC  42A7      9414          clr.l     -(A7)
000051DE  2F02      9415          move.l    D2,-(A7)
000051E0  4EB8 3352 9416          jsr       _Decode6BitEA
000051E4  DEFC 0010 9417          add.w     #16,A7
                    9418   DisassembleInstruction_263:
                    9419   ; }
                    9420   ; }
                    9421   ; /////////////////////////////////////////////////////////////////////////////////
                    9422   ; // if instruction is NOP
                    9423   ; /////////////////////////////////////////////////////////////////////////////////
                    9424   ; if(*OpCode == (unsigned short int)(0x4E71))
000051E8  2042      9425          move.l    D2,A0
000051EA  3010      9426          move.w    (A0),D0
000051EC  0C40 4E71 9427          cmp.w     #20081,D0
000051F0  6610      9428          bne.s     DisassembleInstruction_265
                    9429   ; {
                    9430   ; InstructionSize = 1;
000051F2  24BC 0000 9431          move.l    #1,(A2)
000051F6  0001      
                    9432   ; strcpyInstruction("NOP");
000051F8  4879 0000 9433          pea       @m68kde~2_290.L
000051FC  79D4      
000051FE  4E93      9434          jsr       (A3)
00005200  584F      9435          addq.w    #4,A7
                    9436   DisassembleInstruction_265:
                    9437   ; }
                    9438   ; /////////////////////////////////////////////////////////////////////////////////
                    9439   ; // if instruction is NOT <EA>
                    9440   ; /////////////////////////////////////////////////////////////////////////////////
                    9441   ; if((*OpCode & (unsigned short int)(0xFF00)) == (unsigned short int)(0x4600))
00005202  2042      9442          move.l    D2,A0
00005204  3010      9443          move.w    (A0),D0
00005206  C07C FF00 9444          and.w     #65280,D0
0000520A  0C40 4600 9445          cmp.w     #17920,D0
0000520E  6600 0046 9446          bne       DisassembleInstruction_269
                    9447   ; {
                    9448   ; if(((*OpCode >> 6) & (unsigned short int)(0x0003)) != (unsigned short int)(0x0003))
00005212  2042      9449          move.l    D2,A0
00005214  3010      9450          move.w    (A0),D0
00005216  EC40      9451          asr.w     #6,D0
00005218  C07C 0003 9452          and.w     #3,D0
0000521C  0C40 0003 9453          cmp.w     #3,D0
00005220  6700 0034 9454          beq       DisassembleInstruction_269
                    9455   ; {
                    9456   ; InstructionSize = 1;
00005224  24BC 0000 9457          move.l    #1,(A2)
00005228  0001      
                    9458   ; strcpyInstruction("NOT");
0000522A  4879 0000 9459          pea       @m68kde~2_291.L
0000522E  79D8      
00005230  4E93      9460          jsr       (A3)
00005232  584F      9461          addq.w    #4,A7
                    9462   ; Decode2BitOperandSize(*OpCode) ;
00005234  2042      9463          move.l    D2,A0
00005236  3210      9464          move.w    (A0),D1
00005238  C2BC 0000 9465          and.l     #65535,D1
0000523C  FFFF      
0000523E  2F01      9466          move.l    D1,-(A7)
00005240  4EB8 30BE 9467          jsr       _Decode2BitOperandSize
00005244  584F      9468          addq.w    #4,A7
                    9469   ; Decode6BitEA(OpCode,0,0,0);
00005246  42A7      9470          clr.l     -(A7)
00005248  42A7      9471          clr.l     -(A7)
0000524A  42A7      9472          clr.l     -(A7)
0000524C  2F02      9473          move.l    D2,-(A7)
0000524E  4EB8 3352 9474          jsr       _Decode6BitEA
00005252  DEFC 0010 9475          add.w     #16,A7
                    9476   DisassembleInstruction_269:
                    9477   ; }
                    9478   ; }
                    9479   ; /////////////////////////////////////////////////////////////////////////////////
                    9480   ; // if instruction is OR <EA>,Dn or OR Dn,<EA>
                    9481   ; /////////////////////////////////////////////////////////////////////////////////
                    9482   ; if((*OpCode & (unsigned short int)(0xF000)) == (unsigned short int)(0x8000))
00005256  2042      9483          move.l    D2,A0
00005258  3010      9484          move.w    (A0),D0
0000525A  C07C F000 9485          and.w     #61440,D0
0000525E  0C40 8000 9486          cmp.w     #32768,D0
00005262  6600 0038 9487          bne       DisassembleInstruction_273
                    9488   ; {
                    9489   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0007) ;
00005266  2042      9490          move.l    D2,A0
00005268  3010      9491          move.w    (A0),D0
0000526A  EC40      9492          asr.w     #6,D0
0000526C  C07C 0007 9493          and.w     #7,D0
00005270  3600      9494          move.w    D0,D3
                    9495   ; if( (OpMode <= (unsigned short int)(0x0002)) ||
00005272  0C43 0002 9496          cmp.w     #2,D3
00005276  630C      9497          bls.s     DisassembleInstruction_275
00005278  0C43 0004 9498          cmp.w     #4,D3
0000527C  651E      9499          blo.s     DisassembleInstruction_273
0000527E  0C43 0006 9500          cmp.w     #6,D3
00005282  6218      9501          bhi.s     DisassembleInstruction_273
                    9502   DisassembleInstruction_275:
                    9503   ; ((OpMode >= (unsigned short int)(0x0004)) && (OpMode <= (unsigned short int)(0x0006))))
                    9504   ; {
                    9505   ; InstructionSize = 1;
00005284  24BC 0000 9506          move.l    #1,(A2)
00005288  0001      
                    9507   ; strcpyInstruction("OR") ;
0000528A  4879 0000 9508          pea       @m68kde~2_292.L
0000528E  79DC      
00005290  4E93      9509          jsr       (A3)
00005292  584F      9510          addq.w    #4,A7
                    9511   ; Decode3BitOperandMode(OpCode) ;
00005294  2F02      9512          move.l    D2,-(A7)
00005296  4EB8 377A 9513          jsr       _Decode3BitOperandMode
0000529A  584F      9514          addq.w    #4,A7
                    9515   DisassembleInstruction_273:
                    9516   ; }
                    9517   ; }
                    9518   ; /////////////////////////////////////////////////////////////////////////////////
                    9519   ; // if instruction is ORI to CCR
                    9520   ; /////////////////////////////////////////////////////////////////////////////////
                    9521   ; if(*OpCode == (unsigned short int)(0x003C))   {
0000529C  2042      9522          move.l    D2,A0
0000529E  3010      9523          move.w    (A0),D0
000052A0  0C40 003C 9524          cmp.w     #60,D0
000052A4  662A      9525          bne.s     DisassembleInstruction_276
                    9526   ; sprintf(Instruction, "ORI #$%2X,CCR", OpCode[1] & (unsigned short int)(0x00FF)) ;
000052A6  2042      9527          move.l    D2,A0
000052A8  3228 0002 9528          move.w    2(A0),D1
000052AC  C27C 00FF 9529          and.w     #255,D1
000052B0  C2BC 0000 9530          and.l     #65535,D1
000052B4  FFFF      
000052B6  2F01      9531          move.l    D1,-(A7)
000052B8  4879 0000 9532          pea       @m68kde~2_293.L
000052BC  79E0      
000052BE  4879 0B00 9533          pea       _Instruction.L
000052C2  04E2      
000052C4  4E95      9534          jsr       (A5)
000052C6  DEFC 000C 9535          add.w     #12,A7
                    9536   ; InstructionSize = 2;
000052CA  24BC 0000 9537          move.l    #2,(A2)
000052CE  0002      
                    9538   DisassembleInstruction_276:
                    9539   ; }
                    9540   ; /////////////////////////////////////////////////////////////////////////////////
                    9541   ; // if instruction is ORI #data,SR
                    9542   ; /////////////////////////////////////////////////////////////////////////////////
                    9543   ; if(*OpCode  == (unsigned short int)(0x007c))
000052D0  2042      9544          move.l    D2,A0
000052D2  3010      9545          move.w    (A0),D0
000052D4  0C40 007C 9546          cmp.w     #124,D0
000052D8  6622      9547          bne.s     DisassembleInstruction_278
                    9548   ; {
                    9549   ; InstructionSize = 2;
000052DA  24BC 0000 9550          move.l    #2,(A2)
000052DE  0002      
                    9551   ; sprintf(Instruction, "ORI  #$%X,SR", OpCode[1]);
000052E0  2042      9552          move.l    D2,A0
000052E2  3228 0002 9553          move.w    2(A0),D1
000052E6  48C1      9554          ext.l     D1
000052E8  2F01      9555          move.l    D1,-(A7)
000052EA  4879 0000 9556          pea       @m68kde~2_294.L
000052EE  79EE      
000052F0  4879 0B00 9557          pea       _Instruction.L
000052F4  04E2      
000052F6  4E95      9558          jsr       (A5)
000052F8  DEFC 000C 9559          add.w     #12,A7
                    9560   DisassembleInstruction_278:
                    9561   ; }
                    9562   ; /////////////////////////////////////////////////////////////////////////////////
                    9563   ; // if instruction is PEA
                    9564   ; /////////////////////////////////////////////////////////////////////////////////
                    9565   ; if((*OpCode & (unsigned short int)(0xFFC0)) == (unsigned short int)(0x4840))
000052FC  2042      9566          move.l    D2,A0
000052FE  3010      9567          move.w    (A0),D0
00005300  C07C FFC0 9568          and.w     #65472,D0
00005304  0C40 4840 9569          cmp.w     #18496,D0
00005308  6620      9570          bne.s     DisassembleInstruction_280
                    9571   ; {
                    9572   ; InstructionSize = 1;
0000530A  24BC 0000 9573          move.l    #1,(A2)
0000530E  0001      
                    9574   ; strcpyInstruction("PEA ");
00005310  4879 0000 9575          pea       @m68kde~2_295.L
00005314  79FC      
00005316  4E93      9576          jsr       (A3)
00005318  584F      9577          addq.w    #4,A7
                    9578   ; Decode6BitEA(OpCode,0,0,0);
0000531A  42A7      9579          clr.l     -(A7)
0000531C  42A7      9580          clr.l     -(A7)
0000531E  42A7      9581          clr.l     -(A7)
00005320  2F02      9582          move.l    D2,-(A7)
00005322  4EB8 3352 9583          jsr       _Decode6BitEA
00005326  DEFC 0010 9584          add.w     #16,A7
                    9585   DisassembleInstruction_280:
                    9586   ; }
                    9587   ; /////////////////////////////////////////////////////////////////////////////////
                    9588   ; // if instruction is reset
                    9589   ; /////////////////////////////////////////////////////////////////////////////////
                    9590   ; if(*OpCode  == (unsigned short int)(0x4E70))
0000532A  2042      9591          move.l    D2,A0
0000532C  3010      9592          move.w    (A0),D0
0000532E  0C40 4E70 9593          cmp.w     #20080,D0
00005332  6616      9594          bne.s     DisassembleInstruction_282
                    9595   ; {
                    9596   ; InstructionSize = 1;
00005334  24BC 0000 9597          move.l    #1,(A2)
00005338  0001      
                    9598   ; sprintf(Instruction, "RESET");
0000533A  4879 0000 9599          pea       @m68kde~2_296.L
0000533E  7A02      
00005340  4879 0B00 9600          pea       _Instruction.L
00005344  04E2      
00005346  4E95      9601          jsr       (A5)
00005348  504F      9602          addq.w    #8,A7
                    9603   DisassembleInstruction_282:
                    9604   ; }
                    9605   ; /////////////////////////////////////////////////////////////////////////////////
                    9606   ; // if instruction is RTE
                    9607   ; /////////////////////////////////////////////////////////////////////////////////
                    9608   ; if(*OpCode  == (unsigned short int)(0x4E73))
0000534A  2042      9609          move.l    D2,A0
0000534C  3010      9610          move.w    (A0),D0
0000534E  0C40 4E73 9611          cmp.w     #20083,D0
00005352  6616      9612          bne.s     DisassembleInstruction_284
                    9613   ; {
                    9614   ; InstructionSize = 1;
00005354  24BC 0000 9615          move.l    #1,(A2)
00005358  0001      
                    9616   ; sprintf(Instruction, "RTE");
0000535A  4879 0000 9617          pea       @m68kde~2_297.L
0000535E  7A08      
00005360  4879 0B00 9618          pea       _Instruction.L
00005364  04E2      
00005366  4E95      9619          jsr       (A5)
00005368  504F      9620          addq.w    #8,A7
                    9621   DisassembleInstruction_284:
                    9622   ; }
                    9623   ; /////////////////////////////////////////////////////////////////////////////////
                    9624   ; // if instruction is RTR
                    9625   ; /////////////////////////////////////////////////////////////////////////////////
                    9626   ; if(*OpCode == (unsigned short int)(0x4E77))
0000536A  2042      9627          move.l    D2,A0
0000536C  3010      9628          move.w    (A0),D0
0000536E  0C40 4E77 9629          cmp.w     #20087,D0
00005372  6610      9630          bne.s     DisassembleInstruction_286
                    9631   ; {
                    9632   ; InstructionSize = 1;
00005374  24BC 0000 9633          move.l    #1,(A2)
00005378  0001      
                    9634   ; strcpyInstruction("RTR");
0000537A  4879 0000 9635          pea       @m68kde~2_298.L
0000537E  7A0C      
00005380  4E93      9636          jsr       (A3)
00005382  584F      9637          addq.w    #4,A7
                    9638   DisassembleInstruction_286:
                    9639   ; }
                    9640   ; /////////////////////////////////////////////////////////////////////////////////
                    9641   ; // if instruction is RTS
                    9642   ; /////////////////////////////////////////////////////////////////////////////////
                    9643   ; if(*OpCode == (unsigned short int)(0x4E75))
00005384  2042      9644          move.l    D2,A0
00005386  3010      9645          move.w    (A0),D0
00005388  0C40 4E75 9646          cmp.w     #20085,D0
0000538C  6610      9647          bne.s     DisassembleInstruction_288
                    9648   ; {
                    9649   ; InstructionSize = 1;
0000538E  24BC 0000 9650          move.l    #1,(A2)
00005392  0001      
                    9651   ; strcpyInstruction("RTS");
00005394  4879 0000 9652          pea       @m68kde~2_299.L
00005398  7A10      
0000539A  4E93      9653          jsr       (A3)
0000539C  584F      9654          addq.w    #4,A7
                    9655   DisassembleInstruction_288:
                    9656   ; }
                    9657   ; /////////////////////////////////////////////////////////////////////////////////
                    9658   ; // if instruction is STOP
                    9659   ; /////////////////////////////////////////////////////////////////////////////////
                    9660   ; if(*OpCode  == (unsigned short int)(0x4E72))
0000539E  2042      9661          move.l    D2,A0
000053A0  3010      9662          move.w    (A0),D0
000053A2  0C40 4E72 9663          cmp.w     #20082,D0
000053A6  6622      9664          bne.s     DisassembleInstruction_290
                    9665   ; {
                    9666   ; InstructionSize = 2;
000053A8  24BC 0000 9667          move.l    #2,(A2)
000053AC  0002      
                    9668   ; sprintf(Instruction, "STOP #$%X", OpCode[1]);
000053AE  2042      9669          move.l    D2,A0
000053B0  3228 0002 9670          move.w    2(A0),D1
000053B4  48C1      9671          ext.l     D1
000053B6  2F01      9672          move.l    D1,-(A7)
000053B8  4879 0000 9673          pea       @m68kde~2_300.L
000053BC  7A14      
000053BE  4879 0B00 9674          pea       _Instruction.L
000053C2  04E2      
000053C4  4E95      9675          jsr       (A5)
000053C6  DEFC 000C 9676          add.w     #12,A7
                    9677   DisassembleInstruction_290:
                    9678   ; }
                    9679   ; /////////////////////////////////////////////////////////////////////////////////
                    9680   ; // if instruction is SBCD
                    9681   ; /////////////////////////////////////////////////////////////////////////////////
                    9682   ; if((*OpCode & (unsigned short int)(0xF1F0 )) == (unsigned short int)(0x8100))
000053CA  2042      9683          move.l    D2,A0
000053CC  3010      9684          move.w    (A0),D0
000053CE  C07C F1F0 9685          and.w     #61936,D0
000053D2  0C40 8100 9686          cmp.w     #33024,D0
000053D6  6600 0092 9687          bne       DisassembleInstruction_295
                    9688   ; {
                    9689   ; InstructionSize = 1;
000053DA  24BC 0000 9690          move.l    #1,(A2)
000053DE  0001      
                    9691   ; DestBits = (*OpCode >> 9) & (unsigned short int )(0x0007) ;
000053E0  2042      9692          move.l    D2,A0
000053E2  3010      9693          move.w    (A0),D0
000053E4  E040      9694          asr.w     #8,D0
000053E6  E240      9695          asr.w     #1,D0
000053E8  C07C 0007 9696          and.w     #7,D0
000053EC  3D40 FFE0 9697          move.w    D0,-32(A6)
                    9698   ; SourceBits = (*OpCode & (unsigned short int )(0x0007));
000053F0  2042      9699          move.l    D2,A0
000053F2  3010      9700          move.w    (A0),D0
000053F4  C07C 0007 9701          and.w     #7,D0
000053F8  3D40 FFDE 9702          move.w    D0,-34(A6)
                    9703   ; Mode = (*OpCode >> 3) & (unsigned short int )(0x0001) ;
000053FC  2042      9704          move.l    D2,A0
000053FE  3010      9705          move.w    (A0),D0
00005400  E640      9706          asr.w     #3,D0
00005402  48C0      9707          ext.l     D0
00005404  C0BC 0000 9708          and.l     #1,D0
00005408  0001      
0000540A  2D40 FFE4 9709          move.l    D0,-28(A6)
                    9710   ; if(Mode == 0)
0000540E  202E FFE4 9711          move.l    -28(A6),D0
00005412  662C      9712          bne.s     DisassembleInstruction_294
                    9713   ; sprintf(Instruction, "SBCD D%d,D%d", SourceBits, DestBits) ;
00005414  322E FFE0 9714          move.w    -32(A6),D1
00005418  C2BC 0000 9715          and.l     #65535,D1
0000541C  FFFF      
0000541E  2F01      9716          move.l    D1,-(A7)
00005420  322E FFDE 9717          move.w    -34(A6),D1
00005424  C2BC 0000 9718          and.l     #65535,D1
00005428  FFFF      
0000542A  2F01      9719          move.l    D1,-(A7)
0000542C  4879 0000 9720          pea       @m68kde~2_301.L
00005430  7A1E      
00005432  4879 0B00 9721          pea       _Instruction.L
00005436  04E2      
00005438  4E95      9722          jsr       (A5)
0000543A  DEFC 0010 9723          add.w     #16,A7
0000543E  602A      9724          bra.s     DisassembleInstruction_295
                    9725   DisassembleInstruction_294:
                    9726   ; else
                    9727   ; sprintf(Instruction, "SBCD -(A%d),-(A%d)", SourceBits, DestBits) ;
00005440  322E FFE0 9728          move.w    -32(A6),D1
00005444  C2BC 0000 9729          and.l     #65535,D1
00005448  FFFF      
0000544A  2F01      9730          move.l    D1,-(A7)
0000544C  322E FFDE 9731          move.w    -34(A6),D1
00005450  C2BC 0000 9732          and.l     #65535,D1
00005454  FFFF      
00005456  2F01      9733          move.l    D1,-(A7)
00005458  4879 0000 9734          pea       @m68kde~2_302.L
0000545C  7A2C      
0000545E  4879 0B00 9735          pea       _Instruction.L
00005462  04E2      
00005464  4E95      9736          jsr       (A5)
00005466  DEFC 0010 9737          add.w     #16,A7
                    9738   DisassembleInstruction_295:
                    9739   ; }
                    9740   ; /////////////////////////////////////////////////////////////////////////////////
                    9741   ; // if instruction is Scc
                    9742   ; /////////////////////////////////////////////////////////////////////////////////
                    9743   ; if((*OpCode & (unsigned short int)(0xF0C0 )) == (unsigned short int)(0x50C0))
0000546A  2042      9744          move.l    D2,A0
0000546C  3010      9745          move.w    (A0),D0
0000546E  C07C F0C0 9746          and.w     #61632,D0
00005472  0C40 50C0 9747          cmp.w     #20672,D0
00005476  6600 0060 9748          bne       DisassembleInstruction_298
                    9749   ; {
                    9750   ; EAMode = (*OpCode >> 3) & (unsigned short int)(0x0007) ;    // mode cannot be 1 for Scc as it it used by DBcc instruction as a differentiator
0000547A  2042      9751          move.l    D2,A0
0000547C  3010      9752          move.w    (A0),D0
0000547E  E640      9753          asr.w     #3,D0
00005480  C07C 0007 9754          and.w     #7,D0
00005484  3D40 FFEC 9755          move.w    D0,-20(A6)
                    9756   ; if(EAMode != (unsigned short int)(0x0001))
00005488  302E FFEC 9757          move.w    -20(A6),D0
0000548C  0C40 0001 9758          cmp.w     #1,D0
00005490  6700 0046 9759          beq       DisassembleInstruction_298
                    9760   ; {
                    9761   ; InstructionSize = 1;
00005494  24BC 0000 9762          move.l    #1,(A2)
00005498  0001      
                    9763   ; Condition = ((*OpCode >> 8) & (unsigned short int)(0xF)) ;
0000549A  2042      9764          move.l    D2,A0
0000549C  3010      9765          move.w    (A0),D0
0000549E  E040      9766          asr.w     #8,D0
000054A0  C07C 000F 9767          and.w     #15,D0
000054A4  1D40 FFE9 9768          move.b    D0,-23(A6)
                    9769   ; strcpyInstruction("S") ;
000054A8  4879 0000 9770          pea       @m68kde~2_303.L
000054AC  7A40      
000054AE  4E93      9771          jsr       (A3)
000054B0  584F      9772          addq.w    #4,A7
                    9773   ; DecodeBranchCondition(Condition) ;
000054B2  122E FFE9 9774          move.b    -23(A6),D1
000054B6  C27C 00FF 9775          and.w     #255,D1
000054BA  C2BC 0000 9776          and.l     #65535,D1
000054BE  FFFF      
000054C0  2F01      9777          move.l    D1,-(A7)
000054C2  4EB8 3810 9778          jsr       _DecodeBranchCondition
000054C6  584F      9779          addq.w    #4,A7
                    9780   ; Decode6BitEA(OpCode,0,0,0);
000054C8  42A7      9781          clr.l     -(A7)
000054CA  42A7      9782          clr.l     -(A7)
000054CC  42A7      9783          clr.l     -(A7)
000054CE  2F02      9784          move.l    D2,-(A7)
000054D0  4EB8 3352 9785          jsr       _Decode6BitEA
000054D4  DEFC 0010 9786          add.w     #16,A7
                    9787   DisassembleInstruction_298:
                    9788   ; }
                    9789   ; }
                    9790   ; /////////////////////////////////////////////////////////////////////////////////
                    9791   ; // if instruction is SUB or SUBA
                    9792   ; /////////////////////////////////////////////////////////////////////////////////
                    9793   ; if((*OpCode & (unsigned short int)(0xF000 )) == (unsigned short int)(0x9000))   {
000054D8  2042      9794          move.l    D2,A0
000054DA  3010      9795          move.w    (A0),D0
000054DC  C07C F000 9796          and.w     #61440,D0
000054E0  0C40 9000 9797          cmp.w     #36864,D0
000054E4  6600 008C 9798          bne       DisassembleInstruction_303
                    9799   ; OpMode = ((*OpCode >> 6) & (unsigned short int)(0x0007)) ;
000054E8  2042      9800          move.l    D2,A0
000054EA  3010      9801          move.w    (A0),D0
000054EC  EC40      9802          asr.w     #6,D0
000054EE  C07C 0007 9803          and.w     #7,D0
000054F2  3600      9804          move.w    D0,D3
                    9805   ; InstructionSize = 1;
000054F4  24BC 0000 9806          move.l    #1,(A2)
000054F8  0001      
                    9807   ; if((OpMode == (unsigned short int)(0x0003)) || (OpMode == (unsigned short int)(0x0007)))      // if destination is an address register then use ADDA otherwise use ADD
000054FA  0C43 0003 9808          cmp.w     #3,D3
000054FE  6708      9809          beq.s     DisassembleInstruction_304
00005500  0C43 0007 9810          cmp.w     #7,D3
00005504  6600 005A 9811          bne       DisassembleInstruction_302
                    9812   DisassembleInstruction_304:
                    9813   ; {
                    9814   ; if(OpMode == (unsigned short int)(0x0003))
00005508  0C43 0003 9815          cmp.w     #3,D3
0000550C  660C      9816          bne.s     DisassembleInstruction_305
                    9817   ; strcpyInstruction("SUBA.W ") ;
0000550E  4879 0000 9818          pea       @m68kde~2_304.L
00005512  7A42      
00005514  4E93      9819          jsr       (A3)
00005516  584F      9820          addq.w    #4,A7
00005518  600A      9821          bra.s     DisassembleInstruction_306
                    9822   DisassembleInstruction_305:
                    9823   ; else
                    9824   ; strcpyInstruction("SUBA.L ") ;
0000551A  4879 0000 9825          pea       @m68kde~2_305.L
0000551E  7A4A      
00005520  4E93      9826          jsr       (A3)
00005522  584F      9827          addq.w    #4,A7
                    9828   DisassembleInstruction_306:
                    9829   ; Decode6BitEA(OpCode,0,0,0)  ;
00005524  42A7      9830          clr.l     -(A7)
00005526  42A7      9831          clr.l     -(A7)
00005528  42A7      9832          clr.l     -(A7)
0000552A  2F02      9833          move.l    D2,-(A7)
0000552C  4EB8 3352 9834          jsr       _Decode6BitEA
00005530  DEFC 0010 9835          add.w     #16,A7
                    9836   ; sprintf(TempString, ",A%X", (*OpCode >> 9) & (unsigned short int)(0x0007)) ;
00005534  2042      9837          move.l    D2,A0
00005536  3210      9838          move.w    (A0),D1
00005538  E041      9839          asr.w     #8,D1
0000553A  E241      9840          asr.w     #1,D1
0000553C  C27C 0007 9841          and.w     #7,D1
00005540  C2BC 0000 9842          and.l     #65535,D1
00005544  FFFF      
00005546  2F01      9843          move.l    D1,-(A7)
00005548  4879 0000 9844          pea       @m68kde~2_208.L
0000554C  773E      
0000554E  2F0C      9845          move.l    A4,-(A7)
00005550  4E95      9846          jsr       (A5)
00005552  DEFC 000C 9847          add.w     #12,A7
                    9848   ; strcatInstruction(TempString) ;
00005556  2F0C      9849          move.l    A4,-(A7)
00005558  4EB8 0CCC 9850          jsr       _strcatInstruction
0000555C  584F      9851          addq.w    #4,A7
0000555E  6012      9852          bra.s     DisassembleInstruction_303
                    9853   DisassembleInstruction_302:
                    9854   ; }
                    9855   ; else {
                    9856   ; strcpyInstruction("SUB") ;
00005560  4879 0000 9857          pea       @m68kde~2_306.L
00005564  7A52      
00005566  4E93      9858          jsr       (A3)
00005568  584F      9859          addq.w    #4,A7
                    9860   ; Decode3BitOperandMode(OpCode) ;
0000556A  2F02      9861          move.l    D2,-(A7)
0000556C  4EB8 377A 9862          jsr       _Decode3BitOperandMode
00005570  584F      9863          addq.w    #4,A7
                    9864   DisassembleInstruction_303:
                    9865   ; }
                    9866   ; }
                    9867   ; /////////////////////////////////////////////////////////////////////////////////
                    9868   ; // if instruction is SUBQ
                    9869   ; /////////////////////////////////////////////////////////////////////////////////
                    9870   ; if((*OpCode & (unsigned short int)(0xF100 )) == (unsigned short int)(0x5100))
00005572  2042      9871          move.l    D2,A0
00005574  3010      9872          move.w    (A0),D0
00005576  C07C F100 9873          and.w     #61696,D0
0000557A  0C40 5100 9874          cmp.w     #20736,D0
0000557E  6600 0072 9875          bne       DisassembleInstruction_309
                    9876   ; {
                    9877   ; OpMode = (*OpCode >> 6) & (unsigned short int)(0x0003) ;
00005582  2042      9878          move.l    D2,A0
00005584  3010      9879          move.w    (A0),D0
00005586  EC40      9880          asr.w     #6,D0
00005588  C07C 0003 9881          and.w     #3,D0
0000558C  3600      9882          move.w    D0,D3
                    9883   ; if(OpMode <= (unsigned short int)(0x0002))
0000558E  0C43 0002 9884          cmp.w     #2,D3
00005592  6200 005E 9885          bhi       DisassembleInstruction_309
                    9886   ; {
                    9887   ; InstructionSize = 1;
00005596  24BC 0000 9888          move.l    #1,(A2)
0000559A  0001      
                    9889   ; strcpyInstruction("SUBQ") ;
0000559C  4879 0000 9890          pea       @m68kde~2_307.L
000055A0  7A56      
000055A2  4E93      9891          jsr       (A3)
000055A4  584F      9892          addq.w    #4,A7
                    9893   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
000055A6  2042      9894          move.l    D2,A0
000055A8  3210      9895          move.w    (A0),D1
000055AA  C2BC 0000 9896          and.l     #65535,D1
000055AE  FFFF      
000055B0  2F01      9897          move.l    D1,-(A7)
000055B2  4EB8 30BE 9898          jsr       _Decode2BitOperandSize
000055B6  584F      9899          addq.w    #4,A7
                    9900   ; sprintf(TempString, "#%1X,", ((*OpCode >> 9) & (unsigned short int)(0x0007)));    // print 3 bit #data in positions 11,10,9 in opcode
000055B8  2042      9901          move.l    D2,A0
000055BA  3210      9902          move.w    (A0),D1
000055BC  E041      9903          asr.w     #8,D1
000055BE  E241      9904          asr.w     #1,D1
000055C0  C27C 0007 9905          and.w     #7,D1
000055C4  C2BC 0000 9906          and.l     #65535,D1
000055C8  FFFF      
000055CA  2F01      9907          move.l    D1,-(A7)
000055CC  4879 0000 9908          pea       @m68kde~2_218.L
000055D0  777E      
000055D2  2F0C      9909          move.l    A4,-(A7)
000055D4  4E95      9910          jsr       (A5)
000055D6  DEFC 000C 9911          add.w     #12,A7
                    9912   ; strcatInstruction(TempString) ;
000055DA  2F0C      9913          move.l    A4,-(A7)
000055DC  4EB8 0CCC 9914          jsr       _strcatInstruction
000055E0  584F      9915          addq.w    #4,A7
                    9916   ; Decode6BitEA(OpCode,0,0,0) ;                                           // decode EA
000055E2  42A7      9917          clr.l     -(A7)
000055E4  42A7      9918          clr.l     -(A7)
000055E6  42A7      9919          clr.l     -(A7)
000055E8  2F02      9920          move.l    D2,-(A7)
000055EA  4EB8 3352 9921          jsr       _Decode6BitEA
000055EE  DEFC 0010 9922          add.w     #16,A7
                    9923   DisassembleInstruction_309:
                    9924   ; }
                    9925   ; }
                    9926   ; /////////////////////////////////////////////////////////////////////////////////
                    9927   ; // if instruction is SUBX
                    9928   ; /////////////////////////////////////////////////////////////////////////////////
                    9929   ; if((*OpCode & (unsigned short int)(0xF130 )) == (unsigned short int)(0x9100))
000055F2  2042      9930          move.l    D2,A0
000055F4  3010      9931          move.w    (A0),D0
000055F6  C07C F130 9932          and.w     #61744,D0
000055FA  0C40 9100 9933          cmp.w     #37120,D0
000055FE  6600 00A4 9934          bne       DisassembleInstruction_313
                    9935   ; {
                    9936   ; InstructionSize = 1;
00005602  24BC 0000 9937          move.l    #1,(A2)
00005606  0001      
                    9938   ; OpMode = ((*OpCode >> 6) & (unsigned short int)(0x0003)) ;
00005608  2042      9939          move.l    D2,A0
0000560A  3010      9940          move.w    (A0),D0
0000560C  EC40      9941          asr.w     #6,D0
0000560E  C07C 0003 9942          and.w     #3,D0
00005612  3600      9943          move.w    D0,D3
                    9944   ; if(OpMode != (unsigned short int)(0x0003)) // if size = 11 then it's SUBA not SUBX
00005614  0C43 0003 9945          cmp.w     #3,D3
00005618  6700 008A 9946          beq       DisassembleInstruction_313
                    9947   ; {
                    9948   ; strcpyInstruction("SUBX") ;
0000561C  4879 0000 9949          pea       @m68kde~2_308.L
00005620  7A5C      
00005622  4E93      9950          jsr       (A3)
00005624  584F      9951          addq.w    #4,A7
                    9952   ; Decode2BitOperandSize(*OpCode);                                  // add .b, .w, .l size indicator to instruction string
00005626  2042      9953          move.l    D2,A0
00005628  3210      9954          move.w    (A0),D1
0000562A  C2BC 0000 9955          and.l     #65535,D1
0000562E  FFFF      
00005630  2F01      9956          move.l    D1,-(A7)
00005632  4EB8 30BE 9957          jsr       _Decode2BitOperandSize
00005636  584F      9958          addq.w    #4,A7
                    9959   ; if((*OpCode & (unsigned short int)(0x0008)) == (unsigned short int)(0))    // if bit 3 of opcode is 0 indicates data registers are used as source and destination
00005638  2042      9960          move.l    D2,A0
0000563A  3010      9961          move.w    (A0),D0
0000563C  C07C 0008 9962          and.w     #8,D0
00005640  6600 0030 9963          bne       DisassembleInstruction_315
                    9964   ; sprintf(TempString, "D%1X,D%1X", (*OpCode & 0x0007), ((*OpCode >> 9) & 0x0007)) ;
00005644  2042      9965          move.l    D2,A0
00005646  3210      9966          move.w    (A0),D1
00005648  E041      9967          asr.w     #8,D1
0000564A  E241      9968          asr.w     #1,D1
0000564C  C27C 0007 9969          and.w     #7,D1
00005650  48C1      9970          ext.l     D1
00005652  2F01      9971          move.l    D1,-(A7)
00005654  2042      9972          move.l    D2,A0
00005656  3210      9973          move.w    (A0),D1
00005658  C27C 0007 9974          and.w     #7,D1
0000565C  48C1      9975          ext.l     D1
0000565E  2F01      9976          move.l    D1,-(A7)
00005660  4879 0000 9977          pea       @m68kde~2_309.L
00005664  7A62      
00005666  2F0C      9978          move.l    A4,-(A7)
00005668  4E95      9979          jsr       (A5)
0000566A  DEFC 0010 9980          add.w     #16,A7
0000566E  6000 002C 9981          bra       DisassembleInstruction_316
                    9982   DisassembleInstruction_315:
                    9983   ; else        // -(ax),-(ay) mode used
                    9984   ; sprintf(TempString, "-(A%1X),-(A%1X)", (*OpCode & 0x0007), ((*OpCode >> 9) & 0x0007)) ;
00005672  2042      9985          move.l    D2,A0
00005674  3210      9986          move.w    (A0),D1
00005676  E041      9987          asr.w     #8,D1
00005678  E241      9988          asr.w     #1,D1
0000567A  C27C 0007 9989          and.w     #7,D1
0000567E  48C1      9990          ext.l     D1
00005680  2F01      9991          move.l    D1,-(A7)
00005682  2042      9992          move.l    D2,A0
00005684  3210      9993          move.w    (A0),D1
00005686  C27C 0007 9994          and.w     #7,D1
0000568A  48C1      9995          ext.l     D1
0000568C  2F01      9996          move.l    D1,-(A7)
0000568E  4879 0000 9997          pea       @m68kde~2_310.L
00005692  7A6C      
00005694  2F0C      9998          move.l    A4,-(A7)
00005696  4E95      9999          jsr       (A5)
00005698  DEFC 0010 10000          add.w     #16,A7
                    10001   DisassembleInstruction_316:
                    10002   ; strcatInstruction(TempString) ;
0000569C  2F0C      10003          move.l    A4,-(A7)
0000569E  4EB8 0CCC 10004          jsr       _strcatInstruction
000056A2  584F      10005          addq.w    #4,A7
                    10006   DisassembleInstruction_313:
                    10007   ; }
                    10008   ; }
                    10009   ; /////////////////////////////////////////////////////////////////////////////////
                    10010   ; // if instruction is SWAP
                    10011   ; /////////////////////////////////////////////////////////////////////////////////
                    10012   ; if((*OpCode & (unsigned short int)(0xFFF8 )) == (unsigned short int)(0x4840))
000056A4  2042      10013          move.l    D2,A0
000056A6  3010      10014          move.w    (A0),D0
000056A8  C07C FFF8 10015          and.w     #65528,D0
000056AC  0C40 4840 10016          cmp.w     #18496,D0
000056B0  662A      10017          bne.s     DisassembleInstruction_317
                    10018   ; {
                    10019   ; InstructionSize = 1;
000056B2  24BC 0000 10020          move.l    #1,(A2)
000056B6  0001      
                    10021   ; DataRegister = *OpCode & (unsigned short int)(0x0007) ;
000056B8  2042      10022          move.l    D2,A0
000056BA  3010      10023          move.w    (A0),D0
000056BC  C07C 0007 10024          and.w     #7,D0
000056C0  3A00      10025          move.w    D0,D5
                    10026   ; sprintf(Instruction, "SWAP D%d", DataRegister) ;
000056C2  CABC 0000 10027          and.l     #65535,D5
000056C6  FFFF      
000056C8  2F05      10028          move.l    D5,-(A7)
000056CA  4879 0000 10029          pea       @m68kde~2_311.L
000056CE  7A7C      
000056D0  4879 0B00 10030          pea       _Instruction.L
000056D4  04E2      
000056D6  4E95      10031          jsr       (A5)
000056D8  DEFC 000C 10032          add.w     #12,A7
                    10033   DisassembleInstruction_317:
                    10034   ; }
                    10035   ; /////////////////////////////////////////////////////////////////////////////////
                    10036   ; // if instruction is TAS
                    10037   ; /////////////////////////////////////////////////////////////////////////////////
                    10038   ; if((*OpCode & (unsigned short int)(0xFFC0 )) == (unsigned short int)(0x4AC0))
000056DC  2042      10039          move.l    D2,A0
000056DE  3010      10040          move.w    (A0),D0
000056E0  C07C FFC0 10041          and.w     #65472,D0
000056E4  0C40 4AC0 10042          cmp.w     #19136,D0
000056E8  662A      10043          bne.s     DisassembleInstruction_321
                    10044   ; {
                    10045   ; if(*OpCode != (unsigned short int)(0x4AFC))
000056EA  2042      10046          move.l    D2,A0
000056EC  3010      10047          move.w    (A0),D0
000056EE  0C40 4AFC 10048          cmp.w     #19196,D0
000056F2  6720      10049          beq.s     DisassembleInstruction_321
                    10050   ; {
                    10051   ; InstructionSize = 1;
000056F4  24BC 0000 10052          move.l    #1,(A2)
000056F8  0001      
                    10053   ; strcpyInstruction("TAS ") ;
000056FA  4879 0000 10054          pea       @m68kde~2_312.L
000056FE  7A86      
00005700  4E93      10055          jsr       (A3)
00005702  584F      10056          addq.w    #4,A7
                    10057   ; Decode6BitEA(OpCode,0,0,0) ;
00005704  42A7      10058          clr.l     -(A7)
00005706  42A7      10059          clr.l     -(A7)
00005708  42A7      10060          clr.l     -(A7)
0000570A  2F02      10061          move.l    D2,-(A7)
0000570C  4EB8 3352 10062          jsr       _Decode6BitEA
00005710  DEFC 0010 10063          add.w     #16,A7
                    10064   DisassembleInstruction_321:
                    10065   ; }
                    10066   ; }
                    10067   ; /////////////////////////////////////////////////////////////////////////////////
                    10068   ; // if instruction is TRAP
                    10069   ; /////////////////////////////////////////////////////////////////////////////////
                    10070   ; if((*OpCode & (unsigned short int)(0xFFF0 )) == (unsigned short int)(0x4E40))   {
00005714  2042      10071          move.l    D2,A0
00005716  3010      10072          move.w    (A0),D0
00005718  C07C FFF0 10073          and.w     #65520,D0
0000571C  0C40 4E40 10074          cmp.w     #20032,D0
00005720  6622      10075          bne.s     DisassembleInstruction_323
                    10076   ; sprintf(Instruction, "TRAP #%d", *OpCode & (unsigned short int)(0x000F)) ;
00005722  2042      10077          move.l    D2,A0
00005724  3210      10078          move.w    (A0),D1
00005726  C27C 000F 10079          and.w     #15,D1
0000572A  C2BC 0000 10080          and.l     #65535,D1
0000572E  FFFF      
00005730  2F01      10081          move.l    D1,-(A7)
00005732  4879 0000 10082          pea       @m68kde~2_313.L
00005736  7A8C      
00005738  4879 0B00 10083          pea       _Instruction.L
0000573C  04E2      
0000573E  4E95      10084          jsr       (A5)
00005740  DEFC 000C 10085          add.w     #12,A7
                    10086   DisassembleInstruction_323:
                    10087   ; }
                    10088   ; /////////////////////////////////////////////////////////////////////////////////
                    10089   ; // if instruction is TRAPV
                    10090   ; /////////////////////////////////////////////////////////////////////////////////
                    10091   ; if(*OpCode == (unsigned short int)(0x4E76))
00005744  2042      10092          move.l    D2,A0
00005746  3010      10093          move.w    (A0),D0
00005748  0C40 4E76 10094          cmp.w     #20086,D0
0000574C  6610      10095          bne.s     DisassembleInstruction_325
                    10096   ; {
                    10097   ; InstructionSize = 1;
0000574E  24BC 0000 10098          move.l    #1,(A2)
00005752  0001      
                    10099   ; strcpyInstruction("TRAPV") ;
00005754  4879 0000 10100          pea       @m68kde~2_314.L
00005758  7A96      
0000575A  4E93      10101          jsr       (A3)
0000575C  584F      10102          addq.w    #4,A7
                    10103   DisassembleInstruction_325:
                    10104   ; }
                    10105   ; /////////////////////////////////////////////////////////////////////////////////
                    10106   ; // if instruction is TST
                    10107   ; /////////////////////////////////////////////////////////////////////////////////
                    10108   ; if((*OpCode & (unsigned short int)(0xFF00 )) == (unsigned short int)(0x4A00))
0000575E  2042      10109          move.l    D2,A0
00005760  3010      10110          move.w    (A0),D0
00005762  C07C FF00 10111          and.w     #65280,D0
00005766  0C40 4A00 10112          cmp.w     #18944,D0
0000576A  6600 005A 10113          bne       DisassembleInstruction_329
                    10114   ; {
                    10115   ; Size = (*OpCode >> 6) & (unsigned short int)(0x0003) ;
0000576E  2042      10116          move.l    D2,A0
00005770  3010      10117          move.w    (A0),D0
00005772  EC40      10118          asr.w     #6,D0
00005774  C07C 0003 10119          and.w     #3,D0
00005778  3D40 FFE2 10120          move.w    D0,-30(A6)
                    10121   ; if((*OpCode != (unsigned short int)(0x4AFC)) && (Size != (unsigned short int)(0x0003)))       { // test for size to eliminate TAS instruction which shares similar opcode
0000577C  2042      10122          move.l    D2,A0
0000577E  3010      10123          move.w    (A0),D0
00005780  0C40 4AFC 10124          cmp.w     #19196,D0
00005784  6700 0040 10125          beq       DisassembleInstruction_329
00005788  302E FFE2 10126          move.w    -30(A6),D0
0000578C  0C40 0003 10127          cmp.w     #3,D0
00005790  6700 0034 10128          beq       DisassembleInstruction_329
                    10129   ; InstructionSize = 1;
00005794  24BC 0000 10130          move.l    #1,(A2)
00005798  0001      
                    10131   ; strcpyInstruction("TST") ;
0000579A  4879 0000 10132          pea       @m68kde~2_315.L
0000579E  7A9C      
000057A0  4E93      10133          jsr       (A3)
000057A2  584F      10134          addq.w    #4,A7
                    10135   ; Decode2BitOperandSize(*OpCode) ;
000057A4  2042      10136          move.l    D2,A0
000057A6  3210      10137          move.w    (A0),D1
000057A8  C2BC 0000 10138          and.l     #65535,D1
000057AC  FFFF      
000057AE  2F01      10139          move.l    D1,-(A7)
000057B0  4EB8 30BE 10140          jsr       _Decode2BitOperandSize
000057B4  584F      10141          addq.w    #4,A7
                    10142   ; Decode6BitEA(OpCode,0,0,0) ;
000057B6  42A7      10143          clr.l     -(A7)
000057B8  42A7      10144          clr.l     -(A7)
000057BA  42A7      10145          clr.l     -(A7)
000057BC  2F02      10146          move.l    D2,-(A7)
000057BE  4EB8 3352 10147          jsr       _Decode6BitEA
000057C2  DEFC 0010 10148          add.w     #16,A7
                    10149   DisassembleInstruction_329:
                    10150   ; }
                    10151   ; }
                    10152   ; /////////////////////////////////////////////////////////////////////////////////
                    10153   ; // if instruction is UNLK
                    10154   ; //////////////////////////////////////////////////////////
                    10155   ; if((*OpCode & (unsigned short int)(0xFFF8 )) == (unsigned short int)(0x4E58))
000057C6  2042      10156          move.l    D2,A0
000057C8  3010      10157          move.w    (A0),D0
000057CA  C07C FFF8 10158          and.w     #65528,D0
000057CE  0C40 4E58 10159          cmp.w     #20056,D0
000057D2  6628      10160          bne.s     DisassembleInstruction_331
                    10161   ; {
                    10162   ; InstructionSize = 1;
000057D4  24BC 0000 10163          move.l    #1,(A2)
000057D8  0001      
                    10164   ; sprintf(Instruction, "UNLK A%d", *OpCode & (unsigned short int)(0x0007)) ;
000057DA  2042      10165          move.l    D2,A0
000057DC  3210      10166          move.w    (A0),D1
000057DE  C27C 0007 10167          and.w     #7,D1
000057E2  C2BC 0000 10168          and.l     #65535,D1
000057E6  FFFF      
000057E8  2F01      10169          move.l    D1,-(A7)
000057EA  4879 0000 10170          pea       @m68kde~2_316.L
000057EE  7AA0      
000057F0  4879 0B00 10171          pea       _Instruction.L
000057F4  04E2      
000057F6  4E95      10172          jsr       (A5)
000057F8  DEFC 000C 10173          add.w     #12,A7
                    10174   DisassembleInstruction_331:
                    10175   ; }
                    10176   ; FormatInstruction() ;
000057FC  4EB8 302C 10177          jsr       _FormatInstruction
00005800  4CDF 3CFC 10178          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00005804  4E5E      10179          unlk      A6
00005806  4E75      10180          rts
                    10181   ; }
                    10182   _strcpy:
00005808  206F 0004 10183          move.l    (4,A7),A0
0000580C  226F 0008 10184          move.l    (8,A7),A1
00005810  2008      10185          move.l    A0,D0
                    10186   strcpy_1:
00005812  10D9      10187          move.b    (A1)+,(A0)+
00005814  66FC      10188          bne       strcpy_1
00005816  4E75      10189          rts
                    10190   ULDIV:
00005818  4E56 0000 10191          link    A6,#0
0000581C  48E7 C000 10192          movem.l D0/D1,-(A7)
00005820  222E 0008 10193          move.l  8(A6),D1
00005824  202E 000C 10194          move.l  12(A6),D0
00005828  6036      10195          bra.s   ldiv_3
                    10196   LDIV:
0000582A  4E56 0000 10197          link    A6,#0
0000582E  48E7 C000 10198          movem.l D0/D1,-(A7)
00005832  222E 0008 10199          move.l  8(A6),D1
00005836  202E 000C 10200          move.l  12(A6),D0
0000583A  4A80      10201          tst.l   D0
0000583C  6A0E      10202          bpl.s   ldiv_1
0000583E  4480      10203          neg.l   D0
00005840  4A81      10204          tst.l   D1
00005842  6A14      10205          bpl.s   ldiv_2
00005844  4481      10206          neg.l   D1
00005846  612A      10207          bsr.s   dodiv
00005848  4481      10208          neg.l   D1
0000584A  6016      10209          bra.s   ldiv_4
                    10210   ldiv_1:
0000584C  4A81      10211          tst.l   D1
0000584E  6A10      10212          bpl.s   ldiv_3
00005850  4481      10213          neg.l   D1
00005852  611E      10214          bsr.s   dodiv
00005854  4480      10215          neg.l   D0
00005856  600A      10216          bra.s   ldiv_4
                    10217   ldiv_2:
00005858  6118      10218          bsr.s   dodiv
0000585A  4480      10219          neg.l   D0
0000585C  4481      10220          neg.l   D1
0000585E  6002      10221          bra.s   ldiv_4
                    10222   ldiv_3:
00005860  6110      10223          bsr.s   dodiv
                    10224   ldiv_4:
00005862  2D40 0008 10225          move.l  D0,8(A6)
00005866  2D41 000C 10226          move.l  D1,12(A6)
0000586A  4CDF 0003 10227          movem.l (A7)+,D0/D1
0000586E  4E5E      10228          unlk    A6
00005870  4E75      10229          rts
                    10230   dodiv:
00005872  0C81 0000 10231          cmpi.l  #$FFFF,D1
00005876  FFFF      
00005878  6236      10232          bhi.s   dodiv_2
0000587A  0C80 0000 10233          cmpi.l  #$FFFF,D0
0000587E  FFFF      
00005880  6210      10234          bhi.s   dodiv_1
00005882  80C1      10235          divu    D1,D0
00005884  2200      10236          move.l  D0,D1
00005886  4241      10237          clr.w   D1
00005888  4841      10238          swap    D1
0000588A  0280 0000 10239          andi.l  #$FFFF,D0
0000588E  FFFF      
00005890  4E75      10240          rts
                    10241   dodiv_1:
00005892  48A7 A000 10242          movem.w D0/D2,-(A7)
00005896  4240      10243          clr.w   D0
00005898  4840      10244          swap    D0
0000589A  80C1      10245          divu    D1,D0
0000589C  3400      10246          move.w  D0,D2
0000589E  301F      10247          move.w  (A7)+,D0
000058A0  80C1      10248          divu    D1,D0
000058A2  4840      10249          swap    D0
000058A4  4281      10250          clr.l   D1
000058A6  3200      10251          move.w  D0,D1
000058A8  3002      10252          move.w  D2,D0
000058AA  4840      10253          swap    D0
000058AC  341F      10254          move.w  (A7)+,D2
000058AE  4E75      10255          rts
                    10256   dodiv_2:
000058B0  48E7 3800 10257          movem.l D2/D3/D4,-(A7)
000058B4  2401      10258          move.l  D1,D2
000058B6  4242      10259          clr.w   D2
000058B8  4842      10260          swap    D2
000058BA  5282      10261          addq.l  #1,D2
000058BC  2600      10262          move.l  D0,D3
000058BE  2801      10263          move.l  D1,D4
000058C0  2202      10264          move.l  D2,D1
000058C2  61CE      10265          bsr.s   dodiv_1
000058C4  2204      10266          move.l  D4,D1
000058C6  82C2      10267          divu    D2,D1
000058C8  80C1      10268          divu    D1,D0
000058CA  0280 0000 10269          andi.l  #$FFFF,D0
000058CE  FFFF      
                    10270   dodiv_3:
000058D0  2204      10271          move.l  D4,D1
000058D2  2404      10272          move.l  D4,D2
000058D4  4842      10273          swap    D2
000058D6  C2C0      10274          mulu    D0,D1
000058D8  C4C0      10275          mulu    D0,D2
000058DA  4842      10276          swap    D2
000058DC  D282      10277          add.l   D2,D1
000058DE  9283      10278          sub.l   D3,D1
000058E0  620A      10279          bhi.s   dodiv_4
000058E2  4481      10280          neg.l   D1
000058E4  B881      10281          cmp.l   D1,D4
000058E6  6208      10282          bhi.s   dodiv_5
000058E8  5280      10283          addq.l  #1,D0
000058EA  60E4      10284          bra.s   dodiv_3
                    10285   dodiv_4:
000058EC  5380      10286          subq.l  #1,D0
000058EE  60E0      10287          bra.s   dodiv_3
                    10288   dodiv_5:
000058F0  4CDF 001C 10289          movem.l (A7)+,D2/D3/D4
000058F4  4E75      10290          rts
                    10291   ULMUL:
000058F6  4E56 0000 10292          link    A6,#0
000058FA  48E7 C000 10293          movem.l D0/D1,-(A7)
000058FE  222E 0008 10294          move.l  8(A6),D1
00005902  202E 000C 10295          move.l  12(A6),D0
00005906  602C      10296          bra.s   lmul_3
                    10297   LMUL:
00005908  4E56 0000 10298          link    A6,#0
0000590C  48E7 C000 10299          movem.l D0/D1,-(A7)
00005910  222E 0008 10300          move.l  8(A6),D1
00005914  202E 000C 10301          move.l  12(A6),D0
00005918  4A80      10302          tst.l   D0
0000591A  6A0A      10303          bpl.s   lmul_1
0000591C  4480      10304          neg.l   D0
0000591E  4A81      10305          tst.l   D1
00005920  6A0A      10306          bpl.s   lmul_2
00005922  4481      10307          neg.l   D1
00005924  600E      10308          bra.s   lmul_3
                    10309   lmul_1:
00005926  4A81      10310          tst.l   D1
00005928  6A0A      10311          bpl.s   lmul_3
0000592A  4481      10312          neg.l   D1
                    10313   lmul_2:
0000592C  6114      10314          bsr.s   domul
0000592E  4481      10315          neg.l   D1
00005930  4080      10316          negx.l  D0
00005932  6002      10317          bra.s   lmul_4
                    10318   lmul_3:
00005934  610C      10319          bsr.s   domul
                    10320   lmul_4:
00005936  2D41 0008 10321          move.l  D1,8(A6)
0000593A  4CDF 0003 10322          movem.l (A7)+,D0/D1
0000593E  4E5E      10323          unlk    A6
00005940  4E75      10324          rts
                    10325   domul:
00005942  0C81 0000 10326          cmpi.l  #$FFFF,D1
00005946  FFFF      
00005948  620C      10327          bhi.s   domul_1
0000594A  0C80 0000 10328          cmpi.l  #$FFFF,D0
0000594E  FFFF      
00005950  620E      10329          bhi.s   domul_2
00005952  C2C0      10330          mulu    D0,D1
00005954  4E75      10331          rts
                    10332   domul_1:
00005956  0C80 0000 10333          cmpi.l  #$FFFF,D0
0000595A  FFFF      
0000595C  6218      10334          bhi.s   domul_4
0000595E  6002      10335          bra.s   domul_3
                    10336   domul_2
00005960  C141      10337          exg     D0,D1
                    10338   domul_3:
00005962  2F02      10339          move.l  D2,-(A7)
00005964  2401      10340          move.l  D1,D2
00005966  4842      10341          swap    D2
00005968  C2C0      10342          mulu    D0,D1
0000596A  C4C0      10343          mulu    D0,D2
0000596C  4842      10344          swap    D2
0000596E  4242      10345          clr.w   D2
00005970  D282      10346          add.l   D2,D1
00005972  241F      10347          move.l  (A7)+,D2
00005974  4E75      10348          rts
                    10349   domul_4:
00005976  48E7 3000 10350          movem.l D2/D3,-(A7)
0000597A  2401      10351          move.l  D1,D2
0000597C  2601      10352          move.l  D1,D3
0000597E  C2C0      10353          mulu    D0,D1
00005980  4842      10354          swap    D2
00005982  C4C0      10355          mulu    D0,D2
00005984  4840      10356          swap    D0
00005986  C6C0      10357          mulu    D0,D3
00005988  D483      10358          add.l   D3,D2
0000598A  4842      10359          swap    D2
0000598C  4242      10360          clr.w   D2
0000598E  D282      10361          add.l   D2,D1
00005990  4CDF 000C 10362          movem.l (A7)+,D2/D3
00005994  4E75      10363          rts
                    10364   _putch:
00005996  4E56 0000 10365          link      A6,#0
0000599A  48E7 2000 10366          movem.l   D2,-(A7)
0000599E  242E 0008 10367          move.l    8(A6),D2
000059A2  0C82 0000 10368          cmp.l     #10,D2
000059A6  000A      
000059A8  660A      10369          bne.s     putch_1
000059AA  4878 000D 10370          pea       13
000059AE  6100 B18C 10371          bsr       __putch
000059B2  584F      10372          addq.w    #4,A7
                    10373   putch_1:
000059B4  2F02      10374          move.l    D2,-(A7)
000059B6  6100 B184 10375          bsr       __putch
000059BA  584F      10376          addq.w    #4,A7
000059BC  2002      10377          move.l    D2,D0
000059BE  4CDF 0004 10378          movem.l   (A7)+,D2
000059C2  4E5E      10379          unlk      A6
000059C4  4E75      10380          rts
                    10381   _getch:
000059C6  48E7 2000 10382          movem.l   D2,-(A7)
000059CA  2439 0B00 10383          move.l    __ungetbuf,D2
000059CE  00C0      
000059D0  2039 0B00 10384          move.l    __ungetbuf,D0
000059D4  00C0      
000059D6  0C80 FFFF 10385          cmp.l     #-1,D0
000059DA  FFFF      
000059DC  670C      10386          beq.s     getch_1
000059DE  23FC FFFF 10387          move.l    #-1,__ungetbuf
000059E2  FFFF 0B00 
000059E6  00C0      
000059E8  6010      10388          bra.s     getch_3
                    10389   getch_1:
000059EA  6100 B17C 10390          bsr       __getch
000059EE  2400      10391          move.l    D0,D2
000059F0  0C80 0000 10392          cmp.l     #13,D0
000059F4  000D      
000059F6  6602      10393          bne.s     getch_3
000059F8  740A      10394          moveq     #10,D2
                    10395   getch_3:
000059FA  2002      10396          move.l    D2,D0
000059FC  4CDF 0004 10397          movem.l   (A7)+,D2
00005A00  4E75      10398          rts
                    10399   _tolower:
00005A02  4E56 0000 10400          link      A6,#0
00005A06  48E7 2000 10401          movem.l   D2,-(A7)
00005A0A  242E 0008 10402          move.l    8(A6),D2
00005A0E  0C82 0000 10403          cmp.l     #65,D2
00005A12  0041      
00005A14  6D0E      10404          blt.s     tolower_1
00005A16  0C82 0000 10405          cmp.l     #90,D2
00005A1A  005A      
00005A1C  6E06      10406          bgt.s     tolower_1
00005A1E  84BC 0000 10407          or.l      #32,D2
00005A22  0020      
                    10408   tolower_1:
00005A24  2002      10409          move.l    D2,D0
00005A26  4CDF 0004 10410          movem.l   (A7)+,D2
00005A2A  4E5E      10411          unlk      A6
00005A2C  4E75      10412          rts
                    10413   _sprintf:
00005A2E  4E56 FFFC 10414          link      A6,#-4
00005A32  48E7 2000 10415          movem.l   D2,-(A7)
00005A36  41EE 000C 10416          lea       12(A6),A0
00005A3A  5848      10417          addq.w    #4,A0
00005A3C  2408      10418          move.l    A0,D2
00005A3E  2F02      10419          move.l    D2,-(A7)
00005A40  2F2E 000C 10420          move.l    12(A6),-(A7)
00005A44  2F2E 0008 10421          move.l    8(A6),-(A7)
00005A48  6100 013E 10422          bsr       _vsprintf
00005A4C  DEFC 000C 10423          add.w     #12,A7
00005A50  2D40 FFFC 10424          move.l    D0,-4(A6)
00005A54  4282      10425          clr.l     D2
00005A56  202E FFFC 10426          move.l    -4(A6),D0
00005A5A  4CDF 0004 10427          movem.l   (A7)+,D2
00005A5E  4E5E      10428          unlk      A6
00005A60  4E75      10429          rts
                    10430   _strcat:
00005A62  206F 0004 10431          move.l    (4,A7),A0	
00005A66  226F 0008 10432          move.l    (8,A7),A1	
00005A6A  2008      10433          move.l    A0,D0		
                    10434   strcat_0:
00005A6C  4A18      10435          tst.b     (A0)+
00005A6E  66FC      10436          bne       strcat_0
00005A70  5348      10437          subq      #1,A0
                    10438   strcat_1:
00005A72  10D9      10439          move.b    (A1)+,(A0)+
00005A74  66FC      10440          bne       strcat_1
00005A76  4E75      10441          rts
                    10442   _toupper:
00005A78  4E56 0000 10443          link      A6,#0
00005A7C  48E7 2000 10444          movem.l   D2,-(A7)
00005A80  242E 0008 10445          move.l    8(A6),D2
00005A84  0C82 0000 10446          cmp.l     #97,D2
00005A88  0061      
00005A8A  6D0E      10447          blt.s     toupper_1
00005A8C  0C82 0000 10448          cmp.l     #122,D2
00005A90  007A      
00005A92  6E06      10449          bgt.s     toupper_1
00005A94  C4BC 0000 10450          and.l     #95,D2
00005A98  005F      
                    10451   toupper_1:
00005A9A  2002      10452          move.l    D2,D0
00005A9C  4CDF 0004 10453          movem.l   (A7)+,D2
00005AA0  4E5E      10454          unlk      A6
00005AA2  4E75      10455          rts
                    10456   _printf:
00005AA4  4E56 FFFC 10457          link      A6,#-4
00005AA8  48E7 2000 10458          movem.l   D2,-(A7)
00005AAC  41EE 0008 10459          lea       8(A6),A0
00005AB0  5848      10460          addq.w    #4,A0
00005AB2  2408      10461          move.l    A0,D2
00005AB4  2F02      10462          move.l    D2,-(A7)
00005AB6  2F2E 0008 10463          move.l    8(A6),-(A7)
00005ABA  42A7      10464          clr.l     -(A7)
00005ABC  6100 00CA 10465          bsr       _vsprintf
00005AC0  DEFC 000C 10466          add.w     #12,A7
00005AC4  2D40 FFFC 10467          move.l    D0,-4(A6)
00005AC8  4282      10468          clr.l     D2
00005ACA  202E FFFC 10469          move.l    -4(A6),D0
00005ACE  4CDF 0004 10470          movem.l   (A7)+,D2
00005AD2  4E5E      10471          unlk      A6
00005AD4  4E75      10472          rts
                    10473   @vsprintf_copy:
00005AD6  4E56 0000 10474          link      A6,#0
00005ADA  206E 0008 10475          move.l    8(A6),A0
00005ADE  4A90      10476          tst.l     (A0)
00005AE0  6710      10477          beq.s     @vsprintf_copy_1
00005AE2  202E 000C 10478          move.l    12(A6),D0
00005AE6  206E 0008 10479          move.l    8(A6),A0
00005AEA  2250      10480          move.l    (A0),A1
00005AEC  5290      10481          addq.l    #1,(A0)
00005AEE  1280      10482          move.b    D0,(A1)
00005AF0  600A      10483          bra.s     @vsprintf_copy_2
                    10484   @vsprintf_copy_1:
00005AF2  2F2E 000C 10485          move.l    12(A6),-(A7)
00005AF6  6100 FE9E 10486          bsr       _putch
00005AFA  584F      10487          addq.w    #4,A7
                    10488   @vsprintf_copy_2:
00005AFC  4E5E      10489          unlk      A6
00005AFE  4E75      10490          rts
                    10491   @vsprintf_getval:
00005B00  4E56 0000 10492          link      A6,#0
00005B04  48E7 3000 10493          movem.l   D2/D3,-(A7)
00005B08  242E 0008 10494          move.l    8(A6),D2
00005B0C  4283      10495          clr.l     D3
00005B0E  2042      10496          move.l    D2,A0
00005B10  2050      10497          move.l    (A0),A0
00005B12  1010      10498          move.b    (A0),D0
00005B14  4880      10499          ext.w     D0
00005B16  48C0      10500          ext.l     D0
00005B18  0C80 0000 10501          cmp.l     #42,D0
00005B1C  002A      
00005B1E  6612      10502          bne.s     @vsprintf_getval_1
00005B20  206E 000C 10503          move.l    12(A6),A0
00005B24  2250      10504          move.l    (A0),A1
00005B26  5890      10505          addq.l    #4,(A0)
00005B28  2611      10506          move.l    (A1),D3
00005B2A  2042      10507          move.l    D2,A0
00005B2C  5290      10508          addq.l    #1,(A0)
00005B2E  6000 004E 10509          bra       @vsprintf_getval_5
                    10510   @vsprintf_getval_1:
00005B32  2042      10511          move.l    D2,A0
00005B34  2050      10512          move.l    (A0),A0
00005B36  1010      10513          move.b    (A0),D0
00005B38  4880      10514          ext.w     D0
00005B3A  48C0      10515          ext.l     D0
00005B3C  0C80 0000 10516          cmp.l     #48,D0
00005B40  0030      
00005B42  6D00 003A 10517          blt       @vsprintf_getval_5
00005B46  2042      10518          move.l    D2,A0
00005B48  2050      10519          move.l    (A0),A0
00005B4A  1010      10520          move.b    (A0),D0
00005B4C  4880      10521          ext.w     D0
00005B4E  48C0      10522          ext.l     D0
00005B50  0C80 0000 10523          cmp.l     #57,D0
00005B54  0039      
00005B56  6E26      10524          bgt.s     @vsprintf_getval_5
00005B58  2F03      10525          move.l    D3,-(A7)
00005B5A  4878 000A 10526          pea       10
00005B5E  6100 FDA8 10527          bsr       LMUL
00005B62  2017      10528          move.l    (A7),D0
00005B64  504F      10529          addq.w    #8,A7
00005B66  2042      10530          move.l    D2,A0
00005B68  2250      10531          move.l    (A0),A1
00005B6A  5290      10532          addq.l    #1,(A0)
00005B6C  1211      10533          move.b    (A1),D1
00005B6E  4881      10534          ext.w     D1
00005B70  48C1      10535          ext.l     D1
00005B72  D081      10536          add.l     D1,D0
00005B74  0480 0000 10537          sub.l     #48,D0
00005B78  0030      
00005B7A  2600      10538          move.l    D0,D3
00005B7C  60B4      10539          bra       @vsprintf_getval_1
                    10540   @vsprintf_getval_5:
00005B7E  2003      10541          move.l    D3,D0
00005B80  4CDF 000C 10542          movem.l   (A7)+,D2/D3
00005B84  4E5E      10543          unlk      A6
00005B86  4E75      10544          rts
                    10545   _vsprintf:
00005B88  4E56 FFCC 10546          link      A6,#-52
00005B8C  48E7 3F3C 10547          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00005B90  45EE 0008 10548          lea       8(A6),A2
00005B94  47F8 5AD6 10549          lea       @vsprintf_copy,A3
00005B98  49F9 0000 10550          lea       _ultoa,A4
00005B9C  62E0      
00005B9E  4286      10551          clr.l     D6
                    10552   vsprintf_1:
00005BA0  206E 000C 10553          move.l    12(A6),A0
00005BA4  4A10      10554          tst.b     (A0)
00005BA6  6700 0624 10555          beq       vsprintf_3
00005BAA  206E 000C 10556          move.l    12(A6),A0
00005BAE  1010      10557          move.b    (A0),D0
00005BB0  4880      10558          ext.w     D0
00005BB2  48C0      10559          ext.l     D0
00005BB4  0C80 0000 10560          cmp.l     #37,D0
00005BB8  0025      
00005BBA  671C      10561          beq.s     vsprintf_4
00005BBC  206E 000C 10562          move.l    12(A6),A0
00005BC0  52AE 000C 10563          addq.l    #1,12(A6)
00005BC4  1210      10564          move.b    (A0),D1
00005BC6  4881      10565          ext.w     D1
00005BC8  48C1      10566          ext.l     D1
00005BCA  2F01      10567          move.l    D1,-(A7)
00005BCC  2F0A      10568          move.l    A2,-(A7)
00005BCE  4E93      10569          jsr       (A3)
00005BD0  504F      10570          addq.w    #8,A7
00005BD2  5286      10571          addq.l    #1,D6
00005BD4  6000 05F2 10572          bra       vsprintf_2
                    10573   vsprintf_4:
00005BD8  52AE 000C 10574          addq.l    #1,12(A6)
00005BDC  422E FFD3 10575          clr.b     -45(A6)
00005BE0  422E FFD2 10576          clr.b     -46(A6)
00005BE4  422E FFD0 10577          clr.b     -48(A6)
00005BE8  422E FFCF 10578          clr.b     -49(A6)
00005BEC  422E FFCE 10579          clr.b     -50(A6)
00005BF0  422E FFCD 10580          clr.b     -51(A6)
00005BF4  42AE FFFC 10581          clr.l     -4(A6)
00005BF8  7AFF      10582          moveq     #-1,D5
00005BFA  41EE FFDC 10583          lea       -36(A6),A0
00005BFE  2608      10584          move.l    A0,D3
00005C00  2408      10585          move.l    A0,D2
                    10586   vsprintf_6:
00005C02  206E 000C 10587          move.l    12(A6),A0
00005C06  1010      10588          move.b    (A0),D0
00005C08  4880      10589          ext.w     D0
00005C0A  48C0      10590          ext.l     D0
00005C0C  0C80 0000 10591          cmp.l     #43,D0
00005C10  002B      
00005C12  6730      10592          beq.s     vsprintf_12
00005C14  6E18      10593          bgt.s     vsprintf_15
00005C16  0C80 0000 10594          cmp.l     #35,D0
00005C1A  0023      
00005C1C  6700 003E 10595          beq       vsprintf_14
00005C20  6E00 0046 10596          bgt       vsprintf_9
00005C24  0C80 0000 10597          cmp.l     #32,D0
00005C28  0020      
00005C2A  6724      10598          beq.s     vsprintf_13
00005C2C  603A      10599          bra.s     vsprintf_9
                    10600   vsprintf_15:
00005C2E  0C80 0000 10601          cmp.l     #45,D0
00005C32  002D      
00005C34  6702      10602          beq.s     vsprintf_11
00005C36  6030      10603          bra.s     vsprintf_9
                    10604   vsprintf_11:
00005C38  1D7C 0001 10605          move.b    #1,-51(A6)
00005C3C  FFCD      
00005C3E  52AE 000C 10606          addq.l    #1,12(A6)
00005C42  6026      10607          bra.s     vsprintf_7
                    10608   vsprintf_12:
00005C44  1D7C 0001 10609          move.b    #1,-50(A6)
00005C48  FFCE      
00005C4A  52AE 000C 10610          addq.l    #1,12(A6)
00005C4E  601A      10611          bra.s     vsprintf_7
                    10612   vsprintf_13:
00005C50  1D7C 0001 10613          move.b    #1,-49(A6)
00005C54  FFCF      
00005C56  52AE 000C 10614          addq.l    #1,12(A6)
00005C5A  600E      10615          bra.s     vsprintf_7
                    10616   vsprintf_14:
00005C5C  1D7C 0001 10617          move.b    #1,-48(A6)
00005C60  FFD0      
00005C62  52AE 000C 10618          addq.l    #1,12(A6)
00005C66  6002      10619          bra.s     vsprintf_7
                    10620   vsprintf_9:
00005C68  6002      10621          bra.s     vsprintf_8
                    10622   vsprintf_7:
00005C6A  6096      10623          bra       vsprintf_6
                    10624   vsprintf_8:
00005C6C  206E 000C 10625          move.l    12(A6),A0
00005C70  1010      10626          move.b    (A0),D0
00005C72  4880      10627          ext.w     D0
00005C74  48C0      10628          ext.l     D0
00005C76  0C80 0000 10629          cmp.l     #48,D0
00005C7A  0030      
00005C7C  660A      10630          bne.s     vsprintf_16
00005C7E  52AE 000C 10631          addq.l    #1,12(A6)
00005C82  1D7C 0001 10632          move.b    #1,-46(A6)
00005C86  FFD2      
                    10633   vsprintf_16:
00005C88  486E 0010 10634          pea       16(A6)
00005C8C  486E 000C 10635          pea       12(A6)
00005C90  6100 FE6E 10636          bsr       @vsprintf_getval
00005C94  504F      10637          addq.w    #8,A7
00005C96  2A40      10638          move.l    D0,A5
00005C98  206E 000C 10639          move.l    12(A6),A0
00005C9C  1010      10640          move.b    (A0),D0
00005C9E  4880      10641          ext.w     D0
00005CA0  48C0      10642          ext.l     D0
00005CA2  0C80 0000 10643          cmp.l     #46,D0
00005CA6  002E      
00005CA8  6614      10644          bne.s     vsprintf_18
00005CAA  52AE 000C 10645          addq.l    #1,12(A6)
00005CAE  486E 0010 10646          pea       16(A6)
00005CB2  486E 000C 10647          pea       12(A6)
00005CB6  6100 FE48 10648          bsr       @vsprintf_getval
00005CBA  504F      10649          addq.w    #8,A7
00005CBC  2A00      10650          move.l    D0,D5
                    10651   vsprintf_18:
00005CBE  206E 000C 10652          move.l    12(A6),A0
00005CC2  1010      10653          move.b    (A0),D0
00005CC4  4880      10654          ext.w     D0
00005CC6  48C0      10655          ext.l     D0
00005CC8  0C80 0000 10656          cmp.l     #108,D0
00005CCC  006C      
00005CCE  660A      10657          bne.s     vsprintf_20
00005CD0  52AE 000C 10658          addq.l    #1,12(A6)
00005CD4  1D7C 0001 10659          move.b    #1,-45(A6)
00005CD8  FFD3      
                    10660   vsprintf_20:
00005CDA  206E 000C 10661          move.l    12(A6),A0
00005CDE  1010      10662          move.b    (A0),D0
00005CE0  4880      10663          ext.w     D0
00005CE2  48C0      10664          ext.l     D0
00005CE4  0C80 0000 10665          cmp.l     #111,D0
00005CE8  006F      
00005CEA  6700 00D4 10666          beq       vsprintf_27
00005CEE  6E34      10667          bgt.s     vsprintf_33
00005CF0  0C80 0000 10668          cmp.l     #100,D0
00005CF4  0064      
00005CF6  6700 0054 10669          beq       vsprintf_24
00005CFA  6E1C      10670          bgt.s     vsprintf_34
00005CFC  0C80 0000 10671          cmp.l     #99,D0
00005D00  0063      
00005D02  6700 012C 10672          beq       vsprintf_30
00005D06  6E00 016A 10673          bgt       vsprintf_22
00005D0A  0C80 0000 10674          cmp.l     #88,D0
00005D0E  0058      
00005D10  6700 00E6 10675          beq       vsprintf_28
00005D14  6000 015C 10676          bra       vsprintf_22
                    10677   vsprintf_34:
00005D18  0C80 0000 10678          cmp.l     #105,D0
00005D1C  0069      
00005D1E  672C      10679          beq.s     vsprintf_24
00005D20  6000 0150 10680          bra       vsprintf_22
                    10681   vsprintf_33:
00005D24  0C80 0000 10682          cmp.l     #117,D0
00005D28  0075      
00005D2A  6700 005C 10683          beq       vsprintf_26
00005D2E  6E0E      10684          bgt.s     vsprintf_35
00005D30  0C80 0000 10685          cmp.l     #115,D0
00005D34  0073      
00005D36  6700 011C 10686          beq       vsprintf_31
00005D3A  6000 0136 10687          bra       vsprintf_22
                    10688   vsprintf_35:
00005D3E  0C80 0000 10689          cmp.l     #120,D0
00005D42  0078      
00005D44  6700 00B2 10690          beq       vsprintf_28
00005D48  6000 0128 10691          bra       vsprintf_22
                    10692   vsprintf_24:
00005D4C  4A2E FFD3 10693          tst.b     -45(A6)
00005D50  671A      10694          beq.s     vsprintf_36
00005D52  4878 000A 10695          pea       10
00005D56  2F03      10696          move.l    D3,-(A7)
00005D58  206E 0010 10697          move.l    16(A6),A0
00005D5C  58AE 0010 10698          addq.l    #4,16(A6)
00005D60  2F10      10699          move.l    (A0),-(A7)
00005D62  6100 04F8 10700          bsr       _ltoa
00005D66  DEFC 000C 10701          add.w     #12,A7
00005D6A  6018      10702          bra.s     vsprintf_37
                    10703   vsprintf_36:
00005D6C  4878 000A 10704          pea       10
00005D70  2F03      10705          move.l    D3,-(A7)
00005D72  206E 0010 10706          move.l    16(A6),A0
00005D76  58AE 0010 10707          addq.l    #4,16(A6)
00005D7A  2F10      10708          move.l    (A0),-(A7)
00005D7C  6100 04DE 10709          bsr       _ltoa
00005D80  DEFC 000C 10710          add.w     #12,A7
                    10711   vsprintf_37:
00005D84  6000 00FA 10712          bra       vsprintf_23
                    10713   vsprintf_26:
00005D88  4A2E FFD3 10714          tst.b     -45(A6)
00005D8C  6718      10715          beq.s     vsprintf_38
00005D8E  4878 000A 10716          pea       10
00005D92  2F03      10717          move.l    D3,-(A7)
00005D94  206E 0010 10718          move.l    16(A6),A0
00005D98  58AE 0010 10719          addq.l    #4,16(A6)
00005D9C  2F10      10720          move.l    (A0),-(A7)
00005D9E  4E94      10721          jsr       (A4)
00005DA0  DEFC 000C 10722          add.w     #12,A7
00005DA4  6016      10723          bra.s     vsprintf_39
                    10724   vsprintf_38:
00005DA6  4878 000A 10725          pea       10
00005DAA  2F03      10726          move.l    D3,-(A7)
00005DAC  206E 0010 10727          move.l    16(A6),A0
00005DB0  58AE 0010 10728          addq.l    #4,16(A6)
00005DB4  2F10      10729          move.l    (A0),-(A7)
00005DB6  4E94      10730          jsr       (A4)
00005DB8  DEFC 000C 10731          add.w     #12,A7
                    10732   vsprintf_39:
00005DBC  6000 00C2 10733          bra       vsprintf_23
                    10734   vsprintf_27:
00005DC0  4A2E FFD3 10735          tst.b     -45(A6)
00005DC4  6718      10736          beq.s     vsprintf_40
00005DC6  4878 0008 10737          pea       8
00005DCA  2F03      10738          move.l    D3,-(A7)
00005DCC  206E 0010 10739          move.l    16(A6),A0
00005DD0  58AE 0010 10740          addq.l    #4,16(A6)
00005DD4  2F10      10741          move.l    (A0),-(A7)
00005DD6  4E94      10742          jsr       (A4)
00005DD8  DEFC 000C 10743          add.w     #12,A7
00005DDC  6016      10744          bra.s     vsprintf_41
                    10745   vsprintf_40:
00005DDE  4878 0008 10746          pea       8
00005DE2  2F03      10747          move.l    D3,-(A7)
00005DE4  206E 0010 10748          move.l    16(A6),A0
00005DE8  58AE 0010 10749          addq.l    #4,16(A6)
00005DEC  2F10      10750          move.l    (A0),-(A7)
00005DEE  4E94      10751          jsr       (A4)
00005DF0  DEFC 000C 10752          add.w     #12,A7
                    10753   vsprintf_41:
00005DF4  6000 008A 10754          bra       vsprintf_23
                    10755   vsprintf_28:
00005DF8  4A2E FFD3 10756          tst.b     -45(A6)
00005DFC  6718      10757          beq.s     vsprintf_42
00005DFE  4878 0010 10758          pea       16
00005E02  2F03      10759          move.l    D3,-(A7)
00005E04  206E 0010 10760          move.l    16(A6),A0
00005E08  58AE 0010 10761          addq.l    #4,16(A6)
00005E0C  2F10      10762          move.l    (A0),-(A7)
00005E0E  4E94      10763          jsr       (A4)
00005E10  DEFC 000C 10764          add.w     #12,A7
00005E14  6016      10765          bra.s     vsprintf_43
                    10766   vsprintf_42:
00005E16  4878 0010 10767          pea       16
00005E1A  2F03      10768          move.l    D3,-(A7)
00005E1C  206E 0010 10769          move.l    16(A6),A0
00005E20  58AE 0010 10770          addq.l    #4,16(A6)
00005E24  2F10      10771          move.l    (A0),-(A7)
00005E26  4E94      10772          jsr       (A4)
00005E28  DEFC 000C 10773          add.w     #12,A7
                    10774   vsprintf_43:
00005E2C  6000 0052 10775          bra       vsprintf_23
                    10776   vsprintf_30:
00005E30  206E 0010 10777          move.l    16(A6),A0
00005E34  58AE 0010 10778          addq.l    #4,16(A6)
00005E38  2010      10779          move.l    (A0),D0
00005E3A  2042      10780          move.l    D2,A0
00005E3C  5282      10781          addq.l    #1,D2
00005E3E  1080      10782          move.b    D0,(A0)
00005E40  2042      10783          move.l    D2,A0
00005E42  4210      10784          clr.b     (A0)
00005E44  200D      10785          move.l    A5,D0
00005E46  6704      10786          beq.s     vsprintf_44
00005E48  200D      10787          move.l    A5,D0
00005E4A  6002      10788          bra.s     vsprintf_45
                    10789   vsprintf_44:
00005E4C  7001      10790          moveq     #1,D0
                    10791   vsprintf_45:
00005E4E  2A00      10792          move.l    D0,D5
00005E50  6000 002E 10793          bra       vsprintf_23
                    10794   vsprintf_31:
00005E54  206E 0010 10795          move.l    16(A6),A0
00005E58  58AE 0010 10796          addq.l    #4,16(A6)
00005E5C  2610      10797          move.l    (A0),D3
00005E5E  0C85 FFFF 10798          cmp.l     #-1,D5
00005E62  FFFF      
00005E64  660A      10799          bne.s     vsprintf_46
00005E66  2F03      10800          move.l    D3,-(A7)
00005E68  6100 04D8 10801          bsr       _strlen
00005E6C  584F      10802          addq.w    #4,A7
00005E6E  2A00      10803          move.l    D0,D5
                    10804   vsprintf_46:
00005E70  600E      10805          bra.s     vsprintf_23
                    10806   vsprintf_22:
00005E72  206E 000C 10807          move.l    12(A6),A0
00005E76  2242      10808          move.l    D2,A1
00005E78  5282      10809          addq.l    #1,D2
00005E7A  1290      10810          move.b    (A0),(A1)
00005E7C  2042      10811          move.l    D2,A0
00005E7E  4210      10812          clr.b     (A0)
                    10813   vsprintf_23:
00005E80  2F03      10814          move.l    D3,-(A7)
00005E82  6100 04BE 10815          bsr       _strlen
00005E86  584F      10816          addq.w    #4,A7
00005E88  1800      10817          move.b    D0,D4
00005E8A  206E 000C 10818          move.l    12(A6),A0
00005E8E  1010      10819          move.b    (A0),D0
00005E90  4880      10820          ext.w     D0
00005E92  48C0      10821          ext.l     D0
00005E94  0C80 0000 10822          cmp.l     #115,D0
00005E98  0073      
00005E9A  6618      10823          bne.s     vsprintf_48
00005E9C  0C85 0000 10824          cmp.l     #0,D5
00005EA0  0000      
00005EA2  6D10      10825          blt.s     vsprintf_48
00005EA4  4884      10826          ext.w     D4
00005EA6  48C4      10827          ext.l     D4
00005EA8  B885      10828          cmp.l     D5,D4
00005EAA  6F04      10829          ble.s     vsprintf_50
00005EAC  1005      10830          move.b    D5,D0
00005EAE  6002      10831          bra.s     vsprintf_51
                    10832   vsprintf_50:
00005EB0  1004      10833          move.b    D4,D0
                    10834   vsprintf_51:
00005EB2  1800      10835          move.b    D0,D4
                    10836   vsprintf_48:
00005EB4  206E 000C 10837          move.l    12(A6),A0
00005EB8  1010      10838          move.b    (A0),D0
00005EBA  4880      10839          ext.w     D0
00005EBC  48C0      10840          ext.l     D0
00005EBE  0C80 0000 10841          cmp.l     #88,D0
00005EC2  0058      
00005EC4  6600 0026 10842          bne       vsprintf_56
00005EC8  41EE FFDC 10843          lea       -36(A6),A0
00005ECC  2408      10844          move.l    A0,D2
                    10845   vsprintf_54:
00005ECE  2042      10846          move.l    D2,A0
00005ED0  4A10      10847          tst.b     (A0)
00005ED2  6718      10848          beq.s     vsprintf_56
00005ED4  2042      10849          move.l    D2,A0
00005ED6  1210      10850          move.b    (A0),D1
00005ED8  4881      10851          ext.w     D1
00005EDA  48C1      10852          ext.l     D1
00005EDC  2F01      10853          move.l    D1,-(A7)
00005EDE  6100 FB98 10854          bsr       _toupper
00005EE2  584F      10855          addq.w    #4,A7
00005EE4  2042      10856          move.l    D2,A0
00005EE6  1080      10857          move.b    D0,(A0)
00005EE8  5282      10858          addq.l    #1,D2
00005EEA  60E2      10859          bra       vsprintf_54
                    10860   vsprintf_56:
00005EEC  7E00      10861          moveq     #0,D7
00005EEE  41EE FFD4 10862          lea       -44(A6),A0
00005EF2  2408      10863          move.l    A0,D2
00005EF4  206E 000C 10864          move.l    12(A6),A0
00005EF8  1010      10865          move.b    (A0),D0
00005EFA  4880      10866          ext.w     D0
00005EFC  48C0      10867          ext.l     D0
00005EFE  0C80 0000 10868          cmp.l     #100,D0
00005F02  0064      
00005F04  6714      10869          beq.s     vsprintf_59
00005F06  206E 000C 10870          move.l    12(A6),A0
00005F0A  1010      10871          move.b    (A0),D0
00005F0C  4880      10872          ext.w     D0
00005F0E  48C0      10873          ext.l     D0
00005F10  0C80 0000 10874          cmp.l     #105,D0
00005F14  0069      
00005F16  6600 0076 10875          bne       vsprintf_65
                    10876   vsprintf_59:
00005F1A  4A2E FFCE 10877          tst.b     -50(A6)
00005F1E  6612      10878          bne.s     vsprintf_62
00005F20  2043      10879          move.l    D3,A0
00005F22  1010      10880          move.b    (A0),D0
00005F24  4880      10881          ext.w     D0
00005F26  48C0      10882          ext.l     D0
00005F28  0C80 0000 10883          cmp.l     #45,D0
00005F2C  002D      
00005F2E  6600 002E 10884          bne       vsprintf_60
                    10885   vsprintf_62:
00005F32  2043      10886          move.l    D3,A0
00005F34  1010      10887          move.b    (A0),D0
00005F36  4880      10888          ext.w     D0
00005F38  48C0      10889          ext.l     D0
00005F3A  0C80 0000 10890          cmp.l     #45,D0
00005F3E  002D      
00005F40  660E      10891          bne.s     vsprintf_63
00005F42  2043      10892          move.l    D3,A0
00005F44  5283      10893          addq.l    #1,D3
00005F46  2242      10894          move.l    D2,A1
00005F48  5282      10895          addq.l    #1,D2
00005F4A  1290      10896          move.b    (A0),(A1)
00005F4C  5304      10897          subq.b    #1,D4
00005F4E  6008      10898          bra.s     vsprintf_64
                    10899   vsprintf_63:
00005F50  2042      10900          move.l    D2,A0
00005F52  5282      10901          addq.l    #1,D2
00005F54  10BC 002B 10902          move.b    #43,(A0)
                    10903   vsprintf_64:
00005F58  5287      10904          addq.l    #1,D7
00005F5A  6000 0032 10905          bra       vsprintf_65
                    10906   vsprintf_60:
00005F5E  4A2E FFCF 10907          tst.b     -49(A6)
00005F62  6700 002A 10908          beq       vsprintf_65
00005F66  2043      10909          move.l    D3,A0
00005F68  1010      10910          move.b    (A0),D0
00005F6A  4880      10911          ext.w     D0
00005F6C  48C0      10912          ext.l     D0
00005F6E  0C80 0000 10913          cmp.l     #45,D0
00005F72  002D      
00005F74  660E      10914          bne.s     vsprintf_67
00005F76  2043      10915          move.l    D3,A0
00005F78  5283      10916          addq.l    #1,D3
00005F7A  2242      10917          move.l    D2,A1
00005F7C  5282      10918          addq.l    #1,D2
00005F7E  1290      10919          move.b    (A0),(A1)
00005F80  5304      10920          subq.b    #1,D4
00005F82  6008      10921          bra.s     vsprintf_68
                    10922   vsprintf_67:
00005F84  2042      10923          move.l    D2,A0
00005F86  5282      10924          addq.l    #1,D2
00005F88  10BC 0020 10925          move.b    #32,(A0)
                    10926   vsprintf_68:
00005F8C  5287      10927          addq.l    #1,D7
                    10928   vsprintf_65:
00005F8E  4A2E FFD0 10929          tst.b     -48(A6)
00005F92  6700 0066 10930          beq       vsprintf_77
00005F96  206E 000C 10931          move.l    12(A6),A0
00005F9A  1010      10932          move.b    (A0),D0
00005F9C  4880      10933          ext.w     D0
00005F9E  48C0      10934          ext.l     D0
00005FA0  0C80 0000 10935          cmp.l     #111,D0
00005FA4  006F      
00005FA6  671A      10936          beq.s     vsprintf_73
00005FA8  6E0C      10937          bgt.s     vsprintf_76
00005FAA  0C80 0000 10938          cmp.l     #88,D0
00005FAE  0058      
00005FB0  6710      10939          beq.s     vsprintf_73
00005FB2  6000 0046 10940          bra       vsprintf_77
                    10941   vsprintf_76:
00005FB6  0C80 0000 10942          cmp.l     #120,D0
00005FBA  0078      
00005FBC  6704      10943          beq.s     vsprintf_73
00005FBE  6000 003A 10944          bra       vsprintf_77
                    10945   vsprintf_73:
00005FC2  2042      10946          move.l    D2,A0
00005FC4  5282      10947          addq.l    #1,D2
00005FC6  10BC 0030 10948          move.b    #48,(A0)
00005FCA  5287      10949          addq.l    #1,D7
00005FCC  206E 000C 10950          move.l    12(A6),A0
00005FD0  1010      10951          move.b    (A0),D0
00005FD2  4880      10952          ext.w     D0
00005FD4  48C0      10953          ext.l     D0
00005FD6  0C80 0000 10954          cmp.l     #120,D0
00005FDA  0078      
00005FDC  6712      10955          beq.s     vsprintf_79
00005FDE  206E 000C 10956          move.l    12(A6),A0
00005FE2  1010      10957          move.b    (A0),D0
00005FE4  4880      10958          ext.w     D0
00005FE6  48C0      10959          ext.l     D0
00005FE8  0C80 0000 10960          cmp.l     #88,D0
00005FEC  0058      
00005FEE  660A      10961          bne.s     vsprintf_77
                    10962   vsprintf_79:
00005FF0  2042      10963          move.l    D2,A0
00005FF2  5282      10964          addq.l    #1,D2
00005FF4  10BC 0078 10965          move.b    #120,(A0)
00005FF8  5287      10966          addq.l    #1,D7
                    10967   vsprintf_77:
00005FFA  2042      10968          move.l    D2,A0
00005FFC  4210      10969          clr.b     (A0)
00005FFE  206E 000C 10970          move.l    12(A6),A0
00006002  1010      10971          move.b    (A0),D0
00006004  4880      10972          ext.w     D0
00006006  48C0      10973          ext.l     D0
00006008  0C80 0000 10974          cmp.l     #105,D0
0000600C  0069      
0000600E  6700 0076 10975          beq       vsprintf_82
00006012  6E42      10976          bgt.s     vsprintf_93
00006014  0C80 0000 10977          cmp.l     #99,D0
00006018  0063      
0000601A  6700 0084 10978          beq       vsprintf_96
0000601E  6E1C      10979          bgt.s     vsprintf_94
00006020  0C80 0000 10980          cmp.l     #88,D0
00006024  0058      
00006026  6700 005E 10981          beq       vsprintf_82
0000602A  6E00 0184 10982          bgt       vsprintf_80
0000602E  0C80 0000 10983          cmp.l     #69,D0
00006032  0045      
00006034  6700 0050 10984          beq       vsprintf_82
00006038  6000 0176 10985          bra       vsprintf_80
                    10986   vsprintf_94:
0000603C  0C80 0000 10987          cmp.l     #101,D0
00006040  0065      
00006042  6700 0042 10988          beq       vsprintf_82
00006046  6E00 0168 10989          bgt       vsprintf_80
0000604A  0C80 0000 10990          cmp.l     #100,D0
0000604E  0064      
00006050  6734      10991          beq.s     vsprintf_82
00006052  6000 015C 10992          bra       vsprintf_80
                    10993   vsprintf_93:
00006056  0C80 0000 10994          cmp.l     #117,D0
0000605A  0075      
0000605C  6728      10995          beq.s     vsprintf_82
0000605E  6E1A      10996          bgt.s     vsprintf_95
00006060  0C80 0000 10997          cmp.l     #115,D0
00006064  0073      
00006066  6700 0038 10998          beq       vsprintf_96
0000606A  6E00 0144 10999          bgt       vsprintf_80
0000606E  0C80 0000 11000          cmp.l     #111,D0
00006072  006F      
00006074  6710      11001          beq.s     vsprintf_82
00006076  6000 0138 11002          bra       vsprintf_80
                    11003   vsprintf_95:
0000607A  0C80 0000 11004          cmp.l     #120,D0
0000607E  0078      
00006080  6704      11005          beq.s     vsprintf_82
00006082  6000 012C 11006          bra       vsprintf_80
                    11007   vsprintf_82:
00006086  4A2E FFD2 11008          tst.b     -46(A6)
0000608A  6714      11009          beq.s     vsprintf_96
0000608C  4A2E FFCD 11010          tst.b     -51(A6)
00006090  660E      11011          bne.s     vsprintf_96
00006092  200D      11012          move.l    A5,D0
00006094  9087      11013          sub.l     D7,D0
00006096  4884      11014          ext.w     D4
00006098  48C4      11015          ext.l     D4
0000609A  9084      11016          sub.l     D4,D0
0000609C  2D40 FFFC 11017          move.l    D0,-4(A6)
                    11018   vsprintf_96:
000060A0  202E FFFC 11019          move.l    -4(A6),D0
000060A4  0C80 0000 11020          cmp.l     #0,D0
000060A8  0000      
000060AA  6C04      11021          bge.s     vsprintf_98
000060AC  42AE FFFC 11022          clr.l     -4(A6)
                    11023   vsprintf_98:
000060B0  4A2E FFCD 11024          tst.b     -51(A6)
000060B4  6600 0030 11025          bne       vsprintf_104
000060B8  4884      11026          ext.w     D4
000060BA  48C4      11027          ext.l     D4
000060BC  2004      11028          move.l    D4,D0
000060BE  D0AE FFFC 11029          add.l     -4(A6),D0
000060C2  D087      11030          add.l     D7,D0
000060C4  1D40 FFD1 11031          move.b    D0,-47(A6)
                    11032   vsprintf_102:
000060C8  102E FFD1 11033          move.b    -47(A6),D0
000060CC  4880      11034          ext.w     D0
000060CE  48C0      11035          ext.l     D0
000060D0  220D      11036          move.l    A5,D1
000060D2  534D      11037          subq.w    #1,A5
000060D4  B081      11038          cmp.l     D1,D0
000060D6  6C0E      11039          bge.s     vsprintf_104
000060D8  4878 0020 11040          pea       32
000060DC  2F0A      11041          move.l    A2,-(A7)
000060DE  4E93      11042          jsr       (A3)
000060E0  504F      11043          addq.w    #8,A7
000060E2  5286      11044          addq.l    #1,D6
000060E4  60E2      11045          bra       vsprintf_102
                    11046   vsprintf_104:
000060E6  41EE FFD4 11047          lea       -44(A6),A0
000060EA  2408      11048          move.l    A0,D2
                    11049   vsprintf_105:
000060EC  2042      11050          move.l    D2,A0
000060EE  4A10      11051          tst.b     (A0)
000060F0  6716      11052          beq.s     vsprintf_107
000060F2  2042      11053          move.l    D2,A0
000060F4  5282      11054          addq.l    #1,D2
000060F6  1210      11055          move.b    (A0),D1
000060F8  4881      11056          ext.w     D1
000060FA  48C1      11057          ext.l     D1
000060FC  2F01      11058          move.l    D1,-(A7)
000060FE  2F0A      11059          move.l    A2,-(A7)
00006100  4E93      11060          jsr       (A3)
00006102  504F      11061          addq.w    #8,A7
00006104  5286      11062          addq.l    #1,D6
00006106  60E4      11063          bra       vsprintf_105
                    11064   vsprintf_107:
00006108  202E FFFC 11065          move.l    -4(A6),D0
0000610C  1D40 FFD1 11066          move.b    D0,-47(A6)
                    11067   vsprintf_108:
00006110  102E FFD1 11068          move.b    -47(A6),D0
00006114  532E FFD1 11069          subq.b    #1,-47(A6)
00006118  4A00      11070          tst.b     D0
0000611A  670E      11071          beq.s     vsprintf_110
0000611C  4878 0030 11072          pea       48
00006120  2F0A      11073          move.l    A2,-(A7)
00006122  4E93      11074          jsr       (A3)
00006124  504F      11075          addq.w    #8,A7
00006126  5286      11076          addq.l    #1,D6
00006128  60E6      11077          bra       vsprintf_108
                    11078   vsprintf_110:
0000612A  2043      11079          move.l    D3,A0
0000612C  4A10      11080          tst.b     (A0)
0000612E  6700 0048 11081          beq       vsprintf_113
00006132  206E 000C 11082          move.l    12(A6),A0
00006136  1010      11083          move.b    (A0),D0
00006138  4880      11084          ext.w     D0
0000613A  48C0      11085          ext.l     D0
0000613C  0C80 0000 11086          cmp.l     #115,D0
00006140  0073      
00006142  670C      11087          beq.s     vsprintf_116
00006144  6E18      11088          bgt.s     vsprintf_119
00006146  0C80 0000 11089          cmp.l     #99,D0
0000614A  0063      
0000614C  6702      11090          beq.s     vsprintf_116
0000614E  600E      11091          bra.s     vsprintf_119
                    11092   vsprintf_116:
00006150  2005      11093          move.l    D5,D0
00006152  5385      11094          subq.l    #1,D5
00006154  0C80 0000 11095          cmp.l     #0,D0
00006158  0000      
0000615A  6E02      11096          bgt.s     vsprintf_119
0000615C  6016      11097          bra.s     vsprintf_115
                    11098   vsprintf_119:
0000615E  2043      11099          move.l    D3,A0
00006160  5283      11100          addq.l    #1,D3
00006162  1210      11101          move.b    (A0),D1
00006164  4881      11102          ext.w     D1
00006166  48C1      11103          ext.l     D1
00006168  2F01      11104          move.l    D1,-(A7)
0000616A  2F0A      11105          move.l    A2,-(A7)
0000616C  4E93      11106          jsr       (A3)
0000616E  504F      11107          addq.w    #8,A7
00006170  5286      11108          addq.l    #1,D6
00006172  6002      11109          bra.s     vsprintf_112
                    11110   vsprintf_115:
00006174  6002      11111          bra.s     vsprintf_113
                    11112   vsprintf_112:
00006176  60B2      11113          bra       vsprintf_110
                    11114   vsprintf_113:
00006178  4A2E FFCD 11115          tst.b     -51(A6)
0000617C  6700 0030 11116          beq       vsprintf_125
00006180  4884      11117          ext.w     D4
00006182  48C4      11118          ext.l     D4
00006184  2004      11119          move.l    D4,D0
00006186  D0AE FFFC 11120          add.l     -4(A6),D0
0000618A  D087      11121          add.l     D7,D0
0000618C  1D40 FFD1 11122          move.b    D0,-47(A6)
                    11123   vsprintf_123:
00006190  102E FFD1 11124          move.b    -47(A6),D0
00006194  4880      11125          ext.w     D0
00006196  48C0      11126          ext.l     D0
00006198  220D      11127          move.l    A5,D1
0000619A  534D      11128          subq.w    #1,A5
0000619C  B081      11129          cmp.l     D1,D0
0000619E  6C0E      11130          bge.s     vsprintf_125
000061A0  4878 0020 11131          pea       32
000061A4  2F0A      11132          move.l    A2,-(A7)
000061A6  4E93      11133          jsr       (A3)
000061A8  504F      11134          addq.w    #8,A7
000061AA  5386      11135          subq.l    #1,D6
000061AC  60E2      11136          bra       vsprintf_123
                    11137   vsprintf_125:
000061AE  6014      11138          bra.s     vsprintf_81
                    11139   vsprintf_80:
000061B0  206E 000C 11140          move.l    12(A6),A0
000061B4  1210      11141          move.b    (A0),D1
000061B6  4881      11142          ext.w     D1
000061B8  48C1      11143          ext.l     D1
000061BA  2F01      11144          move.l    D1,-(A7)
000061BC  2F0A      11145          move.l    A2,-(A7)
000061BE  4E93      11146          jsr       (A3)
000061C0  504F      11147          addq.w    #8,A7
000061C2  5286      11148          addq.l    #1,D6
                    11149   vsprintf_81:
000061C4  52AE 000C 11150          addq.l    #1,12(A6)
                    11151   vsprintf_2:
000061C8  6000 F9D6 11152          bra       vsprintf_1
                    11153   vsprintf_3:
000061CC  4A92      11154          tst.l     (A2)
000061CE  6710      11155          beq.s     vsprintf_126
000061D0  4201      11156          clr.b     D1
000061D2  C2BC 0000 11157          and.l     #255,D1
000061D6  00FF      
000061D8  2F01      11158          move.l    D1,-(A7)
000061DA  2F0A      11159          move.l    A2,-(A7)
000061DC  4E93      11160          jsr       (A3)
000061DE  504F      11161          addq.w    #8,A7
                    11162   vsprintf_126:
000061E0  2006      11163          move.l    D6,D0
000061E2  4CDF 3CFC 11164          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000061E6  4E5E      11165          unlk      A6
000061E8  4E75      11166          rts
                    11167   @itoa_convert:
000061EA  4E56 0000 11168          link      A6,#0
000061EE  48E7 3C00 11169          movem.l   D2/D3/D4/D5,-(A7)
000061F2  242E 0008 11170          move.l    8(A6),D2
000061F6  262E 0010 11171          move.l    16(A6),D3
000061FA  2A2E 000C 11172          move.l    12(A6),D5
000061FE  2F05      11173          move.l    D5,-(A7)
00006200  2F03      11174          move.l    D3,-(A7)
00006202  6100 F614 11175          bsr       ULDIV
00006206  202F 0004 11176          move.l    4(A7),D0
0000620A  504F      11177          addq.w    #8,A7
0000620C  2800      11178          move.l    D0,D4
0000620E  BA83      11179          cmp.l     D3,D5
00006210  651A      11180          blo.s     @itoa_convert_1
00006212  2F03      11181          move.l    D3,-(A7)
00006214  2F05      11182          move.l    D5,-(A7)
00006216  2F03      11183          move.l    D3,-(A7)
00006218  6100 F5FE 11184          bsr       ULDIV
0000621C  2217      11185          move.l    (A7),D1
0000621E  504F      11186          addq.w    #8,A7
00006220  2F01      11187          move.l    D1,-(A7)
00006222  2F02      11188          move.l    D2,-(A7)
00006224  61C4      11189          bsr       @itoa_convert
00006226  DEFC 000C 11190          add.w     #12,A7
0000622A  2400      11191          move.l    D0,D2
                    11192   @itoa_convert_1:
0000622C  0C84 0000 11193          cmp.l     #9,D4
00006230  0009      
00006232  6E0A      11194          bgt.s     @itoa_convert_3
00006234  2004      11195          move.l    D4,D0
00006236  0680 0000 11196          add.l     #48,D0
0000623A  0030      
0000623C  600E      11197          bra.s     @itoa_convert_4
                    11198   @itoa_convert_3:
0000623E  2004      11199          move.l    D4,D0
00006240  0680 0000 11200          add.l     #97,D0
00006244  0061      
00006246  0480 0000 11201          sub.l     #10,D0
0000624A  000A      
                    11202   @itoa_convert_4:
0000624C  2042      11203          move.l    D2,A0
0000624E  1080      11204          move.b    D0,(A0)
00006250  2002      11205          move.l    D2,D0
00006252  5280      11206          addq.l    #1,D0
00006254  4CDF 003C 11207          movem.l   (A7)+,D2/D3/D4/D5
00006258  4E5E      11208          unlk      A6
0000625A  4E75      11209          rts
                    11210   _ltoa:
0000625C  4E56 0000 11211          link      A6,#0
00006260  48E7 3C00 11212          movem.l   D2/D3/D4/D5,-(A7)
00006264  242E 0008 11213          move.l    8(A6),D2
00006268  262E 000C 11214          move.l    12(A6),D3
0000626C  2A2E 0010 11215          move.l    16(A6),D5
00006270  2803      11216          move.l    D3,D4
00006272  0C85 0000 11217          cmp.l     #2,D5
00006276  0002      
00006278  6D08      11218          blt.s     ltoa_3
0000627A  0C85 0000 11219          cmp.l     #36,D5
0000627E  0024      
00006280  6F06      11220          ble.s     ltoa_1
                    11221   ltoa_3:
00006282  2003      11222          move.l    D3,D0
00006284  6000 0052 11223          bra       ltoa_4
                    11224   ltoa_1:
00006288  0C85 0000 11225          cmp.l     #10,D5
0000628C  000A      
0000628E  6600 0032 11226          bne       ltoa_5
00006292  0C82 0000 11227          cmp.l     #0,D2
00006296  0000      
00006298  6C28      11228          bge.s     ltoa_5
0000629A  2002      11229          move.l    D2,D0
0000629C  4480      11230          neg.l     D0
0000629E  2400      11231          move.l    D0,D2
000062A0  0C82 0000 11232          cmp.l     #0,D2
000062A4  0000      
000062A6  6C12      11233          bge.s     ltoa_7
000062A8  4879 0000 11234          pea       @itoa_1
000062AC  7AAA      
000062AE  2F03      11235          move.l    D3,-(A7)
000062B0  6100 F556 11236          bsr       _strcpy
000062B4  504F      11237          addq.w    #8,A7
000062B6  2003      11238          move.l    D3,D0
000062B8  601E      11239          bra.s     ltoa_4
                    11240   ltoa_7:
000062BA  2044      11241          move.l    D4,A0
000062BC  5284      11242          addq.l    #1,D4
000062BE  10BC 002D 11243          move.b    #45,(A0)
                    11244   ltoa_5:
000062C2  2F05      11245          move.l    D5,-(A7)
000062C4  2F02      11246          move.l    D2,-(A7)
000062C6  2F04      11247          move.l    D4,-(A7)
000062C8  6100 FF20 11248          bsr       @itoa_convert
000062CC  DEFC 000C 11249          add.w     #12,A7
000062D0  2800      11250          move.l    D0,D4
000062D2  2044      11251          move.l    D4,A0
000062D4  4210      11252          clr.b     (A0)
000062D6  2003      11253          move.l    D3,D0
                    11254   ltoa_4:
000062D8  4CDF 003C 11255          movem.l   (A7)+,D2/D3/D4/D5
000062DC  4E5E      11256          unlk      A6
000062DE  4E75      11257          rts
                    11258   _ultoa:
000062E0  4E56 0000 11259          link      A6,#0
000062E4  48E7 3800 11260          movem.l   D2/D3/D4,-(A7)
000062E8  262E 0010 11261          move.l    16(A6),D3
000062EC  282E 000C 11262          move.l    12(A6),D4
000062F0  2404      11263          move.l    D4,D2
000062F2  0C83 0000 11264          cmp.l     #2,D3
000062F6  0002      
000062F8  6D08      11265          blt.s     ultoa_3
000062FA  0C83 0000 11266          cmp.l     #36,D3
000062FE  0024      
00006300  6F04      11267          ble.s     ultoa_1
                    11268   ultoa_3:
00006302  2004      11269          move.l    D4,D0
00006304  6018      11270          bra.s     ultoa_4
                    11271   ultoa_1:
00006306  2F03      11272          move.l    D3,-(A7)
00006308  2F2E 0008 11273          move.l    8(A6),-(A7)
0000630C  2F02      11274          move.l    D2,-(A7)
0000630E  6100 FEDA 11275          bsr       @itoa_convert
00006312  DEFC 000C 11276          add.w     #12,A7
00006316  2400      11277          move.l    D0,D2
00006318  2042      11278          move.l    D2,A0
0000631A  4210      11279          clr.b     (A0)
0000631C  2004      11280          move.l    D4,D0
                    11281   ultoa_4:
0000631E  4CDF 001C 11282          movem.l   (A7)+,D2/D3/D4
00006322  4E5E      11283          unlk      A6
00006324  4E75      11284          rts
                    11285   _itoa:
00006326  4E56 0000 11286          link      A6,#0
0000632A  2F2E 0010 11287          move.l    16(A6),-(A7)
0000632E  2F2E 000C 11288          move.l    12(A6),-(A7)
00006332  2F2E 0008 11289          move.l    8(A6),-(A7)
00006336  6100 FF24 11290          bsr       _ltoa
0000633A  DEFC 000C 11291          add.w     #12,A7
0000633E  4E5E      11292          unlk      A6
00006340  4E75      11293          rts
                    11294   _strlen:
00006342  206F 0004 11295          move.l    (4,A7),A0
00006346  2248      11296          move.l    A0,A1
                    11297   strlen_1:
00006348  4A19      11298          tst.b     (A1)+
0000634A  66FC      11299          bne       strlen_1
0000634C  2009      11300          move.l    A1,D0
0000634E  9088      11301          sub.l     A0,D0
00006350  5380      11302          subq.l    #1,D0
00006352  4E75      11303          rts
                    11304          section   const
                    11305   
                    11306   @m68kde~2_1:
00006354  0D0A 00   11307          dc.b      13,10,0
                    11308   @m68kde~2_2:
00006358  0D53 7769 11309          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
0000635C  7463 6865 
00006360  7320 5357 
00006364  5B        
00006365  372D 305D 11310          dc.b      55,45,48,93,32,61,32,0
00006369  203D 2000 
                    11311   @m68kde~2_3:
0000636E  3000      11312          dc.b      48,0
                    11313   @m68kde~2_4:
00006370  3100      11314          dc.b      49,0
                    11315   @m68kde~2_5:
00006372  0D0A 456E 11316          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00006376  7465 7220 
0000637A  5374 6172 
0000637E  74        
0000637F  2041 6464 11317          dc.b      32,65,100,100,114,101,115,115,58,32,0
00006383  7265 7373 
00006387  3A20 00   
                    11318   @m68kde~2_6:
0000638A  0D0A 3C45 11319          dc.b      13,10,60,69,83,67,62,32,61,32,65,98,111,114
0000638E  5343 3E20 
00006392  3D20 4162 
00006396  6F72      
00006398  742C 2053 11320          dc.b      116,44,32,83,80,65,67,69,32,116,111,32,67,111
0000639C  5041 4345 
000063A0  2074 6F20 
000063A4  436F      
000063A6  6E74 696E 11321          dc.b      110,116,105,110,117,101,0
000063AA  7565 00   
                    11322   @m68kde~2_7:
000063AE  0D0A 2530 11323          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,32,32
000063B2  3858 2020 
000063B6  2530 3458 
000063BA  2020 20   
000063BD  2020 2020 11324          dc.b      32,32,32,32,32,32,32,32,32,32,32,32,32,32,32
000063C1  2020 2020 
000063C5  2020 2020 
000063C9  2020 20   
000063CC  2020 2020 11325          dc.b      32,32,32,32,32,32,37,115,0
000063D0  2020 2573 
000063D4  00        
                    11326   @m68kde~2_8:
000063D6  0D0A 2530 11327          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,37,48
000063DA  3858 2020 
000063DE  2530 3458 
000063E2  2025 30   
000063E5  3458 2020 11328          dc.b      52,88,32,32,32,32,32,32,32,32,32,32,32,32,32
000063E9  2020 2020 
000063ED  2020 2020 
000063F1  2020 20   
000063F4  2020 2020 11329          dc.b      32,32,32,32,32,32,37,115,0
000063F8  2020 2573 
000063FC  00        
                    11330   @m68kde~2_9:
000063FE  0D0A 2530 11331          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,37,48
00006402  3858 2020 
00006406  2530 3458 
0000640A  2025 30   
0000640D  3458 2025 11332          dc.b      52,88,32,37,48,52,88,32,32,32,32,32,32,32,32
00006411  3034 5820 
00006415  2020 2020 
00006419  2020 20   
0000641C  2020 2020 11333          dc.b      32,32,32,32,32,32,37,115,0
00006420  2020 2573 
00006424  00        
                    11334   @m68kde~2_10:
00006426  0D0A 2530 11335          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,37,48
0000642A  3858 2020 
0000642E  2530 3458 
00006432  2025 30   
00006435  3458 2025 11336          dc.b      52,88,32,37,48,52,88,32,37,48,52,88,32,32,32
00006439  3034 5820 
0000643D  2530 3458 
00006441  2020 20   
00006444  2020 2020 11337          dc.b      32,32,32,32,32,32,37,115,0
00006448  2020 2573 
0000644C  00        
                    11338   @m68kde~2_11:
0000644E  0D0A 2530 11339          dc.b      13,10,37,48,56,88,32,32,37,48,52,88,32,37,48
00006452  3858 2020 
00006456  2530 3458 
0000645A  2025 30   
0000645D  3458 2025 11340          dc.b      52,88,32,37,48,52,88,32,37,48,52,88,32,37,48
00006461  3034 5820 
00006465  2530 3458 
00006469  2025 30   
0000646C  3458 2020 11341          dc.b      52,88,32,32,32,32,37,115,0
00006470  2020 2573 
00006474  00        
                    11342   @m68kde~2_12:
00006476  0D0A 4475 11343          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
0000647A  6D70 204D 
0000647E  656D 6F72 
00006482  79        
00006483  2042 6C6F 11344          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00006487  636B 3A20 
0000648B  3C45 5343 
0000648F  3E20      
00006491  746F 2041 11345          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00006495  626F 7274 
00006499  2C20 3C53 
0000649D  50        
0000649E  4143 453E 11346          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
000064A2  2074 6F20 
000064A6  436F 6E74 
000064AA  69        
000064AB  6E75 6500 11347          dc.b      110,117,101,0
                    11348   @m68kde~2_13:
000064B0  0D0A 2530 11349          dc.b      13,10,37,48,56,120,32,0
000064B4  3878 2000 
                    11350   @m68kde~2_14:
000064B8  2530 3258 11351          dc.b      37,48,50,88,0
000064BC  00        
                    11352   @m68kde~2_15:
000064BE  2020 00   11353          dc.b      32,32,0
                    11354   @m68kde~2_16:
000064C2  0D0A 4669 11355          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
000064C6  6C6C 204D 
000064CA  656D 6F72 
000064CE  79        
000064CF  2042 6C6F 11356          dc.b      32,66,108,111,99,107,0
000064D3  636B 00   
                    11357   @m68kde~2_17:
000064D6  0D0A 456E 11358          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
000064DA  7465 7220 
000064DE  456E 6420 
000064E2  41        
000064E3  6464 7265 11359          dc.b      100,100,114,101,115,115,58,32,0
000064E7  7373 3A20 
000064EB  00        
                    11360   @m68kde~2_18:
000064EC  0D0A 456E 11361          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
000064F0  7465 7220 
000064F4  4669 6C6C 
000064F8  20        
000064F9  4461 7461 11362          dc.b      68,97,116,97,58,32,0
000064FD  3A20 00   
                    11363   @m68kde~2_19:
00006500  0D0A 4669 11364          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
00006504  6C6C 696E 
00006508  6720 4164 
0000650C  64        
0000650D  7265 7373 11365          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00006511  6573 205B 
00006515  2425 3038 
00006519  58        
0000651A  202D 2024 11366          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
0000651E  2530 3858 
00006522  5D20 7769 
00006526  7468      
00006528  2024 2530 11367          dc.b      32,36,37,48,50,88,0
0000652C  3258 00   
                    11368   @m68kde~2_20:
00006530  0D0A 5573 11369          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
00006534  6520 4879 
00006538  7065 7254 
0000653C  65        
0000653D  726D 696E 11370          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
00006541  616C 2074 
00006545  6F20 5365 
00006549  6E64 2054 11371          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
0000654D  6578 7420 
00006551  4669 6C65 
00006555  2028 2E68 11372          dc.b      32,40,46,104,101,120,41,13,10,0
00006559  6578 290D 
0000655D  0A00      
                    11373   @m68kde~2_21:
00006560  0D0A 4C6F 11374          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
00006564  6164 2046 
00006568  6169 6C65 
0000656C  64        
0000656D  2061 7420 11375          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
00006571  4164 6472 
00006575  6573 7320 
00006579  3D        
0000657A  205B 2425 11376          dc.b      32,91,36,37,48,56,88,93,13,10,0
0000657E  3038 585D 
00006582  0D0A 00   
                    11377   @m68kde~2_22:
00006586  0D0A 5375 11378          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
0000658A  6363 6573 
0000658E  733A 2044 
00006592  6F        
00006593  776E 6C6F 11379          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
00006597  6164 6564 
0000659B  2025 6420 
0000659F  6279 7465 11380          dc.b      98,121,116,101,115,13,10,0
000065A3  730D 0A00 
                    11381   @m68kde~2_23:
000065A8  0D0A 4578 11382          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
000065AC  616D 696E 
000065B0  6520 616E 
000065B4  64        
000065B5  2043 6861 11383          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
000065B9  6E67 6520 
000065BD  4D65 6D6F 
000065C1  72        
000065C2  7900      11384          dc.b      121,0
                    11385   @m68kde~2_24:
000065C4  0D0A 3C45 11386          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
000065C8  5343 3E20 
000065CC  746F 2053 
000065D0  746F      
000065D2  702C 203C 11387          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
000065D6  5350 4143 
000065DA  453E 2074 
000065DE  6F20      
000065E0  4164 7661 11388          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
000065E4  6E63 652C 
000065E8  2027 2D27 
000065EC  2074      
000065EE  6F20 476F 11389          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
000065F2  2042 6163 
000065F6  6B2C 203C 
000065FA  4441      
000065FC  5441 3E20 11390          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
00006600  746F 2063 
00006604  6861 6E67 
00006608  65        
00006609  00        11391          dc.b      0
                    11392   @m68kde~2_25:
0000660A  0D0A 456E 11393          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
0000660E  7465 7220 
00006612  4164 6472 
00006616  65        
00006617  7373 3A20 11394          dc.b      115,115,58,32,0
0000661B  00        
                    11395   @m68kde~2_26:
0000661C  0D0A 5B25 11396          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
00006620  3038 785D 
00006624  203A 2025 
00006628  3032 78   
0000662B  2020 00   11397          dc.b      32,32,0
                    11398   @m68kde~2_27:
0000662E  0D0A 5761 11399          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
00006632  726E 696E 
00006636  6720 4368 
0000663A  61        
0000663B  6E67 6520 11400          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
0000663F  4661 696C 
00006643  6564 3A20 
00006647  57        
00006648  726F 7465 11401          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
0000664C  205B 2530 
00006650  3278 5D2C 
00006654  20        
00006655  5265 6164 11402          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
00006659  205B 2530 
0000665D  3278 5D00 
                    11403   @m68kde~2_28:
00006662  4572 726F 11404          dc.b      69,114,114,111,114,58,32,68,97,116,97,32,109
00006666  723A 2044 
0000666A  6174 6120 
0000666E  6D        
0000666F  6973 6D61 11405          dc.b      105,115,109,97,116,99,104,32,97,116,32,97,100
00006673  7463 6820 
00006677  6174 2061 
0000667B  64        
0000667C  6472 6573 11406          dc.b      100,114,101,115,115,32,48,120,37,48,54,88,10
00006680  7320 3078 
00006684  2530 3658 
00006688  0A        
00006689  00        11407          dc.b      0
                    11408   @m68kde~2_29:
0000668A  5375 6363 11409          dc.b      83,117,99,99,101,115,115,58,32,68,97,116,97
0000668E  6573 733A 
00006692  2044 6174 
00006696  61        
00006697  2076 6572 11410          dc.b      32,118,101,114,105,102,105,101,100,10,0
0000669B  6966 6965 
0000669F  640A 00   
                    11411   @m68kde~2_30:
000066A2  0D0A 4C6F 11412          dc.b      13,10,76,111,97,100,105,110,103,32,80,114,111
000066A6  6164 696E 
000066AA  6720 5072 
000066AE  6F        
000066AF  6772 616D 11413          dc.b      103,114,97,109,32,70,114,111,109,32,83,80,73
000066B3  2046 726F 
000066B7  6D20 5350 
000066BB  49        
000066BC  2046 6C61 11414          dc.b      32,70,108,97,115,104,46,46,46,46,0
000066C0  7368 2E2E 
000066C4  2E2E 00   
                    11415   @m68kde~2_31:
000066C8  2425 3038 11416          dc.b      36,37,48,56,88,32,32,0
000066CC  5820 2000 
                    11417   @m68kde~2_32:
000066D0  2000      11418          dc.b      32,0
                    11419   @m68kde~2_33:
000066D2  2E00      11420          dc.b      46,0
                    11421   @m68kde~2_34:
000066D4  2563 00   11422          dc.b      37,99,0
                    11423   @m68kde~2_35:
000066D8  00        11424          dc.b      0
                    11425   @m68kde~2_36:
000066DA  0D0A 0D0A 11426          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
000066DE  2044 3020 
000066E2  3D20 2425 
000066E6  3038 58   
000066E9  2020 4130 11427          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
000066ED  203D 2024 
000066F1  2530 3858 
000066F5  00        
                    11428   @m68kde~2_37:
000066F6  0D0A 2044 11429          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
000066FA  3120 3D20 
000066FE  2425 3038 
00006702  5820 20   
00006705  4131 203D 11430          dc.b      65,49,32,61,32,36,37,48,56,88,0
00006709  2024 2530 
0000670D  3858 00   
                    11431   @m68kde~2_38:
00006710  0D0A 2044 11432          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
00006714  3220 3D20 
00006718  2425 3038 
0000671C  5820 20   
0000671F  4132 203D 11433          dc.b      65,50,32,61,32,36,37,48,56,88,0
00006723  2024 2530 
00006727  3858 00   
                    11434   @m68kde~2_39:
0000672A  0D0A 2044 11435          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
0000672E  3320 3D20 
00006732  2425 3038 
00006736  5820 20   
00006739  4133 203D 11436          dc.b      65,51,32,61,32,36,37,48,56,88,0
0000673D  2024 2530 
00006741  3858 00   
                    11437   @m68kde~2_40:
00006744  0D0A 2044 11438          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
00006748  3420 3D20 
0000674C  2425 3038 
00006750  5820 20   
00006753  4134 203D 11439          dc.b      65,52,32,61,32,36,37,48,56,88,0
00006757  2024 2530 
0000675B  3858 00   
                    11440   @m68kde~2_41:
0000675E  0D0A 2044 11441          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
00006762  3520 3D20 
00006766  2425 3038 
0000676A  5820 20   
0000676D  4135 203D 11442          dc.b      65,53,32,61,32,36,37,48,56,88,0
00006771  2024 2530 
00006775  3858 00   
                    11443   @m68kde~2_42:
00006778  0D0A 2044 11444          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
0000677C  3620 3D20 
00006780  2425 3038 
00006784  5820 20   
00006787  4136 203D 11445          dc.b      65,54,32,61,32,36,37,48,56,88,0
0000678B  2024 2530 
0000678F  3858 00   
                    11446   @m68kde~2_43:
00006792  0D0A 2044 11447          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
00006796  3720 3D20 
0000679A  2425 3038 
0000679E  5820 20   
000067A1  4137 203D 11448          dc.b      65,55,32,61,32,36,37,48,56,88,0
000067A5  2024 2530 
000067A9  3858 00   
                    11449   @m68kde~2_44:
000067AC  0D0A 0D0A 11450          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
000067B0  5553 5020 
000067B4  3D20 2425 
000067B8  3038 58   
000067BB  2020 2841 11451          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
000067BF  3729 2055 
000067C3  7365 7220 
000067C7  5350      
000067C9  00        11452          dc.b      0
                    11453   @m68kde~2_45:
000067CA  0D0A 5353 11454          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
000067CE  5020 3D20 
000067D2  2425 3038 
000067D6  5820 20   
000067D9  2841 3729 11455          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
000067DD  2053 7570 
000067E1  6572 7669 
000067E5  73        
000067E6  6F72 2053 11456          dc.b      111,114,32,83,80,0
000067EA  5000      
                    11457   @m68kde~2_46:
000067EC  0D0A 2053 11458          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
000067F0  5220 3D20 
000067F4  2425 3034 
000067F8  5820 20   
000067FB  2000      11459          dc.b      32,0
                    11460   @m68kde~2_47:
000067FE  2020 205B 11461          dc.b      32,32,32,91,0
00006802  00        
                    11462   @m68kde~2_48:
00006804  0D0A 2050 11463          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
00006808  4320 3D20 
0000680C  2425 3038 
00006810  5820 20   
00006813  00        11464          dc.b      0
                    11465   @m68kde~2_49:
00006814  2573 00   11466          dc.b      37,115,0
                    11467   @m68kde~2_50:
00006818  5B42 5245 11468          dc.b      91,66,82,69,65,75,80,79,73,78,84,93,0
0000681C  414B 504F 
00006820  494E 545D 
00006824  00        
                    11469   @m68kde~2_51:
00006826  0D0A 5750 11470          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
0000682A  2564 203D 
0000682E  2025 7300 
                    11471   @m68kde~2_52:
00006832  0D0A 0D0A 11472          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
00006836  0D0A 0D0A 
0000683A  0D0A 0D0A 
0000683E  5369 6E   
00006841  676C 6520 11473          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
00006845  5374 6570 
00006849  2020 3A5B 
0000684D  4F        
0000684E  4E5D 00   11474          dc.b      78,93,0
                    11475   @m68kde~2_53:
00006852  0D0A 4272 11476          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006856  6561 6B20 
0000685A  506F 696E 
0000685E  74        
0000685F  7320 3A5B 11477          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
00006863  4469 7361 
00006867  626C 6564 
0000686B  5D        
0000686C  00        11478          dc.b      0
                    11479   @m68kde~2_54:
0000686E  0D0A 5072 11480          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
00006872  6573 7320 
00006876  3C53 5041 
0000687A  4345      
0000687C  3E20 746F 11481          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
00006880  2045 7865 
00006884  6375 7465 
00006888  20        
00006889  4E65 7874 11482          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
0000688D  2049 6E73 
00006891  7472 7563 
00006895  7469 6F6E 11483          dc.b      116,105,111,110,0
00006899  00        
                    11484   @m68kde~2_55:
0000689A  0D0A 5072 11485          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
0000689E  6573 7320 
000068A2  3C45 5343 
000068A6  3E20      
000068A8  746F 2052 11486          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
000068AC  6573 756D 
000068B0  6520 5072 
000068B4  6F67 7261 11487          dc.b      111,103,114,97,109,0
000068B8  6D00      
                    11488   @m68kde~2_56:
000068BA  0D0A 496C 11489          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
000068BE  6C65 6761 
000068C2  6C20 4461 
000068C6  74        
000068C7  6120 5265 11490          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
000068CB  6769 7374 
000068CF  6572 203A 
000068D3  20        
000068D4  5573 6520 11491          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
000068D8  4430 2D44 
000068DC  372E 2E2E 
000068E0  2E2E      
000068E2  0D0A 00   11492          dc.b      13,10,0
                    11493   @m68kde~2_57:
000068E6  0D0A 4425 11494          dc.b      13,10,68,37,99,32,61,32,0
000068EA  6320 3D20 
000068EE  00        
                    11495   @m68kde~2_58:
000068F0  0D0A 496C 11496          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
000068F4  6C65 6761 
000068F8  6C20 4164 
000068FC  64        
000068FD  7265 7373 11497          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
00006901  2052 6567 
00006905  6973 7465 
00006909  7220 3A20 11498          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
0000690D  5573 6520 
00006911  4130 2D41 
00006915  372E      
00006917  2E2E 2E2E 11499          dc.b      46,46,46,46,13,10,0
0000691B  0D0A 00   
                    11500   @m68kde~2_59:
0000691E  0D0A 4125 11501          dc.b      13,10,65,37,99,32,61,32,0
00006922  6320 3D20 
00006926  00        
                    11502   @m68kde~2_60:
00006928  0D0A 5573 11503          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
0000692C  6572 2053 
00006930  5020 3D20 
00006934  00        
                    11504   @m68kde~2_61:
00006936  0D0A 496C 11505          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
0000693A  6C65 6761 
0000693E  6C20 5265 
00006942  67        
00006943  6973 7465 11506          dc.b      105,115,116,101,114,46,46,46,46,0
00006947  722E 2E2E 
0000694B  2E00      
                    11507   @m68kde~2_62:
0000694E  0D0A 5379 11508          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
00006952  7374 656D 
00006956  2053 5020 
0000695A  3D        
0000695B  2000      11509          dc.b      32,0
                    11510   @m68kde~2_63:
0000695E  0D0A 5043 11511          dc.b      13,10,80,67,32,61,32,0
00006962  203D 2000 
                    11512   @m68kde~2_64:
00006966  0D0A 5352 11513          dc.b      13,10,83,82,32,61,32,0
0000696A  203D 2000 
                    11514   @m68kde~2_65:
0000696E  0D0A 496C 11515          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00006972  6C65 6761 
00006976  6C20 5265 
0000697A  67        
0000697B  6973 7465 11516          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
0000697F  723A 2055 
00006983  7365 2041 
00006987  30        
00006988  2D41 372C 11517          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
0000698C  2044 302D 
00006990  4437 2C20 
00006994  5353 50   
00006997  2C20 5553 11518          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
0000699B  502C 2050 
0000699F  4320 6F72 
000069A3  2053      
000069A5  520D 0A00 11519          dc.b      82,13,10,0
                    11520   @m68kde~2_66:
000069AA  0D0A 0D0A 11521          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
000069AE  4E75 6D20 
000069B2  2020 2020 
000069B6  4164      
000069B8  6472 6573 11522          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
000069BC  7320 2020 
000069C0  2020 2049 
000069C4  6E        
000069C5  7374 7275 11523          dc.b      115,116,114,117,99,116,105,111,110,0
000069C9  6374 696F 
000069CD  6E00      
                    11524   @m68kde~2_67:
000069D0  0D0A 2D2D 11525          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
000069D4  2D20 2020 
000069D8  2020 2D2D 
000069DC  2D2D 2D   
000069DF  2D2D 2D2D 11526          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
000069E3  2020 2020 
000069E7  2D2D 2D2D 
000069EB  2D2D 2D   
000069EE  2D2D 2D2D 11527          dc.b      45,45,45,45,0
000069F2  00        
                    11528   @m68kde~2_68:
000069F4  0D0A 4E6F 11529          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
000069F8  2042 7265 
000069FC  616B 506F 
00006A00  69        
00006A01  6E74 7320 11530          dc.b      110,116,115,32,83,101,116,0
00006A05  5365 7400 
                    11531   @m68kde~2_69:
00006A0A  0D0A 2533 11532          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
00006A0E  6420 2020 
00006A12  2020 2425 
00006A16  3038 78   
00006A19  00        11533          dc.b      0
                    11534   @m68kde~2_70:
00006A1A  2020 2020 11535          dc.b      32,32,32,32,37,115,0
00006A1E  2573 00   
                    11536   @m68kde~2_71:
00006A22  0D0A 4E75 11537          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
00006A26  6D20 2020 
00006A2A  2020 4164 
00006A2E  6472      
00006A30  6573 7300 11538          dc.b      101,115,115,0
                    11539   @m68kde~2_72:
00006A34  0D0A 2D2D 11540          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00006A38  2D20 2020 
00006A3C  2020 2D2D 
00006A40  2D2D 2D   
00006A43  2D2D 2D2D 11541          dc.b      45,45,45,45,0
00006A47  00        
                    11542   @m68kde~2_73:
00006A48  0D0A 4E6F 11543          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
00006A4C  2057 6174 
00006A50  6368 506F 
00006A54  69        
00006A55  6E74 7320 11544          dc.b      110,116,115,32,83,101,116,0
00006A59  5365 7400 
                    11545   @m68kde~2_74:
00006A5E  0D0A 456E 11546          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
00006A62  7465 7220 
00006A66  4272 6561 
00006A6A  6B        
00006A6B  2050 6F69 11547          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00006A6F  6E74 204E 
00006A73  756D 6265 
00006A77  72        
00006A78  3A20 00   11548          dc.b      58,32,0
                    11549   @m68kde~2_75:
00006A7C  0D0A 496C 11550          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
00006A80  6C65 6761 
00006A84  6C20 5261 
00006A88  6E        
00006A89  6765 203A 11551          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
00006A8D  2055 7365 
00006A91  2030 202D 
00006A95  2037      
00006A97  00        11552          dc.b      0
                    11553   @m68kde~2_76:
00006A98  0D0A 4272 11554          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006A9C  6561 6B20 
00006AA0  506F 696E 
00006AA4  74        
00006AA5  2043 6C65 11555          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00006AA9  6172 6564 
00006AAD  2E2E 2E2E 
00006AB1  2E        
00006AB2  0D0A 00   11556          dc.b      13,10,0
                    11557   @m68kde~2_77:
00006AB6  0D0A 4272 11558          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006ABA  6561 6B20 
00006ABE  506F 696E 
00006AC2  74        
00006AC3  2077 6173 11559          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
00006AC7  6E27 7420 
00006ACB  5365 742E 
00006ACF  2E        
00006AD0  2E2E 2E00 11560          dc.b      46,46,46,0
                    11561   @m68kde~2_78:
00006AD4  0D0A 456E 11562          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
00006AD8  7465 7220 
00006ADC  5761 7463 
00006AE0  68        
00006AE1  2050 6F69 11563          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00006AE5  6E74 204E 
00006AE9  756D 6265 
00006AED  72        
00006AEE  3A20 00   11564          dc.b      58,32,0
                    11565   @m68kde~2_79:
00006AF2  0D0A 5761 11566          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00006AF6  7463 6820 
00006AFA  506F 696E 
00006AFE  74        
00006AFF  2043 6C65 11567          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00006B03  6172 6564 
00006B07  2E2E 2E2E 
00006B0B  2E        
00006B0C  0D0A 00   11568          dc.b      13,10,0
                    11569   @m68kde~2_80:
00006B10  0D0A 5761 11570          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00006B14  7463 6820 
00006B18  506F 696E 
00006B1C  74        
00006B1D  2057 6173 11571          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
00006B21  206E 6F74 
00006B25  2053 6574 
00006B29  2E        
00006B2A  2E2E 2E2E 11572          dc.b      46,46,46,46,0
00006B2E  00        
                    11573   @m68kde~2_81:
00006B30  0D0A 4E6F 11574          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
00006B34  2046 5245 
00006B38  4520 4272 
00006B3C  6561      
00006B3E  6B20 506F 11575          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
00006B42  696E 7473 
00006B46  2E2E 2E2E 
00006B4A  2E        
00006B4B  00        11576          dc.b      0
                    11577   @m68kde~2_82:
00006B4C  0D0A 4272 11578          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006B50  6561 6B20 
00006B54  506F 696E 
00006B58  74        
00006B59  2041 6464 11579          dc.b      32,65,100,100,114,101,115,115,58,32,0
00006B5D  7265 7373 
00006B61  3A20 00   
                    11580   @m68kde~2_83:
00006B64  0D0A 4572 11581          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00006B68  726F 7220 
00006B6C  3A20 4272 
00006B70  65        
00006B71  616B 2050 11582          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00006B75  6F69 6E74 
00006B79  7320 4341 
00006B7D  4E        
00006B7E  4E4F 5420 11583          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
00006B82  6265 2073 
00006B86  6574 2061 
00006B8A  74        
00006B8B  204F 4444 11584          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
00006B8F  2061 6464 
00006B93  7265 7373 
00006B97  65        
00006B98  7300      11585          dc.b      115,0
                    11586   @m68kde~2_84:
00006B9A  0D0A 4572 11587          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00006B9E  726F 7220 
00006BA2  3A20 4272 
00006BA6  65        
00006BA7  616B 2050 11588          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00006BAB  6F69 6E74 
00006BAF  7320 4341 
00006BB3  4E        
00006BB4  4E4F 5420 11589          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
00006BB8  6265 2073 
00006BBC  6574 2066 
00006BC0  6F        
00006BC1  7220 524F 11590          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
00006BC5  4D20 696E 
00006BC9  2052 616E 
00006BCD  67        
00006BCE  6520 3A20 11591          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
00006BD2  5B24 302D 
00006BD6  2430 3030 
00006BDA  3037 46   
00006BDD  4646 5D00 11592          dc.b      70,70,93,0
                    11593   @m68kde~2_85:
00006BE2  0D0A 4572 11594          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
00006BE6  726F 723A 
00006BEA  2042 7265 
00006BEE  61        
00006BEF  6B20 506F 11595          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
00006BF3  696E 7420 
00006BF7  416C 7265 
00006BFB  6164 7920 11596          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
00006BFF  4578 6973 
00006C03  7473 2061 
00006C07  74        
00006C08  2041 6464 11597          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
00006C0C  7265 7373 
00006C10  203A 2025 
00006C14  30        
00006C15  3878 0D0A 11598          dc.b      56,120,13,10,0
00006C19  00        
                    11599   @m68kde~2_86:
00006C1A  0D0A 4272 11600          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006C1E  6561 6B20 
00006C22  506F 696E 
00006C26  74        
00006C27  2053 6574 11601          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00006C2B  2061 7420 
00006C2F  4164 6472 
00006C33  65        
00006C34  7373 3A20 11602          dc.b      115,115,58,32,91,36,37,48,56,120,93,44,32,73
00006C38  5B24 2530 
00006C3C  3878 5D2C 
00006C40  2049      
00006C42  6E73 7472 11603          dc.b      110,115,116,114,117,99,116,105,111,110,32,61
00006C46  7563 7469 
00006C4A  6F6E 203D 
00006C4E  2025 7300 11604          dc.b      32,37,115,0
                    11605   @m68kde~2_87:
00006C52  0D0A 4E6F 11606          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
00006C56  2046 5245 
00006C5A  4520 5761 
00006C5E  7463      
00006C60  6820 506F 11607          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
00006C64  696E 7473 
00006C68  2E2E 2E2E 
00006C6C  2E        
00006C6D  00        11608          dc.b      0
                    11609   @m68kde~2_88:
00006C6E  0D0A 5761 11610          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00006C72  7463 6820 
00006C76  506F 696E 
00006C7A  74        
00006C7B  2041 6464 11611          dc.b      32,65,100,100,114,101,115,115,58,32,0
00006C7F  7265 7373 
00006C83  3A20 00   
                    11612   @m68kde~2_89:
00006C86  0D0A 4572 11613          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
00006C8A  726F 723A 
00006C8E  2057 6174 
00006C92  63        
00006C93  6820 506F 11614          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
00006C97  696E 7420 
00006C9B  416C 7265 
00006C9F  6164 7920 11615          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
00006CA3  5365 7420 
00006CA7  6174 2041 
00006CAB  64        
00006CAC  6472 6573 11616          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
00006CB0  7320 3A20 
00006CB4  2530 3878 
00006CB8  0D        
00006CB9  0A00      11617          dc.b      10,0
                    11618   @m68kde~2_90:
00006CBC  0D0A 5761 11619          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00006CC0  7463 6820 
00006CC4  506F 696E 
00006CC8  74        
00006CC9  2053 6574 11620          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00006CCD  2061 7420 
00006CD1  4164 6472 
00006CD5  65        
00006CD6  7373 3A20 11621          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00006CDA  5B24 2530 
00006CDE  3878 5D00 
                    11622   @m68kde~2_91:
00006CE2  0D0A 0D0A 11623          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
00006CE6  0D0A 0D0A 
00006CEA  4042 5245 
00006CEE  414B 50   
00006CF1  4F49 4E54 11624          dc.b      79,73,78,84,0
00006CF5  00        
                    11625   @m68kde~2_92:
00006CF6  0D0A 5369 11626          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00006CFA  6E67 6C65 
00006CFE  2053 7465 
00006D02  70        
00006D03  203A 205B 11627          dc.b      32,58,32,91,79,78,93,0
00006D07  4F4E 5D00 
                    11628   @m68kde~2_93:
00006D0C  0D0A 4272 11629          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
00006D10  6561 6B50 
00006D14  6F69 6E74 
00006D18  73        
00006D19  203A 205B 11630          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
00006D1D  456E 6162 
00006D21  6C65 645D 
00006D25  00        
                    11631   @m68kde~2_94:
00006D26  0D0A 5072 11632          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00006D2A  6573 7320 
00006D2E  3C45 5343 
00006D32  3E20      
00006D34  746F 2052 11633          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00006D38  6573 756D 
00006D3C  6520 5573 
00006D40  6572 2050 11634          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
00006D44  726F 6772 
00006D48  616D 0D0A 
00006D4C  00        
                    11635   @m68kde~2_95:
00006D4E  0D0A 556E 11636          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
00006D52  6B6E 6F77 
00006D56  6E20 436F 
00006D5A  6D        
00006D5B  6D61 6E64 11637          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
00006D5F  2E2E 2E2E 
00006D63  2E0D 0A00 
                    11638   @m68kde~2_96:
00006D68  0D0A 5072 11639          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
00006D6C  6F67 7261 
00006D70  6D20 456E 
00006D74  64        
00006D75  6564 2028 11640          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
00006D79  5452 4150 
00006D7D  2023 3135 
00006D81  292E      
00006D83  2E2E 2E00 11641          dc.b      46,46,46,0
                    11642   @m68kde~2_97:
00006D88  0D0A 4B69 11643          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
00006D8C  6C6C 2041 
00006D90  6C6C 2042 
00006D94  72        
00006D95  6561 6B20 11644          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
00006D99  506F 696E 
00006D9D  7473 2E2E 
00006DA1  2E        
00006DA2  2879 2F6E 11645          dc.b      40,121,47,110,41,63,0
00006DA6  293F 00   
                    11646   @m68kde~2_98:
00006DAA  0D0A 4B69 11647          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
00006DAE  6C6C 2041 
00006DB2  6C6C 2057 
00006DB6  61        
00006DB7  7463 6820 11648          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
00006DBB  506F 696E 
00006DBF  7473 2E2E 
00006DC3  2E        
00006DC4  2879 2F6E 11649          dc.b      40,121,47,110,41,63,0
00006DC8  293F 00   
                    11650   @m68kde~2_99:
00006DCC  0D0A 2D2D 11651          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
00006DD0  2D2D 2D2D 
00006DD4  2D2D 2D2D 
00006DD8  2D2D 2D   
00006DDB  2D2D 2D2D 11652          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00006DDF  2D2D 2D2D 
00006DE3  2D2D 2D2D 
00006DE7  2D2D 2D   
00006DEA  2D2D 2D2D 11653          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00006DEE  2D2D 2D2D 
00006DF2  2D2D 2D2D 
00006DF6  2D2D 2D   
00006DF9  2D2D 2D2D 11654          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00006DFD  2D2D 2D2D 
00006E01  2D2D 2D2D 
00006E05  2D2D 2D   
00006E08  2D2D 2D2D 11655          dc.b      45,45,45,45,45,45,0
00006E0C  2D2D 00   
                    11656   @m68kde~2_100:
00006E10  0D0A 2020 11657          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
00006E14  4465 6275 
00006E18  6767 6572 
00006E1C  20        
00006E1D  436F 6D6D 11658          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
00006E21  616E 6420 
00006E25  5375 6D6D 
00006E29  6172 7900 11659          dc.b      97,114,121,0
                    11660   @m68kde~2_101:
00006E2E  0D0A 2020 11661          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
00006E32  2E28 7265 
00006E36  6729 2020 
00006E3A  2020      
00006E3C  2020 202D 11662          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
00006E40  2043 6861 
00006E44  6E67 6520 
00006E48  5265      
00006E4A  6769 7374 11663          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
00006E4E  6572 733A 
00006E52  2065 2E67 
00006E56  2041 302D 11664          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
00006E5A  4137 2C44 
00006E5E  302D 4437 
00006E62  2C50 43   
00006E65  2C53 5350 11665          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
00006E69  2C55 5350 
00006E6D  2C53 5200 
                    11666   @m68kde~2_102:
00006E72  0D0A 2020 11667          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
00006E76  4244 2F42 
00006E7A  532F 4243 
00006E7E  2F42 4B   
00006E81  2020 2D20 11668          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
00006E85  4272 6561 
00006E89  6B20 506F 
00006E8D  69        
00006E8E  6E74 3A20 11669          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
00006E92  4469 7370 
00006E96  6C61 792F 
00006E9A  53        
00006E9B  6574 2F43 11670          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
00006E9F  6C65 6172 
00006EA3  2F4B 696C 
00006EA7  6C        
00006EA8  00        11671          dc.b      0
                    11672   @m68kde~2_103:
00006EAA  0D0A 2020 11673          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
00006EAE  4320 2020 
00006EB2  2020 2020 
00006EB6  2020 20   
00006EB9  2020 2D20 11674          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
00006EBD  436F 7079 
00006EC1  2050 726F 
00006EC5  67        
00006EC6  7261 6D20 11675          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
00006ECA  6672 6F6D 
00006ECE  2046 6C61 
00006ED2  73        
00006ED3  6820 746F 11676          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
00006ED7  204D 6169 
00006EDB  6E20 4D65 
00006EDF  6D        
00006EE0  6F72 7900 11677          dc.b      111,114,121,0
                    11678   @m68kde~2_104:
00006EE4  0D0A 2020 11679          dc.b      13,10,32,32,68,73,32,32,32,32,32,32,32,32,32
00006EE8  4449 2020 
00006EEC  2020 2020 
00006EF0  2020 20   
00006EF3  2020 2D20 11680          dc.b      32,32,45,32,68,105,115,97,115,115,101,109,98
00006EF7  4469 7361 
00006EFB  7373 656D 
00006EFF  62        
00006F00  6C65 2050 11681          dc.b      108,101,32,80,114,111,103,114,97,109,0
00006F04  726F 6772 
00006F08  616D 00   
                    11682   @m68kde~2_105:
00006F0C  0D0A 2020 11683          dc.b      13,10,32,32,68,85,32,32,32,32,32,32,32,32,32
00006F10  4455 2020 
00006F14  2020 2020 
00006F18  2020 20   
00006F1B  2020 2D20 11684          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
00006F1F  4475 6D70 
00006F23  204D 656D 
00006F27  6F        
00006F28  7279 2043 11685          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
00006F2C  6F6E 7465 
00006F30  6E74 7320 
00006F34  746F 2053 11686          dc.b      116,111,32,83,99,114,101,101,110,0
00006F38  6372 6565 
00006F3C  6E00      
                    11687   @m68kde~2_106:
00006F3E  0D0A 2020 11688          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
00006F42  4520 2020 
00006F46  2020 2020 
00006F4A  2020 20   
00006F4D  2020 2D20 11689          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
00006F51  456E 7465 
00006F55  7220 5374 
00006F59  72        
00006F5A  696E 6720 11690          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
00006F5E  696E 746F 
00006F62  204D 656D 
00006F66  6F72 7900 11691          dc.b      111,114,121,0
                    11692   @m68kde~2_107:
00006F6A  0D0A 2020 11693          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
00006F6E  4620 2020 
00006F72  2020 2020 
00006F76  2020 20   
00006F79  2020 2D20 11694          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
00006F7D  4669 6C6C 
00006F81  204D 656D 
00006F85  6F        
00006F86  7279 2077 11695          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
00006F8A  6974 6820 
00006F8E  4461 7461 
00006F92  00        
                    11696   @m68kde~2_108:
00006F94  0D0A 2020 11697          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
00006F98  4720 2020 
00006F9C  2020 2020 
00006FA0  2020 20   
00006FA3  2020 2D20 11698          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
00006FA7  476F 2050 
00006FAB  726F 6772 
00006FAF  61        
00006FB0  6D20 5374 11699          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
00006FB4  6172 7469 
00006FB8  6E67 2061 
00006FBC  74        
00006FBD  2041 6464 11700          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
00006FC1  7265 7373 
00006FC5  3A20 2425 
00006FC9  30        
00006FCA  3858 00   11701          dc.b      56,88,0
                    11702   @m68kde~2_109:
00006FCE  0D0A 2020 11703          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
00006FD2  4C20 2020 
00006FD6  2020 2020 
00006FDA  2020 20   
00006FDD  2020 2D20 11704          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
00006FE1  4C6F 6164 
00006FE5  2050 726F 
00006FE9  67        
00006FEA  7261 6D20 11705          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
00006FEE  282E 4845 
00006FF2  5820 6669 
00006FF6  6C        
00006FF7  6529 2066 11706          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
00006FFB  726F 6D20 
00006FFF  4C61 7074 
00007003  6F        
00007004  7000      11707          dc.b      112,0
                    11708   @m68kde~2_110:
00007006  0D0A 2020 11709          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
0000700A  4D20 2020 
0000700E  2020 2020 
00007012  2020 20   
00007015  2020 2D20 11710          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
00007019  4D65 6D6F 
0000701D  7279 2045 
00007021  78        
00007022  616D 696E 11711          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
00007026  6520 616E 
0000702A  6420 4368 
0000702E  61        
0000702F  6E67 6500 11712          dc.b      110,103,101,0
                    11713   @m68kde~2_111:
00007034  0D0A 2020 11714          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
00007038  5020 2020 
0000703C  2020 2020 
00007040  2020 20   
00007043  2020 2D20 11715          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
00007047  5072 6F67 
0000704B  7261 6D20 
0000704F  46        
00007050  6C61 7368 11716          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
00007054  204D 656D 
00007058  6F72 7920 
0000705C  7769 7468 11717          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00007060  2055 7365 
00007064  7220 5072 
00007068  6F67 7261 11718          dc.b      111,103,114,97,109,0
0000706C  6D00      
                    11719   @m68kde~2_112:
0000706E  0D0A 2020 11720          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00007072  5220 2020 
00007076  2020 2020 
0000707A  2020 20   
0000707D  2020 2D20 11721          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00007081  4469 7370 
00007085  6C61 7920 
00007089  36        
0000708A  3830 3030 11722          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
0000708E  2052 6567 
00007092  6973 7465 
00007096  72        
00007097  7300      11723          dc.b      115,0
                    11724   @m68kde~2_113:
0000709A  0D0A 2020 11725          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
0000709E  5320 2020 
000070A2  2020 2020 
000070A6  2020 20   
000070A9  2020 2D20 11726          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
000070AD  546F 6767 
000070B1  6C65 204F 
000070B5  4E        
000070B6  2F4F 4646 11727          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
000070BA  2053 696E 
000070BE  676C 6520 
000070C2  53        
000070C3  7465 7020 11728          dc.b      116,101,112,32,77,111,100,101,0
000070C7  4D6F 6465 
000070CB  00        
                    11729   @m68kde~2_114:
000070CC  0D0A 2020 11730          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
000070D0  544D 2020 
000070D4  2020 2020 
000070D8  2020 20   
000070DB  2020 2D20 11731          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
000070DF  5465 7374 
000070E3  204D 656D 
000070E7  6F        
000070E8  7279 00   11732          dc.b      114,121,0
                    11733   @m68kde~2_115:
000070EC  0D0A 2020 11734          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
000070F0  5453 2020 
000070F4  2020 2020 
000070F8  2020 20   
000070FB  2020 2D20 11735          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
000070FF  5465 7374 
00007103  2053 7769 
00007107  74        
00007108  6368 6573 11736          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
0000710C  3A20 5357 
00007110  372D 3000 
                    11737   @m68kde~2_116:
00007114  0D0A 2020 11738          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
00007118  5444 2020 
0000711C  2020 2020 
00007120  2020 20   
00007123  2020 2D20 11739          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
00007127  5465 7374 
0000712B  2044 6973 
0000712F  70        
00007130  6C61 7973 11740          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
00007134  3A20 4C45 
00007138  4473 2061 
0000713C  6E        
0000713D  6420 372D 11741          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00007141  5365 676D 
00007145  656E 7400 
                    11742   @m68kde~2_117:
0000714A  0D0A 2020 11743          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
0000714E  5744 2F57 
00007152  532F 5743 
00007156  2F57 4B   
00007159  2020 2D20 11744          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
0000715D  5761 7463 
00007161  6820 506F 
00007165  696E      
00007167  743A 2044 11745          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
0000716B  6973 706C 
0000716F  6179 2F53 
00007173  65        
00007174  742F 436C 11746          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
00007178  6561 722F 
0000717C  4B69 6C6C 
00007180  00        
                    11747   @m68kde~2_118:
00007182  0D0A 2300 11748          dc.b      13,10,35,0
                    11749   @m68kde~2_119:
00007186  0D0A 5072 11750          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
0000718A  6F67 7261 
0000718E  6D20 5275 
00007192  6E        
00007193  6E69 6E67 11751          dc.b      110,105,110,103,46,46,46,46,46,0
00007197  2E2E 2E2E 
0000719B  2E00      
                    11752   @m68kde~2_120:
0000719E  0D0A 5072 11753          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
000071A2  6573 7320 
000071A6  3C52 4553 
000071AA  4554      
000071AC  3E20 6275 11754          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
000071B0  7474 6F6E 
000071B4  203C 4B65 
000071B8  79        
000071B9  303E 206F 11755          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
000071BD  6E20 4445 
000071C1  3120 746F 
000071C5  2073      
000071C7  746F 7000 11756          dc.b      116,111,112,0
                    11757   @m68kde~2_121:
000071CC  0D0A 4572 11758          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
000071D0  726F 723A 
000071D4  2050 7265 
000071D8  73        
000071D9  7320 2747 11759          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
000071DD  2720 6669 
000071E1  7273 7420 
000071E5  74        
000071E6  6F20 7374 11760          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
000071EA  6172 7420 
000071EE  7072 6F67 
000071F2  7261 6D00 11761          dc.b      114,97,109,0
                    11762   @m68kde~2_122:
000071F6  0D0A 5369 11763          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000071FA  6E67 6C65 
000071FE  2053 7465 
00007202  70        
00007203  2020 3A5B 11764          dc.b      32,32,58,91,79,78,93,0
00007207  4F4E 5D00 
                    11765   @m68kde~2_123:
0000720C  0D0A 5072 11766          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00007210  6573 7320 
00007214  2747 2720 
00007218  74        
00007219  6F20 5472 11767          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
0000721D  6163 6520 
00007221  5072 6F67 
00007225  72        
00007226  616D 2066 11768          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
0000722A  726F 6D20 
0000722E  6164 6472 
00007232  6573 7320 11769          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
00007236  2425 582E 
0000723A  2E2E 2E2E 
0000723E  00        
                    11770   @m68kde~2_124:
00007240  0D0A 5075 11771          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
00007244  7368 203C 
00007248  5245 5345 
0000724C  5420      
0000724E  4275 7474 11772          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00007252  6F6E 3E20 
00007256  746F 2053 
0000725A  74        
0000725B  6F70 2E2E 11773          dc.b      111,112,46,46,46,46,46,0
0000725F  2E2E 2E00 
                    11774   @m68kde~2_125:
00007264  0D0A 5369 11775          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00007268  6E67 6C65 
0000726C  2053 7465 
00007270  70        
00007271  203A 205B 11776          dc.b      32,58,32,91,79,70,70,93,0
00007275  4F46 465D 
00007279  00        
                    11777   @m68kde~2_126:
0000727A  0D0A 4272 11778          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
0000727E  6561 6B20 
00007282  506F 696E 
00007286  74        
00007287  7320 3A5B 11779          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
0000728B  456E 6162 
0000728F  6C65 645D 
00007293  00        
                    11780   @m68kde~2_127:
00007294  0D0A 5072 11781          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00007298  6573 7320 
0000729C  3C45 5343 
000072A0  3E20      
000072A2  746F 2052 11782          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
000072A6  6573 756D 
000072AA  6520 5573 
000072AE  6572 2050 11783          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
000072B2  726F 6772 
000072B6  616D 2E2E 
000072BA  2E        
000072BB  2E2E 00   11784          dc.b      46,46,0
                    11785   @m68kde~2_128:
000072BE  0D0A 5369 11786          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000072C2  6E67 6C65 
000072C6  2053 7465 
000072CA  70        
000072CB  2020 3A5B 11787          dc.b      32,32,58,91,79,70,70,93,0
000072CF  4F46 465D 
000072D3  00        
                    11788   @m68kde~2_129:
000072D4  0D0A 0D0A 11789          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
000072D8  5072 6F67 
000072DC  7261 6D20 
000072E0  41        
000072E1  424F 5254 11790          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
000072E5  2021 2121 
000072E9  2121 210D 
000072ED  0A00      
                    11791   @m68kde~2_130:
000072F0  2573 0D0A 11792          dc.b      37,115,13,10,0
000072F4  00        
                    11793   @m68kde~2_131:
000072F6  0D0A 0D0A 11794          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
000072FA  5072 6F67 
000072FE  7261 6D20 
00007302  41        
00007303  424F 5254 11795          dc.b      66,79,82,84,32,33,33,33,33,33,0
00007307  2021 2121 
0000730B  2121 00   
                    11796   @m68kde~2_132:
0000730E  0D0A 556E 11797          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
00007312  6861 6E64 
00007316  6C65 6420 
0000731A  49        
0000731B  6E74 6572 11798          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
0000731F  7275 7074 
00007323  3A20 4952 
00007327  5125 6420 11799          dc.b      81,37,100,32,33,33,33,33,33,0
0000732B  2121 2121 
0000732F  2100      
                    11800   @m68kde~2_133:
00007332  4144 4452 11801          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
00007336  4553 5320 
0000733A  4552 524F 
0000733E  523A 20   
00007341  3136 206F 11802          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
00007345  7220 3332 
00007349  2042 6974 
0000734D  2054      
0000734F  7261 6E73 11803          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00007353  6665 7220 
00007357  746F 2F66 
0000735B  726F 6D20 11804          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
0000735F  616E 204F 
00007363  4444 2041 
00007367  64        
00007368  6472 6573 11805          dc.b      100,114,101,115,115,46,46,46,46,0
0000736C  732E 2E2E 
00007370  2E00      
                    11806   @m68kde~2_134:
00007372  556E 6861 11807          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
00007376  6E64 6C65 
0000737A  6420 5472 
0000737E  6170 2021 11808          dc.b      97,112,32,33,33,33,33,33,0
00007382  2121 2121 
00007386  00        
                    11809   @m68kde~2_135:
00007388  4255 5320 11810          dc.b      66,85,83,32,69,114,114,111,114,33,0
0000738C  4572 726F 
00007390  7221 00   
                    11811   @m68kde~2_136:
00007394  4144 4452 11812          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
00007398  4553 5320 
0000739C  4572 726F 
000073A0  7221      
000073A2  00        11813          dc.b      0
                    11814   @m68kde~2_137:
000073A4  494C 4C45 11815          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
000073A8  4741 4C20 
000073AC  494E 5354 
000073B0  5255 43   
000073B3  5449 4F4E 11816          dc.b      84,73,79,78,0
000073B7  00        
                    11817   @m68kde~2_138:
000073B8  4449 5649 11818          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
000073BC  4445 2042 
000073C0  5920 5A45 
000073C4  524F 00   
                    11819   @m68kde~2_139:
000073C8  2743 484B 11820          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
000073CC  2720 494E 
000073D0  5354 5255 
000073D4  4354 49   
000073D7  4F4E 00   11821          dc.b      79,78,0
                    11822   @m68kde~2_140:
000073DA  5452 4150 11823          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
000073DE  5620 494E 
000073E2  5354 5255 
000073E6  4354 49   
000073E9  4F4E 00   11824          dc.b      79,78,0
                    11825   @m68kde~2_141:
000073EC  5052 4956 11826          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
000073F0  494C 4547 
000073F4  4520 5649 
000073F8  4F4C 41   
000073FB  5449 4F4E 11827          dc.b      84,73,79,78,0
000073FF  00        
                    11828   @m68kde~2_142:
00007400  554E 494E 11829          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
00007404  4954 4941 
00007408  4C49 5345 
0000740C  4420 49   
0000740F  5251 00   11830          dc.b      82,81,0
                    11831   @m68kde~2_143:
00007412  5350 5552 11832          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
00007416  494F 5553 
0000741A  2049 5251 
0000741E  00        
                    11833   @m68kde~2_144:
00007420  0D0A 5374 11834          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
00007424  6172 7420 
00007428  4164 6472 
0000742C  65        
0000742D  7373 2069 11835          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00007431  6E20 4D65 
00007435  6D6F 7279 
00007439  3A20 00   11836          dc.b      58,32,0
                    11837   @m68kde~2_145:
0000743C  0D0A 456E 11838          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00007440  7465 7220 
00007444  5374 7269 
00007448  6E        
00007449  6720 2845 11839          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
0000744D  5343 2074 
00007451  6F20 656E 
00007455  64        
00007456  2920 3A00 11840          dc.b      41,32,58,0
                    11841   @m68kde~2_146:
0000745A  0D0A 5374 11842          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
0000745E  6172 7420 
00007462  4164 6472 
00007466  65        
00007467  7373 00   11843          dc.b      115,115,0
                    11844   @m68kde~2_147:
0000746A  0D0A 456E 11845          dc.b      13,10,69,110,100,32,65,100,100,114,101,115,115
0000746E  6420 4164 
00007472  6472 6573 
00007476  73        
00007477  00        11846          dc.b      0
                    11847   @m68kde~2_148:
00007478  0D0A 5465 11848          dc.b      13,10,84,101,115,116,32,112,97,116,116,101,114
0000747C  7374 2070 
00007480  6174 7465 
00007484  72        
00007485  6E3A 200D 11849          dc.b      110,58,32,13,10,48,58,32,53,53,13,10,49,58,32
00007489  0A30 3A20 
0000748D  3535 0D0A 
00007491  313A 20   
00007494  4141 0D0A 11850          dc.b      65,65,13,10,50,58,32,70,70,13,10,51,58,32,48
00007498  323A 2046 
0000749C  460D 0A33 
000074A0  3A20 30   
000074A3  3000      11851          dc.b      48,0
                    11852   @m68kde~2_149:
000074A6  0D0A 4461 11853          dc.b      13,10,68,97,116,97,32,115,101,108,101,99,116
000074AA  7461 2073 
000074AE  656C 6563 
000074B2  74        
000074B3  6564 3A20 11854          dc.b      101,100,58,32,48,120,37,120,0
000074B7  3078 2578 
000074BB  00        
                    11855   @m68kde~2_150:
000074BC  0D0A 456E 11856          dc.b      13,10,69,110,116,101,114,32,39,66,39,44,32,39
000074C0  7465 7220 
000074C4  2742 272C 
000074C8  2027      
000074CA  5727 2C20 11857          dc.b      87,39,44,32,111,114,32,39,76,39,32,102,111,114
000074CE  6F72 2027 
000074D2  4C27 2066 
000074D6  6F72      
000074D8  2062 7974 11858          dc.b      32,98,121,116,101,115,44,32,119,111,114,100
000074DC  6573 2C20 
000074E0  776F 7264 
000074E4  732C 206F 11859          dc.b      115,44,32,111,114,32,108,111,110,103,32,119
000074E8  7220 6C6F 
000074EC  6E67 2077 
000074F0  6F72 643A 11860          dc.b      111,114,100,58,32,0
000074F4  2000      
                    11861   @m68kde~2_151:
000074F6  0D0A 6277 11862          dc.b      13,10,98,119,108,32,115,101,108,101,99,116,101
000074FA  6C20 7365 
000074FE  6C65 6374 
00007502  65        
00007503  643A 00   11863          dc.b      100,58,0
                    11864   @m68kde~2_152:
00007506  4C6F 6E67 11865          dc.b      76,111,110,103,32,119,111,114,100,0
0000750A  2077 6F72 
0000750E  6400      
                    11866   @m68kde~2_153:
00007510  576F 7264 11867          dc.b      87,111,114,100,0
00007514  00        
                    11868   @m68kde~2_154:
00007516  4279 7465 11869          dc.b      66,121,116,101,115,0
0000751A  7300      
                    11870   @m68kde~2_155:
0000751C  0D0A 5772 11871          dc.b      13,10,87,114,105,116,101,32,99,111,109,112,108
00007520  6974 6520 
00007524  636F 6D70 
00007528  6C        
00007529  6574 652E 11872          dc.b      101,116,101,46,32,83,116,97,114,116,105,110
0000752D  2053 7461 
00007531  7274 696E 
00007535  6720 7265 11873          dc.b      103,32,114,101,97,100,46,0
00007539  6164 2E00 
                    11874   @m68kde~2_156:
0000753E  0D0A 5772 11875          dc.b      13,10,87,114,105,116,101,58,32,48,120,37,120
00007542  6974 653A 
00007546  2030 7825 
0000754A  78        
0000754B  2074 6F20 11876          dc.b      32,116,111,32,97,100,100,114,32,48,120,37,120
0000754F  6164 6472 
00007553  2030 7825 
00007557  78        
00007558  00        11877          dc.b      0
                    11878   @m68kde~2_157:
0000755A  0D0A 5265 11879          dc.b      13,10,82,101,97,100,32,99,111,109,112,108,101
0000755E  6164 2063 
00007562  6F6D 706C 
00007566  65        
00007567  7465 2E00 11880          dc.b      116,101,46,0
                    11881   @m68kde~2_158:
0000756C  0D0A 4E6F 11882          dc.b      13,10,78,111,32,101,114,114,111,114,32,105,110
00007570  2065 7272 
00007574  6F72 2069 
00007578  6E        
00007579  206D 656D 11883          dc.b      32,109,101,109,32,116,101,115,116,0
0000757D  2074 6573 
00007581  7400      
                    11884   @m68kde~2_159:
00007584  0D0A 4552 11885          dc.b      13,10,69,82,82,79,82,58,32,65,100,100,114,101
00007588  524F 523A 
0000758C  2041 6464 
00007590  7265      
00007592  7373 2030 11886          dc.b      115,115,32,48,120,37,120,32,100,97,116,97,32
00007596  7825 7820 
0000759A  6461 7461 
0000759E  20        
0000759F  6973 2030 11887          dc.b      105,115,32,48,120,37,120,32,98,117,116,32,115
000075A3  7825 7820 
000075A7  6275 7420 
000075AB  73        
000075AC  686F 756C 11888          dc.b      104,111,117,108,100,32,98,101,32,48,120,37,120
000075B0  6420 6265 
000075B4  2030 7825 
000075B8  78        
000075B9  00        11889          dc.b      0
                    11890   @m68kde~2_160:
000075BA  0D0A 4641 11891          dc.b      13,10,70,65,73,76,58,32,77,101,109,32,116,101
000075BE  494C 3A20 
000075C2  4D65 6D20 
000075C6  7465      
000075C8  7374 2064 11892          dc.b      115,116,32,100,105,100,32,110,111,116,32,99
000075CC  6964 206E 
000075D0  6F74 2063 
000075D4  6F6D 706C 11893          dc.b      111,109,112,108,101,116,101,32,115,117,99,99
000075D8  6574 6520 
000075DC  7375 6363 
000075E0  6573 7366 11894          dc.b      101,115,115,102,117,108,108,121,46,0
000075E4  756C 6C79 
000075E8  2E00      
                    11895   @m68kde~2_161:
000075EA  0D0A 5265 11896          dc.b      13,10,82,101,97,100,58,32,65,100,100,114,101
000075EE  6164 3A20 
000075F2  4164 6472 
000075F6  65        
000075F7  7373 2030 11897          dc.b      115,115,32,48,120,37,120,32,100,97,116,97,32
000075FB  7825 7820 
000075FF  6461 7461 
00007603  20        
00007604  6973 2030 11898          dc.b      105,115,32,48,120,37,120,0
00007608  7825 7800 
                    11899   @m68kde~2_162:
0000760C  4C61 6233 11900          dc.b      76,97,98,51,0
00007610  00        
                    11901   @m68kde~2_163:
00007612  4161 7261 11902          dc.b      65,97,114,97,110,32,80,111,111,110,32,51,54
00007616  6E20 506F 
0000761A  6F6E 2033 
0000761E  36        
0000761F  3232 3832 11903          dc.b      50,50,56,50,48,51,10,80,97,114,115,97,32,75
00007623  3033 0A50 
00007627  6172 7361 
0000762B  204B      
0000762D  6573 686D 11904          dc.b      101,115,104,109,105,114,105,32,51,53,55,50,55
00007631  6972 6920 
00007635  3335 3732 
00007639  37        
0000763A  3337 3900 11905          dc.b      51,55,57,0
                    11906   @m68kde~2_164:
0000763E  0D0A 5275 11907          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
00007642  6E6E 696E 
00007646  672E 2E2E 
0000764A  2E        
0000764B  2E00      11908          dc.b      46,0
                    11909   @m68kde~2_165:
0000764E  5275 6E6E 11910          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
00007652  696E 672E 
00007656  2E2E 2E2E 
0000765A  00        
                    11911   @m68kde~2_166:
0000765C  4279 3A20 11912          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
00007660  504A 2044 
00007664  6176 6965 
00007668  73        
00007669  00        11913          dc.b      0
                    11914   @m68kde~2_167:
0000766A  0D0A 2573 11915          dc.b      13,10,37,115,0
0000766E  00        
                    11916   @m68kde~2_168:
00007670  2E42 2000 11917          dc.b      46,66,32,0
                    11918   @m68kde~2_169:
00007674  2E57 2000 11919          dc.b      46,87,32,0
                    11920   @m68kde~2_170:
00007678  2E4C 2000 11921          dc.b      46,76,32,0
                    11922   @m68kde~2_171:
0000767C  2324 2558 11923          dc.b      35,36,37,88,0
00007680  00        
                    11924   @m68kde~2_172:
00007682  2800      11925          dc.b      40,0
                    11926   @m68kde~2_173:
00007684  2900      11927          dc.b      41,0
                    11928   @m68kde~2_174:
00007686  292B 00   11929          dc.b      41,43,0
                    11930   @m68kde~2_175:
0000768A  2D28 00   11931          dc.b      45,40,0
                    11932   @m68kde~2_176:
0000768E  2564 2841 11933          dc.b      37,100,40,65,37,100,41,0
00007692  2564 2900 
                    11934   @m68kde~2_177:
00007696  2564 2841 11935          dc.b      37,100,40,65,37,100,44,0
0000769A  2564 2C00 
                    11936   @m68kde~2_178:
0000769E  4400      11937          dc.b      68,0
                    11938   @m68kde~2_179:
000076A0  4100      11939          dc.b      65,0
                    11940   @m68kde~2_180:
000076A2  2564 00   11941          dc.b      37,100,0
                    11942   @m68kde~2_181:
000076A6  2E57 2900 11943          dc.b      46,87,41,0
                    11944   @m68kde~2_182:
000076AA  2E4C 2900 11945          dc.b      46,76,41,0
                    11946   @m68kde~2_183:
000076AE  2425 5800 11947          dc.b      36,37,88,0
                    11948   @m68kde~2_184:
000076B2  2564 2850 11949          dc.b      37,100,40,80,67,41,0
000076B6  4329 00   
                    11950   @m68kde~2_185:
000076BA  2564 2850 11951          dc.b      37,100,40,80,67,44,0
000076BE  432C 00   
                    11952   @m68kde~2_186:
000076C2  2C00      11953          dc.b      44,0
                    11954   @m68kde~2_187:
000076C4  4343 00   11955          dc.b      67,67,0
                    11956   @m68kde~2_188:
000076C8  4353 00   11957          dc.b      67,83,0
                    11958   @m68kde~2_189:
000076CC  4551 00   11959          dc.b      69,81,0
                    11960   @m68kde~2_190:
000076D0  4745 00   11961          dc.b      71,69,0
                    11962   @m68kde~2_191:
000076D4  4754 00   11963          dc.b      71,84,0
                    11964   @m68kde~2_192:
000076D8  4849 00   11965          dc.b      72,73,0
                    11966   @m68kde~2_193:
000076DC  4C45 00   11967          dc.b      76,69,0
                    11968   @m68kde~2_194:
000076E0  4C53 00   11969          dc.b      76,83,0
                    11970   @m68kde~2_195:
000076E4  4C54 00   11971          dc.b      76,84,0
                    11972   @m68kde~2_196:
000076E8  4D49 00   11973          dc.b      77,73,0
                    11974   @m68kde~2_197:
000076EC  4E45 00   11975          dc.b      78,69,0
                    11976   @m68kde~2_198:
000076F0  504C 00   11977          dc.b      80,76,0
                    11978   @m68kde~2_199:
000076F4  5653 00   11979          dc.b      86,83,0
                    11980   @m68kde~2_200:
000076F8  5643 00   11981          dc.b      86,67,0
                    11982   @m68kde~2_201:
000076FC  5241 00   11983          dc.b      82,65,0
                    11984   @m68kde~2_202:
00007700  5352 00   11985          dc.b      83,82,0
                    11986   @m68kde~2_203:
00007704  556E 6B6E 11987          dc.b      85,110,107,110,111,119,110,0
00007708  6F77 6E00 
                    11988   @m68kde~2_204:
0000770C  4142 4344 11989          dc.b      65,66,67,68,32,68,37,100,44,68,37,100,0
00007710  2044 2564 
00007714  2C44 2564 
00007718  00        
                    11990   @m68kde~2_205:
0000771A  4142 4344 11991          dc.b      65,66,67,68,32,45,40,65,37,100,41,44,45,40,65
0000771E  202D 2841 
00007722  2564 292C 
00007726  2D28 41   
00007729  2564 2900 11992          dc.b      37,100,41,0
                    11993   @m68kde~2_206:
0000772E  4144 4441 11994          dc.b      65,68,68,65,46,87,32,0
00007732  2E57 2000 
                    11995   @m68kde~2_207:
00007736  4144 4441 11996          dc.b      65,68,68,65,46,76,32,0
0000773A  2E4C 2000 
                    11997   @m68kde~2_208:
0000773E  2C41 2558 11998          dc.b      44,65,37,88,0
00007742  00        
                    11999   @m68kde~2_209:
00007744  4144 4400 12000          dc.b      65,68,68,0
                    12001   @m68kde~2_210:
00007748  4144 4449 12002          dc.b      65,68,68,73,0
0000774C  00        
                    12003   @m68kde~2_211:
0000774E  414E 4449 12004          dc.b      65,78,68,73,0
00007752  00        
                    12005   @m68kde~2_212:
00007754  434D 5049 12006          dc.b      67,77,80,73,0
00007758  00        
                    12007   @m68kde~2_213:
0000775A  454F 5249 12008          dc.b      69,79,82,73,0
0000775E  00        
                    12009   @m68kde~2_214:
00007760  4F52 4900 12010          dc.b      79,82,73,0
                    12011   @m68kde~2_215:
00007764  5355 4249 12012          dc.b      83,85,66,73,0
00007768  00        
                    12013   @m68kde~2_216:
0000776A  414E 4449 12014          dc.b      65,78,68,73,32,35,36,37,88,44,83,82,0
0000776E  2023 2425 
00007772  582C 5352 
00007776  00        
                    12015   @m68kde~2_217:
00007778  4144 4451 12016          dc.b      65,68,68,81,0
0000777C  00        
                    12017   @m68kde~2_218:
0000777E  2325 3158 12018          dc.b      35,37,49,88,44,0
00007782  2C00      
                    12019   @m68kde~2_219:
00007784  4144 4458 12020          dc.b      65,68,68,88,0
00007788  00        
                    12021   @m68kde~2_220:
0000778A  4425 582C 12022          dc.b      68,37,88,44,68,37,88,0
0000778E  4425 5800 
                    12023   @m68kde~2_221:
00007792  2D28 4125 12024          dc.b      45,40,65,37,88,41,44,45,40,65,37,88,41,0
00007796  5829 2C2D 
0000779A  2841 2558 
0000779E  2900      
                    12025   @m68kde~2_222:
000077A0  414E 4400 12026          dc.b      65,78,68,0
                    12027   @m68kde~2_223:
000077A4  414E 4449 12028          dc.b      65,78,68,73,32,35,36,37,50,88,44,67,67,82,0
000077A8  2023 2425 
000077AC  3258 2C43 
000077B0  4352 00   
                    12029   @m68kde~2_224:
000077B4  4153 4C00 12030          dc.b      65,83,76,0
                    12031   @m68kde~2_225:
000077B8  4153 5200 12032          dc.b      65,83,82,0
                    12033   @m68kde~2_226:
000077BC  4C53 4C00 12034          dc.b      76,83,76,0
                    12035   @m68kde~2_227:
000077C0  4C53 5200 12036          dc.b      76,83,82,0
                    12037   @m68kde~2_228:
000077C4  524F 4C00 12038          dc.b      82,79,76,0
                    12039   @m68kde~2_229:
000077C8  524F 5200 12040          dc.b      82,79,82,0
                    12041   @m68kde~2_230:
000077CC  524F 584C 12042          dc.b      82,79,88,76,0
000077D0  00        
                    12043   @m68kde~2_231:
000077D2  524F 5852 12044          dc.b      82,79,88,82,0
000077D6  00        
                    12045   @m68kde~2_232:
000077D8  2324 2558 12046          dc.b      35,36,37,88,44,68,37,88,0
000077DC  2C44 2558 
000077E0  00        
                    12047   @m68kde~2_233:
000077E2  4200      12048          dc.b      66,0
                    12049   @m68kde~2_234:
000077E4  4243 4847 12050          dc.b      66,67,72,71,32,0
000077E8  2000      
                    12051   @m68kde~2_235:
000077EA  4425 642C 12052          dc.b      68,37,100,44,0
000077EE  00        
                    12053   @m68kde~2_236:
000077F0  2324 2558 12054          dc.b      35,36,37,88,44,0
000077F4  2C00      
                    12055   @m68kde~2_237:
000077F6  4243 4C52 12056          dc.b      66,67,76,82,32,0
000077FA  2000      
                    12057   @m68kde~2_238:
000077FC  4253 4554 12058          dc.b      66,83,69,84,32,0
00007800  2000      
                    12059   @m68kde~2_239:
00007802  4254 5354 12060          dc.b      66,84,83,84,32,0
00007806  2000      
                    12061   @m68kde~2_240:
00007808  4348 4B20 12062          dc.b      67,72,75,32,0
0000780C  00        
                    12063   @m68kde~2_241:
0000780E  2C44 2564 12064          dc.b      44,68,37,100,0
00007812  00        
                    12065   @m68kde~2_242:
00007814  434C 5200 12066          dc.b      67,76,82,0
                    12067   @m68kde~2_243:
00007818  434D 5041 12068          dc.b      67,77,80,65,46,87,32,0
0000781C  2E57 2000 
                    12069   @m68kde~2_244:
00007820  434D 5041 12070          dc.b      67,77,80,65,46,76,32,0
00007824  2E4C 2000 
                    12071   @m68kde~2_245:
00007828  2C41 2564 12072          dc.b      44,65,37,100,0
0000782C  00        
                    12073   @m68kde~2_246:
0000782E  434D 5000 12074          dc.b      67,77,80,0
                    12075   @m68kde~2_247:
00007832  434D 504D 12076          dc.b      67,77,80,77,0
00007836  00        
                    12077   @m68kde~2_248:
00007838  2841 2564 12078          dc.b      40,65,37,100,41,43,44,40,65,37,100,41,43,0
0000783C  292B 2C28 
00007840  4125 6429 
00007844  2B00      
                    12079   @m68kde~2_249:
00007846  4442 00   12080          dc.b      68,66,0
                    12081   @m68kde~2_250:
0000784A  4425 642C 12082          dc.b      68,37,100,44,37,43,100,40,80,67,41,32,116,111
0000784E  252B 6428 
00007852  5043 2920 
00007856  746F      
00007858  2041 6464 12083          dc.b      32,65,100,100,114,58,36,37,88,0
0000785C  723A 2425 
00007860  5800      
                    12084   @m68kde~2_251:
00007862  4449 5653 12085          dc.b      68,73,86,83,32,0
00007866  2000      
                    12086   @m68kde~2_252:
00007868  4449 5655 12087          dc.b      68,73,86,85,32,0
0000786C  2000      
                    12088   @m68kde~2_253:
0000786E  454F 5200 12089          dc.b      69,79,82,0
                    12090   @m68kde~2_254:
00007872  454F 5249 12091          dc.b      69,79,82,73,32,35,36,37,50,88,44,67,67,82,0
00007876  2023 2425 
0000787A  3258 2C43 
0000787E  4352 00   
                    12092   @m68kde~2_255:
00007882  454F 5249 12093          dc.b      69,79,82,73,32,35,36,37,88,44,83,82,0
00007886  2023 2425 
0000788A  582C 5352 
0000788E  00        
                    12094   @m68kde~2_256:
00007890  4558 4720 12095          dc.b      69,88,71,32,68,37,100,44,68,37,100,0
00007894  4425 642C 
00007898  4425 6400 
                    12096   @m68kde~2_257:
0000789C  4558 4720 12097          dc.b      69,88,71,32,65,37,100,44,65,37,100,0
000078A0  4125 642C 
000078A4  4125 6400 
                    12098   @m68kde~2_258:
000078A8  4558 4720 12099          dc.b      69,88,71,32,68,37,100,44,65,37,100,0
000078AC  4425 642C 
000078B0  4125 6400 
                    12100   @m68kde~2_259:
000078B4  4558 5400 12101          dc.b      69,88,84,0
                    12102   @m68kde~2_260:
000078B8  494C 4C45 12103          dc.b      73,76,76,69,71,65,76,32,40,36,52,65,70,67,41
000078BC  4741 4C20 
000078C0  2824 3441 
000078C4  4643 29   
000078C7  00        12104          dc.b      0
                    12105   @m68kde~2_261:
000078C8  4A4D 5020 12106          dc.b      74,77,80,32,0
000078CC  00        
                    12107   @m68kde~2_262:
000078CE  4A53 5220 12108          dc.b      74,83,82,32,0
000078D2  00        
                    12109   @m68kde~2_263:
000078D4  4C45 4120 12110          dc.b      76,69,65,32,0
000078D8  00        
                    12111   @m68kde~2_264:
000078DA  4C49 4E4B 12112          dc.b      76,73,78,75,32,0
000078DE  2000      
                    12113   @m68kde~2_265:
000078E0  4125 642C 12114          dc.b      65,37,100,44,35,37,100,0
000078E4  2325 6400 
                    12115   @m68kde~2_266:
000078E8  4D4F 5645 12116          dc.b      77,79,86,69,46,66,32,0
000078EC  2E42 2000 
                    12117   @m68kde~2_267:
000078F0  4D4F 5645 12118          dc.b      77,79,86,69,46,76,32,0
000078F4  2E4C 2000 
                    12119   @m68kde~2_268:
000078F8  4D4F 5645 12120          dc.b      77,79,86,69,46,87,32,0
000078FC  2E57 2000 
                    12121   @m68kde~2_269:
00007900  4D4F 5645 12122          dc.b      77,79,86,69,32,0
00007904  2000      
                    12123   @m68kde~2_270:
00007906  2C43 4352 12124          dc.b      44,67,67,82,0
0000790A  00        
                    12125   @m68kde~2_271:
0000790C  4D4F 5645 12126          dc.b      77,79,86,69,32,83,82,44,0
00007910  2053 522C 
00007914  00        
                    12127   @m68kde~2_272:
00007916  2C53 5200 12128          dc.b      44,83,82,0
                    12129   @m68kde~2_273:
0000791A  4D4F 5645 12130          dc.b      77,79,86,69,32,85,83,80,44,65,37,100,0
0000791E  2055 5350 
00007922  2C41 2564 
00007926  00        
                    12131   @m68kde~2_274:
00007928  4D4F 5645 12132          dc.b      77,79,86,69,32,65,37,100,44,85,83,80,0
0000792C  2041 2564 
00007930  2C55 5350 
00007934  00        
                    12133   @m68kde~2_275:
00007936  4D4F 5645 12134          dc.b      77,79,86,69,77,0
0000793A  4D00      
                    12135   @m68kde~2_276:
0000793C  4425 6400 12136          dc.b      68,37,100,0
                    12137   @m68kde~2_277:
00007940  2F44 2564 12138          dc.b      47,68,37,100,0
00007944  00        
                    12139   @m68kde~2_278:
00007946  4125 6400 12140          dc.b      65,37,100,0
                    12141   @m68kde~2_279:
0000794A  2F41 2564 12142          dc.b      47,65,37,100,0
0000794E  00        
                    12143   @m68kde~2_280:
00007950  4D4F 5645 12144          dc.b      77,79,86,69,80,46,87,32,36,37,88,40,65,37,100
00007954  502E 5720 
00007958  2425 5828 
0000795C  4125 64   
0000795F  292C 4425 12145          dc.b      41,44,68,37,100,0
00007963  6400      
                    12146   @m68kde~2_281:
00007966  4D4F 5645 12147          dc.b      77,79,86,69,80,46,76,32,36,37,88,40,65,37,100
0000796A  502E 4C20 
0000796E  2425 5828 
00007972  4125 64   
00007975  292C 4425 12148          dc.b      41,44,68,37,100,0
00007979  6400      
                    12149   @m68kde~2_282:
0000797C  4D4F 5645 12150          dc.b      77,79,86,69,80,46,87,32,68,37,100,44,36,37,88
00007980  502E 5720 
00007984  4425 642C 
00007988  2425 58   
0000798B  2841 2564 12151          dc.b      40,65,37,100,41,0
0000798F  2900      
                    12152   @m68kde~2_283:
00007992  4D4F 5645 12153          dc.b      77,79,86,69,80,46,76,32,68,37,100,44,36,37,88
00007996  502E 4C20 
0000799A  4425 642C 
0000799E  2425 58   
000079A1  2841 2564 12154          dc.b      40,65,37,100,41,0
000079A5  2900      
                    12155   @m68kde~2_284:
000079A8  4D4F 5645 12156          dc.b      77,79,86,69,81,32,35,36,37,88,44,68,37,100,0
000079AC  5120 2324 
000079B0  2558 2C44 
000079B4  2564 00   
                    12157   @m68kde~2_285:
000079B8  4D55 4C53 12158          dc.b      77,85,76,83,32,0
000079BC  2000      
                    12159   @m68kde~2_286:
000079BE  4D55 4C55 12160          dc.b      77,85,76,85,32,0
000079C2  2000      
                    12161   @m68kde~2_287:
000079C4  4E42 4344 12162          dc.b      78,66,67,68,32,0
000079C8  2000      
                    12163   @m68kde~2_288:
000079CA  4E45 4700 12164          dc.b      78,69,71,0
                    12165   @m68kde~2_289:
000079CE  4E45 4758 12166          dc.b      78,69,71,88,0
000079D2  00        
                    12167   @m68kde~2_290:
000079D4  4E4F 5000 12168          dc.b      78,79,80,0
                    12169   @m68kde~2_291:
000079D8  4E4F 5400 12170          dc.b      78,79,84,0
                    12171   @m68kde~2_292:
000079DC  4F52 00   12172          dc.b      79,82,0
                    12173   @m68kde~2_293:
000079E0  4F52 4920 12174          dc.b      79,82,73,32,35,36,37,50,88,44,67,67,82,0
000079E4  2324 2532 
000079E8  582C 4343 
000079EC  5200      
                    12175   @m68kde~2_294:
000079EE  4F52 4920 12176          dc.b      79,82,73,32,32,35,36,37,88,44,83,82,0
000079F2  2023 2425 
000079F6  582C 5352 
000079FA  00        
                    12177   @m68kde~2_295:
000079FC  5045 4120 12178          dc.b      80,69,65,32,0
00007A00  00        
                    12179   @m68kde~2_296:
00007A02  5245 5345 12180          dc.b      82,69,83,69,84,0
00007A06  5400      
                    12181   @m68kde~2_297:
00007A08  5254 4500 12182          dc.b      82,84,69,0
                    12183   @m68kde~2_298:
00007A0C  5254 5200 12184          dc.b      82,84,82,0
                    12185   @m68kde~2_299:
00007A10  5254 5300 12186          dc.b      82,84,83,0
                    12187   @m68kde~2_300:
00007A14  5354 4F50 12188          dc.b      83,84,79,80,32,35,36,37,88,0
00007A18  2023 2425 
00007A1C  5800      
                    12189   @m68kde~2_301:
00007A1E  5342 4344 12190          dc.b      83,66,67,68,32,68,37,100,44,68,37,100,0
00007A22  2044 2564 
00007A26  2C44 2564 
00007A2A  00        
                    12191   @m68kde~2_302:
00007A2C  5342 4344 12192          dc.b      83,66,67,68,32,45,40,65,37,100,41,44,45,40,65
00007A30  202D 2841 
00007A34  2564 292C 
00007A38  2D28 41   
00007A3B  2564 2900 12193          dc.b      37,100,41,0
                    12194   @m68kde~2_303:
00007A40  5300      12195          dc.b      83,0
                    12196   @m68kde~2_304:
00007A42  5355 4241 12197          dc.b      83,85,66,65,46,87,32,0
00007A46  2E57 2000 
                    12198   @m68kde~2_305:
00007A4A  5355 4241 12199          dc.b      83,85,66,65,46,76,32,0
00007A4E  2E4C 2000 
                    12200   @m68kde~2_306:
00007A52  5355 4200 12201          dc.b      83,85,66,0
                    12202   @m68kde~2_307:
00007A56  5355 4251 12203          dc.b      83,85,66,81,0
00007A5A  00        
                    12204   @m68kde~2_308:
00007A5C  5355 4258 12205          dc.b      83,85,66,88,0
00007A60  00        
                    12206   @m68kde~2_309:
00007A62  4425 3158 12207          dc.b      68,37,49,88,44,68,37,49,88,0
00007A66  2C44 2531 
00007A6A  5800      
                    12208   @m68kde~2_310:
00007A6C  2D28 4125 12209          dc.b      45,40,65,37,49,88,41,44,45,40,65,37,49,88,41
00007A70  3158 292C 
00007A74  2D28 4125 
00007A78  3158 29   
00007A7B  00        12210          dc.b      0
                    12211   @m68kde~2_311:
00007A7C  5357 4150 12212          dc.b      83,87,65,80,32,68,37,100,0
00007A80  2044 2564 
00007A84  00        
                    12213   @m68kde~2_312:
00007A86  5441 5320 12214          dc.b      84,65,83,32,0
00007A8A  00        
                    12215   @m68kde~2_313:
00007A8C  5452 4150 12216          dc.b      84,82,65,80,32,35,37,100,0
00007A90  2023 2564 
00007A94  00        
                    12217   @m68kde~2_314:
00007A96  5452 4150 12218          dc.b      84,82,65,80,86,0
00007A9A  5600      
                    12219   @m68kde~2_315:
00007A9C  5453 5400 12220          dc.b      84,83,84,0
                    12221   @m68kde~2_316:
00007AA0  554E 4C4B 12222          dc.b      85,78,76,75,32,65,37,100,0
00007AA4  2041 2564 
00007AA8  00        
                    12223          section   data
00007AAA            12224                   align
          0000 7AAA 12225   DataStart       equ       *
                    12226   
                    12227   *********************************************************************************************************
                    12228   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    12229   * to ram as part of the CStart routine in this file
                    12230   *********************************************************************************************************
                    12231   
                    12232   @itoa_1:
00007AAA  2D32 3134 12233          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
00007AAE  3734 3833 
00007AB2  3634 3800 
                    12234          section   bss
00007AB6            12235                   align
          0000 7AB6 12236   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    12237   
                    12238   *********************************************************************************************************
                    12239   * Section for Uninitialised Data held in ROM as constants
                    12240   *********************************************************************************************************
                    12241   
0B000000            12242                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 000C 12243   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    12244   
                    12245   
0B000000            12246   bss             org       bss
                    12247   
                    12248   *********************************************************************************************************
                    12249   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    12250   * install the exception handler using the C function InstallExceptionHandler()
                    12251   *********************************************************************************************************
                    12252   
                    12253   
                    12254   
0B000000            12255   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            12256   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            12257   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            12258   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            12259   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            12260   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            12261   VCheck           ds.l    1      ditto
0B00001C            12262   VTrapV           ds.l    1      ditto
0B000020            12263   VPrivilege       ds.l    1      ditto
0B000024            12264   VTrace           ds.l    1
0B000028            12265   VLine1010emul    ds.l    1
0B00002C            12266   VLine1111emul    ds.l    1
0B000030            12267   VUnassigned1     ds.l    1
0B000034            12268   VUnassigned2     ds.l    1
0B000038            12269   VUnassigned3     ds.l    1
0B00003C            12270   VUninit_IRQ      ds.l    1
0B000040            12271   VUnassigned4     ds.l    1
0B000044            12272   VUnassigned5     ds.l    1
0B000048            12273   VUnassigned6     ds.l    1
0B00004C            12274   VUnassigned7     ds.l    1
0B000050            12275   VUnassigned8     ds.l    1
0B000054            12276   VUnassigned9     ds.l    1
0B000058            12277   VUnassigned10    ds.l    1
0B00005C            12278   VUnassigned11    ds.l    1
0B000060            12279   VSpuriousIRQ     ds.l    1
                    12280   
                    12281   * Interrupt handlers Vector 25-31
0B000064            12282   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            12283   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            12284   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            12285   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            12286   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            12287   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            12288   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    12289   
                    12290   * Trap Handler vectors 32-47
0B000080            12291   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            12292   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            12293   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            12294   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            12295   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            12296   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            12297   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            12298   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            12299   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            12300   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            12301   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            12302   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            12303   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            12304   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            12305   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            12306   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    12307   
                    12308   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    12309   
                    12310   ***********************************************************************************************************
                    12311   * Other Variables
                    12312   ***********************************************************************************************************
                    12313   *__DebugA5       ds.l    1
                    12314   *__UserA5        ds.l    1
                    12315   
                    12316   ***********************************************************************************************************
0B0000C0            12317   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            12318   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            12319   __heap:         ds.l    0       ; pointers for malloc functions
                    12320   
                    12321   *__himem:       ds.l    himem            ; highest memory location + 1
                    12322   *__stklen:      ds.l    stklen           ; default stack size
                    12323   
                    12324   *********************************************************************************************************
                    12325   * Section for Heap
                    12326   *********************************************************************************************************
                    12327   
                    12328   _i:
0B0000C4            12329          ds.b      4
                    12330   _x:
0B0000C8            12331          ds.b      4
                    12332   _y:
0B0000CC            12333          ds.b      4
                    12334   _z:
0B0000D0            12335          ds.b      4
                    12336   _PortA_Count:
0B0000D4            12337          ds.b      4
                    12338   _Trace:
0B0000D8            12339          ds.b      4
                    12340   _GoFlag:
0B0000DC            12341          ds.b      4
                    12342   _Echo:
0B0000E0            12343          ds.b      4
                    12344   _d0:
0B0000E4            12345          ds.b      4
                    12346   _d1:
0B0000E8            12347          ds.b      4
                    12348   _d2:
0B0000EC            12349          ds.b      4
                    12350   _d3:
0B0000F0            12351          ds.b      4
                    12352   _d4:
0B0000F4            12353          ds.b      4
                    12354   _d5:
0B0000F8            12355          ds.b      4
                    12356   _d6:
0B0000FC            12357          ds.b      4
                    12358   _d7:
0B000100            12359          ds.b      4
                    12360   _a0:
0B000104            12361          ds.b      4
                    12362   _a1:
0B000108            12363          ds.b      4
                    12364   _a2:
0B00010C            12365          ds.b      4
                    12366   _a3:
0B000110            12367          ds.b      4
                    12368   _a4:
0B000114            12369          ds.b      4
                    12370   _a5:
0B000118            12371          ds.b      4
                    12372   _a6:
0B00011C            12373          ds.b      4
                    12374   _PC:
0B000120            12375          ds.b      4
                    12376   _SSP:
0B000124            12377          ds.b      4
                    12378   _USP:
0B000128            12379          ds.b      4
                    12380   _SR:
0B00012C            12381          ds.b      2
                    12382   _BreakPointAddress:
0B00012E            12383          ds.b      32
                    12384   _BreakPointInstruction:
0B00014E            12385          ds.b      16
                    12386   _BreakPointSetOrCleared:
0B00015E            12387          ds.b      32
                    12388   _InstructionSize:
0B00017E            12389          ds.b      4
                    12390   _WatchPointAddress:
0B000182            12391          ds.b      32
                    12392   _WatchPointSetOrCleared:
0B0001A2            12393          ds.b      32
                    12394   _WatchPointString:
0B0001C2            12395          ds.b      800
                    12396   _Instruction:
0B0004E2            12397          ds.b      100
                    12398   _TempString:
0B000546            12399          ds.b      100
                    12400          section   heap
0B0005AA            12401                   align
          0B00 05AA 12402   bssEnd          equ *                   end of storage space for unitialised variables
                    12403   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 05AA 12404   heap   equ       *
0B0005AA            12405                    align
          0000 0000

Assembly errors: 0
